<HTML>
<HEAD>
<TITLE>
ПАТЕНТ США 6.357.008 * Zemsky Fershal //NF (C) 1998-2004
</TITLE>
<STYLE TYPE="text/css">
BODY {font-family:Courier; font-size:10pt;}
PRE  {font-family:Courier; font-size:10pt;}
</STYLE>
</HEAD>
<BODY>
<P><CENTER><IMG SRC="ZF.gif" ALT="ZF"></CENTER></P>
<TABLE ALIGN="center">
<TR>
<TD>
<PRE>
                         ПАТЕНТ США 6.357.008
                      Нашенберг, 12 марта 2002 г.

  МЕТОД ДИНАМИЧЕСКОЙ  ЭВРИСТИКИ ДЛЯ ДЕТЕКТИРОВАНИЯ КОМПЬЮТЕРНЫХ ВИРУСОВ
       С ИСПОЛЬЗОВАНИКЕМ ФАЗ РАСШИФРОВКИ И ИССЛЕДОВАНИЯ.
                         (Избранные фрагменты)

**********  Перевод: Constantin E. Climentieff aka DrMAD **************

Разработчики: Нашенберг; Кэрью С. (Нортридж, Калифорния)
Владелец: Symantec Corp. (Купертино, Калифорния)
Инв. Номер: 935577
Представлен: 23 сентября 1997 г.


                                [. . .]


Что предлагается к рассмотрению:

    1. Метод детектирования вируса в цифровом  файле,  включающий  себя
следующие шаги:
    - определение  хотя  бы одного региона в цифровом файле,  в котором
вирус, вероятно, присутствует;
    - эмуляция кода внутри по  крайней  мере  одного  региона  с  целью
полностью  исследовать  по  крайней  мере  один регион на вирусность во
время исследовательской фазы;
    - позиционирование на эмулируемой инструкции внутри секции кода;
    - определение,  действительно  ли  во   время   фазы   исследования
эмулируемая инструкция уже проэмулирована;
    - если    инструкция,   предназначенная   для   эмулирования,   уже
проэмулирована во время исследовательской фазы, то должна эмулироваться
следующая непроэмулированная инструкция.

    2. Подметод метода 1,  при котором  исследуемым  регионом  является
конец цифрового файла.

    3. Подметод  метода  1,  при  котором исследуемым регионом является
начало цифрового файла.

    4. Подметод метода 1,  при котором  шаг  эмуляции  кода  внутри  по
крайней  мере  одного региона с целью полностью исследовать как минимум
один регион во время фазы исследования предполагает  включать следующие
шаги:
    - определение,     действительно    ли    эмулируемая    инструкция
располагается вне выбранного региона;
    - если эмулируемая инструкция вне выбранного  региона,  то  она  не
эмулируется.

    5. Подметод метода 4, который предполагает включать следующие шаги:
    - определение, осталась ли какая-нибудь нерассмотренная ветвь;
    - и  если  такая  ветвь  осталась,  то  позиционирование на команду
следующей нерассмотренной ветви, установка текущего состояния эмулятора
CPU в сохраненное состояние,  соответствующее следующей нерассмотренной
ветви.

    6. Подметод метода 5, который предполагает включать следующие шаги:
    - если  не  осталось  нерассмотренных  ветвей,  то  определение   -
осталась ли хотя бы одна непроэмулированная секция кода в регионе;
    - и  если  такая  секция  осталась,  то перемещение указателя на ее
начальную инструкцию, как на инструкцию, предназначенную для эмуляции и
сброс эмулятора CPU в исходное состояние.

    7. Подметод метода 4, в котором эмуляция инструкций включает:
    - определение, является ли инструкция подозрительной операцией;
    - фиксирование  подозрительной  операции,  если предназначенная для
эмуляции инструкция выполняет подозрительную операцию.

    8. Подметод метода 4, в котором эмуляция инструкций включает:
    - определение, является ли эмулируемая инструкция прерыванием;
    - если это прерывание,  то имитировать результаты  его  работы,  но
реально прерывание не выполнять.

    9. Подметод метода 4, в котором эмуляция инструкций включает:
    - определение, является ли эмулируемая инструкция командой записи в
память по крайней мере в один из регионов;
    - и если она таковой является,  то перенаправление записи в  другой
сегмент S.

    10. Подметод метода 9, в котором эмуляция инструкций включает:
    - определение, действительно ли эмулируемая инструкция предполагает
чтение из области памяти, перенаправленной в сегмент S;
    - и если это так, то перенаправление чтения на сегмент S.

    11. Подметод метода  4,  в  котором  эмуляция  инструкций  включает
следующие шаги:
    - определение,  действительно ди  эмулируемая  инструкция  означает
начало новой ветви алгоритма;
    - и если это так,  то  запоминание  нерассмотренного  ранее  адреса
перехода  на  ветвь  и  стсотяния  эмулятора CPU,  соответствующее этой
точке.

    12. Метод  детектирования   компьютерного   вируса   в   программе,
включающий:
    - первый  этап эмуляции инструкций рассматриваемой программы, чтобы
позволить вирусу расшифровать виртуальное тело;
    - определение как минимум одного рогиона рассматриваемой программы,
в котором присутствует расшифрованное вирнтуальное тело;
    - второй  этап  эмуляции  инструкций  как  минимум  одного  региона
рассматриваемой программы, в котором присутствует виртуальное тело;
    - оценивание  подозрительных  операций  во  время первого и второго
этапов эмуляции с целью детектировать компьютерный вирус.

    13. Подметод  метода  12,  где  первый  этап  эмуляции начинается с
первой инструкции в точке входа изучаемой программы.

    14. Подметод метода  12,  где  второй  эта  эмуляции  начинается  с
инструкции,   непосредственно   следующей   за  последней  инструкцией,
проэмулированной на первом этапе.

    15. Подметод  метода  15,  где  во  время  первого  этапа  эмуляции
компьютерный  вирус  не  расшифровывает вирусное тело,  поскльку оно не
зашифровано;  и  в  этом  случае  второй  этап  эмуляции  начинается  с
инструкции, лежащей в точке входа исследуемой программы.

    16. Подметод метода 12, где определяется, действительно ли вирусное
тело расшифровано,  посредством определения непрерывной секции байтов в
памяти, которые были перезаписаны во время первого этапа эмуляции.

    17. В   компьютерной   системе  метод  детектирования  компьютерных
вирусов включает следующие шаги:
    - эмуляцию инструкций исследуемой программы;
    - оценивание рассматриваемых  иснструкций  во  время  эмуляции  для
обнаружения компьютерных вирусов;
    - остановку оценивания если встретилась безобидная операция или нет
больше подозрительных операций.

    18. Подметод  метода 17,  где невинная операция включает печать или
изображение символа.

    19. Подметод метода 17,  где невинная операция включает  инструкцию
завершения программы в опрределенном программном регионе.

    20. Подметод    метода   17,   где   невинная   операция   включает
ревекторизацию вектора ошибки.

    21. Подметод  метода  17,  где  невинная  операция  включает  вызов
функции, удаленной от текущей точки.

    22. Подметод метода 17, где очень подозрительной операцией является
сравнение содержимого регистра или ячейки памяти с сигнатурой файлового
заголовка.

    23. Подметод метода 17, где очень подозрительной операцией является
запись  в  файл  определенного  количества   байтов,   соответствующего
количеству  байтов от точки входа до конца файла исследуемой программы.

    24. Подметод метода 17, где очень подозрительной операцией является
переход (SEEK) на конец файла,  следующий за записью в него  инструкции
JMP.

    25. Подметод  метода  24,  где  операция  SEEK  определяет  длину в
байтах, а команда JMP выполняется на равное или большее расстояние.

    26. Подметод метода 17, где очень подозрительной операцией является
запись  количества байтов,  равного размеру заголовка,  а записываемыке
данные содержат признаки заголовка.

    27. Подметод метода 17, где очень подозрительной операцией является
нахождение заголовка исполняемого файла в теле исследуемой программы.

    28. Подметод метода 17, где очень подозрительной операцией является
поиск исполняемых файлов в каталоге.

    29. Подметод метода 17, где очень подозрительной операцией является
исследование или модификация схемы распределения памяти.

    30. Подметод метода 17, где очень подозрительной операцией является
одна  или  более   операций   пересылки   строк,   которые   перемещают
приблизительно  такое  же  количество байтов,  как количество байтов от
точки входа до конца файла исследуемой прогаммы.

    31. Метод детектирования вируса в исследуемой программе, включающий
шаг детектирования присутствия операции перехода (seek) на конец файла,
следующей  за  записью  инструкции  JMP,  где  SEEK определяет размер в
байтах, а JMP производится на равное или большее расстояние.

                               Описание.

                             1. Приложения

                         A. Техническая часть

    Это изобретение относится к антивирусному программному обеспечению.
Более  конкретно,  это изобретение относится к программному обеспечению
для детектирования неизвестных компьютерных  вирусов  с  использованием
эмуляции и искусственного интеллекта.

                      B. Сопутствующая информация

    Технология обнаружения компьютерных вирусов может быть подразделена
на такие категории  как,  например,  сканирование  сигнатуры,  проверка
целостности,  и  не  основанное  на проверке целостности детектирование
неизвестных вирусов (также  называемое  эвристикой).  Данный  раздел  и
обсуждает эти категории антивирусной технологии.

    Сканирование сигнатур   в   антивирусных   программах  основано  на
сканировании файлов для поиска сигнатур  известных  вирусов.  Сигнатура
представляет   собой  последовательность  байтов,  которые  могут  быть
обнаружены  в  вирусном  программном  коде,  и  более   ничего.   Чтобы
&quot;извлечь&quot; сигнатуру,  вирусолог  должен предварительно проанализировать
вирус.  Как только эта сигнатура будет определена,  она записывается  в
базу   данных   вирусных  сигнатур,  которыми  пользуется  антивирусная
программа.  Антивирусная программа сканирует  подозрительную  программу
(исполняемый  файл,  загрузочную  запись  или макрос внутри документа),
чтобы  обнаружить  присутствие  вирусной  сигнатуры.   Если   сигнатура
обнаружена,  тогда программа посчиталась зараженной. В противном случае
программа считается неинфицированной.

    Сканирование сигнатур   антивирусом   позволяет    идентифицировать
конкретные  вирусные  типы  и  может  иметь  низкий  уровень показателя
&quot;ложное срабатывание&quot;,  если правильно осуществляется.  Тем  не  менее,
только  вирусы,  чьи  подписи  уже определены и загружены в базу данных
сигнатуры,  могут быть обнаружены,  используя  сканирование  сигнатуры.
Кроме того,  база данных сигнатуры должна часто корректироваться, чтобы
обнаруживать самые последние вирусы.

    Проверка целостности    (в    терминах    Norton    Anti-Virus    -
&quot;inoculation&quot;),   -   техника,   в   которой  предварительно  снимаются
&quot;отпечатки пальцев&quot; программ (выполняемых файлов,  загрузочных записей)
в  предположении,  что  все  эти  файлы  находятся  в  неинфицированном
состоянии.  Эти отпечатки пальцев  обычно  снимаются  после  того,  как
компьютер   будет   отсканирован  вирусным  сканером,  что  гарантирует
незараженность компьютера.  Эти отпечатки пальцев затем сохраненяются в
базу данных для последующей проверки целостности.

    В течение  последующей  проверки целостности антивирусная программа
проверяет,  какие программы изменили отпечатки пальцев.  Если программа
не  соответствует  своему  отпечатку пальца,  то антивирусная программа
обычно использует  искусственный  интеллект,  чтобы  определить  -  эта
модификация  похожа  на  или просто законное изменение программы.  Если
модификация появляется из-за инфекции вирусом,  антивирусная  программа
обычно   предупреждает   пользователя  о  модификации  и  предоставляет
пользователю возможность исправить повреждения, если это возможно.

    Поскольку проверка целостности не сканирует вирусные сигнатуры, она
может быть использована,  чтобы обнаруживать новые и (пока) неизвестные
вирусные типы.  Проверка целостности актуальна, поскольку вирусы обычно
измененяют зараженную программу, и эти изменения могут быть обнаружены,
если база данных отпечатков пальцев чистых программ правильно создана и
поддерживается.  Тем не менее,  проверка целостности не работает,  если
компьютер  не  является  свободным  от  вирусов  во  время   снятия   и
запоминания   отпечатков   пальцев.   Зараженная   вирусная  программа,
отпечатки пальцев которой сохранены в  базе  данных  вместе  с  другими
чистыми программами,  будет безопасной гаванью,  из которой вирус может
заразить другие программы.  Кроме того,  когда изменение обнаруживается
проверкой  целостности,  часто  очень трудно для антивирусной программы
определить  -  изменение  было  порождено  вирусом  или   пользователем
(например,  пользователь может скорректировать программу,  устанавливая
новую версию или копируя скорректированный файл).  Если это определение
не  может быть сделано антивирусной программой,  то пользователь должен
быть вызван, чтобы принять решение, но многие пользователи недостаточно
опытны, чтобы сделать это.

    Детектирование, не   основанное   на  проверке  целостности  (также
называемое &quot;эвристическим&quot;),  используется,  чтобы обнаруживать новые и
неизвестные  вирусы  без  какой-либо  проверки  целостности информации.
Эвристическая антивирусная программа изучает  подозрительную  программу
(исполняемый   файл,   загрузочная   запись,  документ  с  макросом)  и
анализирует  программный  код,  чтобы  определять  -  является  ли  код
подобием  вируса.  Если подозрительный программный код похож вирус,  то
пользователю сообщается о возможной инфекции.

    Эвристическое вирусное  обнаружение  может   обнаружить   новые   и
неизвестные  вирусы,  которые  еще  не  проанализированы  антивирусными
исследователями,  поскольку  оно  не  использует  вирусные   сигнатуры.
Поскольку эвристическая техника не использует информацию о целостности,
она не требует отпечатков  пальцев  программ,  которые  нужно  брать  и
сохранять, пока компьютер находится в чистом состоянии.

    Эвристическое вирусное  обнаружение может быть классифицировано как
статическое или  динамическое.  Основное  различие  между  этими  двумя
схемами  обнаружения в том,  что динамический метод использует эмуляцию
CPU, а статический метод нет.

                          I. Статическая эвристика

    При статическом детектировании вирусов антивирусная  программа ищет
в   подозрительной  программе  последовательности  инструкций,  которые
типичны  для   вирусов.   В   отличие   от   вирусных   сигнатур,   эти
последовательности   не  соответствуют  какому-то  конкретному  вирусу.
Вместо этого, они имеют наиболее общий характер, специфичный для многих
различных вирусов.

    Например, следующая      последовательность      инcтрукций     x86
(микропроцессора Intel) может быть использована для открытия файла:

Ассемблер                  Машинный код
MOV DX, ????               BA ?? ??
MOV AX, 3D02               B8 02 3D
INT 21                     CD 21

    где &quot;??&quot;  индицирует,  что  этот  байт  может  различаться в разных
вирусах.  Соответственно,  следующая последовательность  инструкцуий  в
коде x86 может быть использована для записи в файл:

Ассемблер                  Машинный код
MOV DX, ????               BA ?? ??
MOV CX, ????               B9 ?? ??
MOV AX, 4000               B8 00 40
INT 21                     CD 21

    где &quot;??&quot; снова соответствует переменным байтам.

    Антивирусная программа     со     статической    эвристикой    ищет
последовательности байтов типа тех, которые показаны выше, затем делает
заключение    о    вирусной    инфекции,    основанное    на   найденых
последовательностях.    Например,    если    антивирусная    программа,
использующая статическую эвристику,  обнаружит операцию открытия файла,
следующую за операциями чтения и записи,  а так  же  символьную  строку
&quot;VIRUS&quot;   внутри   программы,   то  она  может  рапортавать,  что  файл
инфицирован неизвестным вирусом.

    Некоторые (самошифрующиеся)     компьютерные      вирусы      имеют
закодированные  вирусные тела.  Последовательность инструкций,  которые
определяют  вирусоподобное  поведение,  не  могут  быть  обнаружены   в
закодированном   файле.   Поэтому   некоторые  антивирусные  программы,
выполняющие статическое детектирование,  предварительно  расшифровывают
программы в эмуляторе CPU.

    Несмотря на  то,  что  статические  эвристики  могут  быть довольно
быстрыми,  они могут распознавать только небольшое количество различных
вариантов   вирусоподобных  операций.  Например,  вирусописатель  может
переставить местами инструкции в последовательности открывания файла:

Ассемблер                  Машинный код
MOV AX, 3D02               B8 02 3D
MOV DX, ????               BA ?? ??
INT 21                     CD 21

    Как еще   более  продвинутый  пример,  вирусописатель  может  более
радикально изменить инструкции открытия, типа:

Ассемблер                  Машинный код
MOV AX, 3E00               B8 00 3E
SUB AX, 0100               2D 00 01
MOV DX, 1234               BA 34 12
ADD AL, 02                 04 02
INT 21                     CD 21

    Таким образом,   статическая  эвристика  должна  содержать  в  себе
большое количество вариантов  вирусоподобных  операций,  чтобы  реально
обнаруживать  вирусоподобное  поведение.  Использование  баз данных для
хранения  больного  количества  возможных  пермутаций  может  оказаться
просто  нереализуемым.  Эта  проблема  становится еще актуальней,  если
вирусописатель использует  &quot;генератор  вирусов&quot;,  который  одновременно
генерирует тысячи вирусов,  в которых перемешаны отдельные инструкции и
секции кода,  но не изменено  эффективное  поведение.  Такое  множество
вирусов  должно привести к большим осложнениям при попытке использовать
для их поиска статическую эвристику.

                      II. Динамическая эвристика

    При динамической   эвристике   антивирусная   программа   эмулирует
подозрительную   программу   в   виртуальной   среде   и  наблюдает  за
эмулируемыми инструкциями на предмет вирусных  действий. Вирусоподобные
действия  определены  заранее и внесены в каталог.  Пользуясь каталогом
вирусных   действий,   динамический    эвристик    может    определить,
действительно  ли  исследуемая  программа  выглядит  похоже  на  вирус.
Естественно,  если  вирус  имеет  закодированное  вирусное  тело,  этот
динамический метод эмуляции может позволить вирусу декодироваться перед
тем,  как наблюдать за  вирусоподобными  действиями  (открытие  файлов,
поиск файлов, и т.п..).

    Динамическая эвристика  может  обнаружить  множество  разнообразных
перестановок какого-нибудь  действия  гораздо  проще,  чем  статический
эвристический метод.  Например,  рассмотрим динамическое детектирование
файловых операций.  Всякий раз,  когда  прерывание  вызывается  в  ходе
эмуляции,  динамическая  эвристика проверяет значения в регистрах.  Эти
значения определяют то действие,  которое исследуемая  программа  хочет
потребовать   выполнить  от  операционной  системы.  Как  сказано  выше
относительно   статической   эвристики,   вирус,   заражающий   целевую
программу,  может  решить  помещать  определенные  значения  в регистры
многими способами.  Тем не менее,  когда  прерывание  наконец  вызвано,
регистры   должны   содержать  вполне  определенные  значения,  которые
характеризуют желаемое действие.  Динамическая эвристика должна  только
отслеживать значения регистров на момент вызова прерывания.

    Несмотря на  то,  что  динамическая  эвристическая техника - высшее
достижение в области распознавания вирусоподобных  действий, существуют
по крайней мере три проблемы. Они обсуждаются далее.

    Во-первых, продвинутая  эмуляция  может  потребоваться прежде,  чем
вирусоподобные действия произойдут.  Например,  вирус  может  выполнить
холостой  цикл  50000  раз  перед  обращением  к  файлу.  В этом случае
огромное  число  инструкций  должно  быть  проэмулировано  прежде,  чем
начнется собственно работа с файлами.  Это должно существенно замедлить
антивирусную программу.

    Во-вторых, некоторые вирусы активизируются только  когда выолняются
определенные   произвольные  условия.  Например,  рассмотрим  следующий
псевдокод вируса:

    1. Найти первый файл в текущем каталоге,  который имеет  расширение
&quot;.com&quot; (*.com).
    2. Если файл был обнаружен, перейти на Шаг 4.
    3. Вернуть управление в главную программу.
    4. Если файл менее чем 1000 байтов длиной, перейти на Шаг 3.
    5. Если файловое имя не заканчивается в &quot;EL&quot;, перейти на Шаг 3.
    6. Открыть файл.
    7. Прочитать первые 3 байта.
    8. Перейти на конец файла.
    9. Записать вирусные байты в файл. 10. и т.п..

    Если динамическая  эвристика  должна эмулировать главную программу,
зараженную таким вирусом,  она неминуемо начнет с  Шага  1,  в  котором
указывается,  что  необходимо  находить  первый  *.com  файл  в текущем
каталоге.  Здесь антивирусная программа может сымитировать вызов DOS  и
обмануть вирус, что фиктивная *.com программа была обнаружена.

    Впоследствии, на  Шаге  4,  эмулятору  указано,  чтобы он возвратил
управление от вируса главной программе,  если фиктивная *.com программа
имела  файловый  размер  менее 1000 байтов.  Как антивирусная программа
собирается проверить такое произвольное условие?

    Возможно антивирусная программа будет счастливой и  фиктивная *.com
программа   имела   файловый   размер  по  крайней  мере  1000  байтов.
Впоследствии,  на Шаге 5,  эмулятору указывается,  чтобы  он  возвращал
управление   из   вируса   главной  программе,  если  файловое  имя  не
заканчивается на &quot;EL&quot;. Снова, если этот критерий не встречен (например,
файловое имя - &quot;FOO.COM&quot; и заканчивается на &quot;OO&quot;),  то вирус немедленно
завершится и передаст управление в главную программу.

    Таким образом,  вирус  может  быть  очень  &quot;разборчивым&quot;  в   своем
процессе инфицирования, и если любой критерий (как например, дата - 5-е
число месяца) не встречен,  то  вирус  не  выполнит  свое  инфицирующее
поведение.   Следовательно,   динамическая  эвристическая  антивирусная
программа не пронаблюдает инфицирующее поведение и не  обнаружит вирус.

    В-третьих, это  только  вирус  &quot;прямого  действия&quot;  (как  например,
примеры,  обсужденные выше) заражает другие программы сразу при запуске
зараженной программы, а вот резидентный вирус просто устанавливает себя
как   резидентный  обработчик  прерываний  и  следит,  пока  подходящее
прерывание не будет  вызвано.  После  установки  себя  как  резидентный
обработчик   прерывания,  резидентный  вирус  возвращает  управление  в
главную программу.

    Динамическая эвристическая антивирусная программа начинает эмуляцию
в  точке  входа  исследуемой  программы.  Тем  не  менее,  инфекционный
вирусный код (часть вируса, которая заражает другие программы) не может
быть достигнут непосредственно. Вместо этого, инфицирующий вирусный код
выполняется только когда выполнится прерывание,  перехваченное вирусом,
и  такое  обращение  к  операционной  системе  может быть сделано любой
другой программой, а не исследуемой.

    Так, даже если динамическая  эвристическая  антивирусная  программа
эмулирует   зараженную   программу  сколь  угодно  долго,  инфекционный
вирусный код не может быть достигнут,  и таким образом,  подозрительные
вирусные действия могут остаться необнаруженными.

                       II. ВЫВОДЫ ПО РАЗРАБОТКЕ

    Выше описаны  проблемы,  которые  были  преодалены  в  предлагаемой
разработке.  Настоящая  разработка  относится  к  методам  динамической
эвристики  и  предназначена  для  детектирования компьютерных вирусов в
процессе трех фаз выполнения:  фазы расшифровки,  фазы  исследования  и
фазы   оценивания.   Цель  фазы  расшифровки  -  эмулировать  требуемое
количество инструкций,  необходимое вирусу для дешифрования собственого
тела.  Цель  фазы  исследования  -  эмулировать как минимум однажды все
достижимые секции кода в регионе  программы,  который  может  содержать
вирус.  Цель  фазы  оценивания  - проанализировать любое подозрительное
действие  во  время  расшифровки   и   исследования   для   определения
инфицированности программы.


                   III. КРАТКОЕ ОПИСАНИЕ ИЛЛЮСТРАЦИЙ

                                [. . .]

------------------------------------------------------------------------
Перевод: Constantin E. Climentieff aka DrMAD



</PRE>
</TD>
</TR>
</TABLE>
<HR>
<CENTER>(C) NF, 1998-2004</CENTER>
</BODY>
</HTML>
