<HTML>
<HEAD>
<TITLE>
Мутационные технологии * Zemsky Fershal //NF (C) 1998-2004
</TITLE>
<STYLE TYPE="text/css">
BODY {font-family:Courier; font-size:10pt;}
PRE  {font-family:Courier; font-size:10pt;}
</STYLE>
</HEAD>
<BODY>
<P><CENTER><IMG SRC="ZF-2.gif" ALT="ZF"></CENTER></P>
<TABLE ALIGN="center">
<TR>
<TD>
<PRE>
                     Мутационные технологии
                            by JHB

             ( Вольный перевод - DrMad, 1998 г. )

    Как только  я  впервые  услышал про идею Мутационной Технологии,  я
заинтересовался в том,  чтобы увидеть код,  который мог бы объяснить  -
как  может  работать  фрагмент  непостоянного кода.  Я заимел несколько
вирусов,  но большинство Мутационных Технологий  в  соответствии  с  их
природой  были сложны для дизассемблирования.  Так,  после знакомства с
кодом других авторов, я решил попытаться приложить свои ручонки к этому
типу  программирования.  Данная статья проиллюстрирует путь,  который я
избрал при разработке и реализации Мутационной Технологии.

    Для начала  я попытаюсь определить,  что такое Мутационная
Технология,  ее код, который может быть прилинкован или просто
присоединен к обычной программе или вирусу. Она:

    1. Расшифровывает себя,  также, как и программу, к которой
прилинкована.
    2. Создает  Расшифровщик,  который будет выполняться перед
основной программой.
    3. Каждый  Расшифровщик,  который  она  создает,  имеет   различные
сигнатуры.

    Хорошо, теперь давайте разъясним это определение,  сигнатура (когда
говорят о коде) - это фрагмент кода, который должен быть уникальным для
этого кода. Примером может служить сигнатура:

        EA 05 00 C0 07

    Которая является 16-ричным кодом для команды

        jmp     07c0:0005

    Это (как могут отметить многие) - первая строка кода вируса Stoned,
хотя  даже  и  этот  маленький  кусочек  кода,  помещенный   в   начале
загрузочного сектора, используется многими а/в продуктами, как признак.
(Далее не проверялось).

    Простейшая Мутационная Технология состоит в  том,  чтобы  полностью
заменять  код  на  другой,  делающий  то же самое,  но это увеличило бы
размеры Технологии.  Создатели Мутационных  Технологий  изобрели  более
легкий  способ,  заключающийся  в  том,  что они шифруют основной код и
Технологию,  затем делают расшифровщик первым выполняющимся фрагментом.

    Это означает,  что единственая сигнатура,  которая  должна
изменяться - это расшифровщик,  и это основной тип современных
Технологий.

    Первой частью     процесса     создания     является      генерация
шифровщика/расшифровщика,  который  должен выполнять достаточно простую
шифровку.  Я игрался со стандартными xor/add/sub,  но  они  вскрываются
немедленно  расшифровщиками  TBAV  и  F-prot.  Поскльку  основная  идея
Мутационной Технологии - обдуривать и людей и сканеры,  то это не самый
лучший путь.  Во время чтения конференций usenet я обнаружил упоминание
шифровки,  которая использует shl/shr. Многие могут быть удивлены, если
Вы  используете  shl/shr,  поскольку  либо  старший,  либо  младший бит
пропадают,  но это не совсем так,  ибо они  помещаются  в  флаг  carry.
Простым  добавлением этого бита к концу или началу регистров (или слов)
вы  можете  поиметь  реверсивную  шифрацию.  Сейчас  TBAV  обнаруживает
большинство  таких  шифровок,  исключая  четные количества сдвигов типа
2,4,8,  в то время  как  F-prot,  кажется,  пропускает  большинство  их
(только при эвристическом анализе и ключе /paranoid ).  ( Говорят,  это
потому чо shl 2,4,  8 может использоваться для быстрого  умножения  или
деления, так что TBAV не отмечает это как шифровку). Итак, я немедленно
использовал это для шифровки

             mov bx,offset virus_code
decrypt:
             mov     cx,4        ; ключ шифрации
             mov ax,cs:[bx]      ; взять слово для шифровки
again:
             clc                 ; не нужно, но я был юн, сорри <FONT FACE="Wingdings">J</FONT>
             shl     1           ; ок, т.к. код перед этим был
                                 ; ax 1000 0000 0000 0000 cf = 0
                                 ; после shl
                                 ; ax 0000 0000 0000 0000 cf = 1
             jnc     no_high_bit ;
             inc     ax          ; это просо делает ax =
                                 ; ax 0000 0000 0000 0001
no_high_bit:
             dec     cx
             jcxz    done_unencr ; нормально завершено, двигаем дальше
             jmp     short again ; двигаем дальше
done_enencr:
             mov     cs:[bx],ax  ; Запоминаем расшифрованный код
             add     bx,2        ; двигаем наш указатель
             dec     dx          ; проверяем, сколько осталось
             jnz     decrypt

virus_code:

    Ок, теперь  у  нас  есть расшифровщик,  который использует shr и Вы
имеете шифрующую процедуру ( она в коде, который Вы читаете ;) ).

    Все нормально до этого момента,  поскольку у  меня  есть  шифрующая
Технология,  которая будет обдуривать TBAV и F-prot (вне зависимости от
того,  что Вы используете f-prot  /paranoid,  чего  даже  и  не  делают
обычные средние пользователи),  но это не Мутационная Технология.  Дык,
простейшая  мутация  состоит  в  том,  чтобы  изменять  регистры,   это
простейшая  вещь  всего лишь требует небольших исследований или хорошей
книжки по ассемблеру. Все команды ассемблера строятся по образцу

                        push    ax          что в 16-м будет
                        50h  или 1001 0000b
                                            теперь
                        push    bx          имеем
                        53h  или 10010 011b

    Обратите внимание,  что 3 последних  бита  -  единственная
вещь, которая изменяется при изменении словных регистров

                        ax = 000  0
                        cx = 001  1
                        dx = 010  2
                        bx = 011  3
                        sp = 100  4
                        bp = 101  5
                        si = 110  6
                        di = 111  7

    ОК, при помощи простейших команд and/or мы можем  изменить регистры
на другие, и, конечно, мы должны менять их случайным образом, проверяя,
какие мы уже использовали и имея в виду,  что мы заменяем все bx на cx.

    В этом месте некоторые люди начнут путаться, потому что мы начинаем
готовить исполнимый код,  к которому  намереваемся  обращаться,  как  к
данным. Посмотрите на примерчик:

                mov     cx,0004         ;b90400h

превращается в

shift_reg:
                db      0b9h            ;10111 001  &lt;- cx
                dw      0004

    Теперь мутация для этого кода может выглядеть как

                mov     ax,[shift_reg]    ;
                and     ax,11111000h      ; это изолирует
                                          ; команду mov
                or      ax,00000111       ; это готовит команду
                                          ; mov di

    Лучший способ  заключался  бы  в  генерации   случайных   чисел   и
извлечении   числа   в  границах  0-7,  затем  в  операции  OR  его  на
использованную мной константу. Конечно, вы должны отслеживать регистры,
котолрые вы уже использовали и какие только собираетесь.

    Теперь, используя эту технику, мы получили ограниченную Муnационную
Технологию,  но не забудьте,  что F-prot все еще  ловит  ее.  Следующая
простая  мутация  заключается в использовании недокументированной формы
команды shl.

        shl AX,1        D1 E0    1101 000 1 1110 0000 &lt;-Обычно
        SHL AX,1        D1 F0    1101 111 1 1110 0000 &lt;-Недокум

        SHL AX,1        C1 E0 01                      &lt;-Обычно
        SHL AX,1        C1 F0 01                      &lt;-Недокум


        D1 F0           &lt;-Кажется, FP и TB не найдут это

    Теперь несколько необычная часть:  пока весь приведенный код делает
аналогичные вещи, сдвигаем биты в регистре АХ влево при помощи F0h, что
не поддерживается большинством ассемблеров. ( Тем не менее, я читал про
шареварный ассемблер, который может использовать эти коды, и, вероятно,
трассировщик,       понимающий      такой      код).      Использование
&quot;недокументированной&quot; формы будет обдуривать F-Prot каждый раз,  но  на
байты  C1 F0 01 будет вставать TBAV-флажок (как же я люблю этот флажок)
&quot;Обнаружена по крайней мере одна инструкция,  которая  требует  налиция
процессора 80186 или выше&quot;. Как будто бы после 8086 в систему команд не
добавлялись новые инструкции!!  Но для сгененированного вирусного  кода
это не тот флаг,  который вам хотелось бы видеть. И вообще, любой флаг,
которого там нет, будет вызывать проблемы.

    ОК, итак мы имеем простую мутацию простого  реверсивного шифровщика
и  как  минимум 4 формы расшифровывающего кода,  не содержащего мутации
регистров.  Следующая часть - это примочка,  которая ничего не  делает,
или мусорный код. Эту фигню надо вводить в действие осторожно. Мусорные
инструкции или Бесполезные байты - это те, которые делают нечто, но это
не влияет на ваш код.  Примеры такого кода - команды NOP и XCHG AX, AX.
В прежние  времена  мутационных  технологий  и  эвристических  сканеров
простое   добавление   NOP-ов   и   XCHG   делало  вирус  устойчивым  к
сканированию.  Но по мере того,  как  сканеры  совершенствовались,  они
научились не обращать внимания на мусорный код или предупреждать юзера,
что имеется код,  кторый не может служить ничему,  кроме  как  сокрытию
вируса.  И  снова  я считаю,  что вы могли бы использовать некоторые из
этих идей,  но имейте в виду,  что два или более NOP-а подряд  возбудят
TBAV.   Итак,   я   подумал,   что  вместо  использования  однобайтовых
инструкций,  почему бы не иметь процедурок,  которые используют  вызовы
прерываний. Просто найдите такие, которые не влияют на многие регистры,
или сохраняйте/восстанавливайте регистры,  это не повлияет на  реальный
код. Пример:

noise_6:
        push    ax           ;1 для использования сдвигов
        mov     ax,0200h     ;3 достаточно сохранить и восста-
        int     16h          ;2 новить AX
        pop     ax           ;1
end_noise_6:

    Используйте эти идеи совместно,  и вы  можете  получить  интересный
фрагмент   кода,   который   будет   генерировать   различные  варианты
расшифровщиков.  А мне  больше  и  не  нужно.  Если  вам  действительно
интересно,  как  хулиганить  с  использованием  Мутационных Технологий,
разберите несколько исходничков и попытыйтесь сделать  что-нибудь свое.
Даже  если  вы  обломитесь при производстве работоспособной Мутационной
Технологии,  вы поймете про них очень многое. Я, вообще, и не собирался
делать из моего кода реальную технологию, это только примерчик - и все.

</PRE>
</TD>
</TR>
</TABLE>
<HR>
<CENTER>(C) NF, 1998-2004</CENTER>
</BODY>
</HTML>
