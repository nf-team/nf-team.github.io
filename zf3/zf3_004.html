<HTML>
<HEAD>
<TITLE>
Введение в Windows 95 от Quantum/VLAD * Zemsky Fershal //NF (C) 1998-2004
</TITLE>
<STYLE TYPE="text/css">
BODY {font-family:Courier; font-size:10pt;}
PRE  {font-family:Courier; font-size:10pt;}
</STYLE>
</HEAD>
<BODY>
<P><CENTER><IMG SRC="ZF-2.gif" ALT="ZF"></CENTER></P>
<TABLE ALIGN="center">
<TR>
<TD>
<PRE>
             Введение в Windows 95 от Quantum/VLAD
            -------------------------------------

             ( Вольный перевод (с) DrMad, 1998 )

    Когда Vladы  начали работать над Win95-проблемами (еще до того, как
появился WinSurfer),  все мы до этого знакомы были только с Win32s  для
Win  3.1,  что  позволяло  пользователям  Win  3.1 выполнять (не всегда
успешно) 32-битные приложения для Win95/NT.  Однажды,  трасируя код, мы
обнаружили,  что  все  стартующие  ЕХЕ  загружаются  с  РЕ-заголовком и
регистром EAX,  указывающим на него,  а также переходя на  точку  входа
(jmp [eax+28h]).  Так мы заменили указатель на входную точку RVA на наш
код, втолкнули EAX в стек, выполнили наш код, извлекли EAX и перешли на
[eax+28h].  Это  работало,  мы  получили  Win32s-инфектор,  но затем мы
обнаружили,  что у нас никак не получается собственно инфицирование. Не
было int-ов и мы действительно ощущали свою беспомощность,  но мы нашли
совершенный способ,  чтобы устанавливать  резиденты  без  инфицирования
оболочки  Win3.  1,  и  так родился PH33R.  И тут я отпал с паническими
криками криками &quot;Боже,  я сейчас сдохну&quot;, и это означало конец проекту,
связанному с Win32s/95/NT.

    Но сейчас  паника  прошла.  У  меня каникулы,  я отдыхаю от школы и
работы в Win95,  и я решил попробовать еще раз. Неожиданно jmp [eax+28]
не  сработал,  это  было  побочным  эффектом  в Win32s.  Вместо этого я
вычислил расстояние между концом ЕХЕ и точкой  входа,  вычислил  начало
вирусного кода и вычел двойку.  Это сработало, и я получил инфектор для
Win95/NT. Оставалась фигня - вызывать API...

  День, когда перевернулся мир
  ----------------------------

    Поначалу были  известны адреса памяти и мы игрались с ними на нашем
компьютере,  записывая туда и считывая оттуда.  И это было классно.  Но
это  было  еще  не  все,  на  горизонтах  маячил &quot;порт&quot; и потихоньку мы
изучали связь с внешними устройствами, используя in и out.

    Через некоторе время компьютер стал уже привычным и  нам захотелось
чего-то   новенького.   Нам   требовался  способ  непрямого  доступа  к
аппаратуре,  и  появились  прерывания.  Не  всем  понравилась   система
прерываний,  но  вскоре мы научились жить с ними,  манипулировать ими и
использовать для наших надобностей.

    Все так и делали,  исключая одну команду в Майкрософте  -  чуваков,
которые  написали &quot;революционную&quot; оболочку и назвали ее &quot;Windows&quot;.  Эти
парни искали способ разделить все функции, которые раньше были доступны
через  прерывания,  по отдельности,  используя общие файлы,  называемые
Динамическими Библиотеками Связи (DDL).  И родился Интерфейс Прикладных
Программ (API). API сделали вызов функций существенно сложнее и иногда,
предположительно,  вообще недоступным.  Но  чуваки  из  Майкрософта  не
отказались совсем от прерываний,  и мы еще имеем некоторый контроль над
системой с помощью DPMI.

    Затем парни  из  Майкрософта  выпендрились  снова.   Их   последнее
изобретение запретило прерывания,  порты и доступ к памяти. Их &quot;Windows
95/NT&quot; - настоящая  приоритетная  многозадачная  система,  или  другими
словами  -  ничего  себе  штучка.  Этот людоедище утаптывает программы,
сжимает  их  в  ограниченном  пространстве,   ограничивает   доступ   к
запрещенным  областям и,  хуже всего,  вынуждает их использовать новый,
невозможно сложный метод вызова API.

    И это вынудило нас...

  Одна пьяная ночь в Майкрософте
  ------------------------------

    Когда чуваки в Майкрософте хотят выпить, они берут - и выпивают. Но
прежде чем бегать  кругами  в  полицейских  кальсонах  на  своей  общей
коллективной голове и пи$дить монетки из автобусных касс,  они изобрели
новую конструкцию вызовов.

    В духе  Windows  3.1  парни  из   Майкрософт   нашли   альтернативу
прерываниям.  В  других  случаях  это было хорошо - программеру не надо
проверять,  есть ли DLLы в памяит (даже если они могут делать  это),  и
они  могут  установить  те  DLLы,  которые  им нужны.  Способ,  который
изобоели в Майкрософте - это Таблицы Иморта и Экспорта. Таблица Импорта
заставляет программера постулировать - какие функции из каких DLLов ему
будут  нужны.  Таблица  Экспорта  заставляет   обеспечивающую   систему
специфицировать те функции, которыми она снабжает.

    Есть проблема,   раз   Таблица   Импорта   написана,  она  остается
погстоянной.  В ней нет пустого места для добавления новых вхождений  и
вы  туда ничего не засунете.  Почему?  Хорошо,  в основном потому,  что
определенная таблица переходов может быть в  ЕХЕ  в  ЛЮБОМ  МЕСТЕ.  Для
того, чтобы обратиться к API, код вызывает предопределенный адрес. Этот
адрес указывает на непрямой переход,  который  указывает  на  строку  в
Таблице  Импорта,  которая  заполнена  (когда  программа уже загружена)
адресамим на  простую  таблицу  переходов  в  DLLе,  который  сохнаняет
значение  в стеке и переходит на диспетчер функций,  который использует
значения, размещенные в таблице экспорта DLLа. Для добавления вхождения
в таблицу импорта,  вам надо перемещать текущие вхождения,  так что вам
надо на них еще попасть.  Это  означает,  что  вам  надо  еще  изменить
таблицу  переходов  для того,  чтобы указать на перемещаемые вхождения,
что невозможно, т.к. таблица переходов может быть в ЛЮБОМ МЕСТЕ в файле
и ее нельзя обнаружить.

    Новые рубежи
    ------------

    Windows 95 - целиком новая платформа.  Это новый  вызов  и  поэтому
куча  всяких  заморочек  встанут  перед  вами - это ОЧЕНЬ возможно.  Но
возьмите и начните исследования.  Эти исследования будут означать войну
против VX/AV, тем или иным образом.

</PRE>
</TD>
</TR>
</TABLE>
<HR>
<CENTER>(C) NF, 1998-2004</CENTER>
</BODY>
</HTML>
