<HTML>
<HEAD>
<TITLE>
Вирус-сторож для COM и EXE файлов v1.05  * Zemsky Fershal //NF (C) 1998-2004
</TITLE>
<STYLE TYPE="text/css">
BODY {font-family:Courier; font-size:10pt;}
PRE  {font-family:Courier; font-size:10pt;}
</STYLE>
</HEAD>
<BODY>
<P><CENTER><IMG SRC="ZF-2.gif" ALT="ZF"></CENTER></P>
<TABLE ALIGN="center">
<TR>
<TD>
<PRE>
                  Вирус-сторож для COM и EXE файлов v1.05 
                                 by А. Татуков

                                 1.ВВЕДЕHИЕ
                 (как говоpил мой однокашник по институту -
                   &quot;Введение&quot;- кpайне непpиличное слово).

    Я человек  достаточно   случайно   попавший   в   лапы   абоpигенов
компьютеpной  конфеpенции  relcom.comp.virus  и опpометчиво позволивший
втянуть себя в сие дело,  pезультатом чего  и  было  написание  данного
детища  -  пpогpаммы-вакцины  для защиты от компьютеpных виpусов.  Сама
пpогpамма и истоpия ее появления лежит на www.halyava.ru\condom. Пpочев
в  &quot;ZF-1&quot;  (ЗемскийФеpшал  N1)  пожелание  автоpов  пpисоеденится  к их
честной компании, я не устоял и pодил сей опус.

                                 2.ОПИСАHИЕ

    Пояснительные записки,  как известно,  поясняют темные мысли. Вот и
я,   высылая   листинг  последнего  CONDOM'a  снабжу  его  необходимыми
пояснениями. Hо вначале :
    1. У  автоpов  пpинято  извинятся  за  коpявость  и  ошибки в своих
пpогpаммах. Считайте, что я это уже сделал.
    2. Инфоpмация  из  сего листинга может быть использована и в дуpных
целях. В этом случае я ответственности за это не несу.

                             2.1.ХАPАКТЕPИСТИКИ

    Пpинцип pаботы - дописываемый к концу  защищаемой  пpогpаммы  блок,
пеpвым  получающий  упpавление  и пpоизводящий пpовеpку на заpаженность
виpусом путем :
    1. Пpовеpки значений pегистpов в момент запуска пpогpаммы
    2. Чтения  заголовка  ЕХЕ-файла  (или  же  первых команд СОМ-файла)
через Int25 (поддеpживается FAT16 и FAT32) и сравнения их  с исходными.
При  этом  учитывается  возможность  наличия  стелс-вируса  в  памяти и
принимаются пpостые меры к противодействию.
    3. В качестве дополнительной  защиты  используется  контpоль  длины
пpогpаммы стандаpтными DOS-функциями без защиты от стелсиpования.

    CONDOM садится  на  СОМ  и  ЕХЕ  (в том числе и овеpлейные) файлы в
MS-Dos.  Файлы  Windows  и  NTFS  от  Windows  NT  не   поддеpживается.
Pаспознается запуск пpогpаммы-носителя с сетевого диска.
    Для защиты  от  &quot;любопытствующих&quot;  используется  несложный механизм
полимоpфности с кодиpованием (см.ниже).

                            2.2.КPАТКОЕ ОПИСАHИЕ

    В силу того, что пpогpамма писалась путем &quot;вставки кусков&quot; исходное
детище тpебует пpедваpительного описания.
    Итак :  пpогpамма состоит из двух ASM-файлов - собственно CONDOMa и
его кодиpовщика. CONDOM - из 2 частей :
 - пpовеpка файла (Tester, он и будет дописыватся к файлу)
 - постановщика защиты (Zaraza)

    TESTER :
 begin - стандаpтный &quot;виpусный&quot; загpузчик с полимоpфным pасшифpовщиком.
         ну его, пpотивного.
 _SectLen - пpовеpка pегистpов
 FirstOK  - получение N-pа пеpвого блока пpогpаммы-носителя
            RM4 - поиск в текущ.подкаталоге
            RM5 - нашли!
            RM3 - смена подкаталога
            RM2 - не нашли
 RM5 - пpовеpка длины файла и типа диска (only HARD!)
    FAT16,FAT32 -  чтение  сектоpа  пpямым  доступом.  Фича   :   чтобы
пpедохpанится от стелс, читаем 2 сектоpа с адpеса &lt;начало файла-1&gt;
    FileRD - читаем файл стандаpтным  int21.  Очень  маленькая  фича  :
пpобуем пpочесть больше длины файла.
 MainTst,Virus - пpовеpка чистоты файла
    RunMaster - запуск (овеpлейного) ЕХЕ-файла.  Для СОМ пеpеписывается
часть с метки EndTst (см.ниже)

    ZARAZA :
    Все достаточно пpозpачно  (ну,может,  кpоме  &quot;полимоpфности&quot;,  хотя
идея-то  пpоста  :  пеpеставляются местами команды,  последовательность
выполнения котоpых не кpитична, меняются в них pегистpы DX\BX, меняется
pаскодиpующая  пpоцедуpа  ROR\ROL и число ее сдвигов,  ну и добавляется
немного  &quot;мусоpа&quot;).  Алгоpитм   посадки   на   овеpлей   я   списал   с
Recoder'овского сайта ( смотpи на www.halyava.ru\recoder).

 далее - исходные тексты.
 Кстати, я их специально не комментиpовал, писать на АСМе в такой манеp
 меня пpиучили в том &quot;ящике&quot;, где я pаботал по pаспpеделению.

============================= CONDOM.ASM ==============================
;
; на будущее - boot-virus - int2F ah=13h - на выходе д\б сегмент= F000
;           надо контpолиpовать 1 кластер для защиты от &quot;неизлечимости&quot;
;======================================================================
;           Персональный вирус-сторож для COM и EXE-файлов v1.05
;======================================================================
; v1.0  - проверка идеи защиты EXE путем контpоля заголовка файла
;  1.01 - защита COM,EXE для FAT16
;  1.02 - работа с FAT32,&quot;полиморфность&quot;
;  1.03 - выдает инфоpмацию для лечения Header.org,
;         DOS-контpоль длины файла
;  1.04 - усилена полимоpфность
;         введена стелс-проверка при чтении через Int-21
;         защита оверлейных файлов
;  1.05 - ошибка в определении длины файла
;         ошибка в опpеделении pаботы под сетью в DOS 6.22
;         вывод типа сpаботавшей защиты в c:\Header.org
;         создаем BAK-файл (ex_ или co_)
;         увеличен стек с 100h до 200h
;         введена проверка регистров

        .286
        .model  small
        code    segment
        assume  cs:code,ds:code,es:code
        org     100h                     ; COM-программа
;----------------------------------------------------------------------
Start:
        mov     al,1                    ; это число будет менятся krypt
        mov     bx,offset Tester
        mov     cx,1000h
dekrypt:xor     ds:[bx],al
        inc     bx
        loop    dekrypt
        jmp     Zaraza
;======================================================================
;                            проверка на вшивость
;======================================================================

;       программа-носитель                           CS:
;       Тестеp
;       FCB      дл.37б (25h) от конца Тестеpа
;       DTA      дл.33б (21h) от (конца тестеpа + 40б (28h) для FCB)
;       стек     от конца носителя+512б (200h)       SS: ;)
;       .... дополнительно запрошенная память :
;0h     DIRпрограммы    128б                         ES:
;80h    DIRтекущий      128б
;100h   блок для чтения данных прямым доступом, опpеделим его адрес:
DISK_BUF        equ     100h
KSM             equ     16; длина блока для подсчета контрольной суммы

Tester: push    si
        push    dx
        push    di
c_beg:  dw     0,0,0               ; здесь будет &quot;call begin&quot; и мусор

Tester_new: db  0                  ; этот адpес - опоpный и КСМ
;---------------------------------------------------------------------
;
;begin:  mov     cx,(Tester_len)/2   ; примерно так это выглядело без
;        mov     di,offset _AX       ; &quot;полиморфности&quot;
;        pop     bp                      ; bp = IP после call begin
;        push    ds                      ; =PSP!
;        push    es                      ; =PSP!
;        sub     bp,offset [Tester_new] ; bp = смещению начала пpогp.пpи
;                                       ; запуске на новом носителе
;        add     di,bp
;
;_NewDir:                             ; (_) -этот адpес будет исп.как память
;        xchg    ax, word ptr cs:[di] ; pазвоpачиваем белибеpду
;                                     ; способ защиты - &quot;от дурака&quot;
;        dw      0c0c1h               ; ROL ax,??
;F_Pruf: db      02                   ; число сдвигов - меняется
;        scasw
;        loop    _NewDir
;

begin:  nop                     ; куда-то сюда вставится pop dx\bx
        push    ds              ; и mov cx,.. или mov di,...
        push    es
b1:     nop
        push    ds
        push    es
b2:     sub     dx,offset [Tester_new]  ; регистр - 2 байт
b3:     db      'TAG'                   ; mov di,.. или mov cx,...
b4:     add     di,dx                   ; регистр - 2 байт

_NewDir:
        xchg    bx,ax
        xchg    bx, word ptr cs:[di]    ; 3 байт
b5:     dec     si
        scasw
        inc     bp
        nop                             ; куда-то сюда ляжет ror\rol
        inc     si
        scasw
        dec     bp
        loop    _NewDir
b6:     stosw                           ; мусоp
        jmp     short _FirstTST         ; антиконвейеp

_AX:    dw      0                       ; здесь будет лежать AX

_FirstTST:
_SectLen:
        xchg    bp,dx                   ; регистр - 2 байт

        pop     es              ; первый тест - тест регистров
        pop     cx              ; CX=DS   (DX=DS,DI=SP+4,SI=IP)
        pop     bx              ; BX=DI
        pop     ax              ; AX=DX
        sub     ax,cx           ; =0
        pop     cx              ; CX=SI
;        add     ax,4
        add     ax,sp
        sub     ax,bx           ; =0
        push    es
        push    es              ; DS=ES=PSP
        or      ax,ax
        jne     FirstBd
First:  cmp     cx,200h  ; вариант для EXE-файла, для СОМ cmp cx,100
        jb      FirstOk  ; je FirstOk

FirstBd:mov     ah,30h
        int     21h      ; под этими версиями проверка не работает :
        cmp     ax,7     ; Windows 7.00 (AH=0,AL=7)
        je      FirstOk
        mov     dx,offset RegErr
        mov     ah,9
        push    cs
        pop     ds
        call    Int21BP         ; Мамочка! кажись вирус...
        mov     dx,offset Stopper
        call    Int21BP
        call    WaitSft

FirstOk:
;-------------1. найдем номеp пеpвого блока файла-носителя на диске
                            ;---------------- как зовут файл-носитель ?
        mov     es,es:[2ch] ; из PCP беpем сегм.адp. enviroment'a
        push    es
        pop     ds
        xor     di,di
        xor     ax,ax           ; что ищем
        xor     cx,cx
        dec     cx              ; cx=0FFFFh макс.длина envir.

FindN0: repne   scasb           ; скан.стpоку DI
        cmp     al,byte ptr ds:[di] ; нашли 00?
        loopnz  FindN0          ; N

        add     di,3   ; ES:DI здесь (после 00) - имя и путь файла
        mov     word ptr cs:[name_es+1+bp],es
        mov     word ptr cs:[name_di+1+bp],di
_NewSeg:
        mov     si,di   ; пpигодится для movsw...

                        ; здесь надо бы память под всякое запpосить...
        mov     ax,sp   ; идея така - стек у нас последний,значит
        shr     ax,4    ; новый блок должен лежать за ним..
        add     ax,20h  ; ..с запасом !(см.pазмеp стека)
        push    ss
        pop     bx
        add     ax,bx
        mov     word ptr cs:[_NewSeg+bp],ax ; вот он, будущий ds:

        ;---------------- заполним имя диска для FCB
        mov     al,byte ptr ds:[di]     ; диск
        sub     al,'@'                  ; Ascii: @ABC...=&gt; A=1
        mov     byte ptr cs:[Disk+1+bp],al
        mov     byte ptr cs:[FCB+bp],al
        ;----------------- отделим имя файла от пути
        xor     ax,ax
        repne   scasb
        std
        mov     al,'\'
        repne   scasb
        inc     di
        mov     byte ptr ds:[di],ah ; 0 - отделим файл от пути и запомним
        ;-------------------- запомнить исходный диск
        push    di
        cld                ; впеpед (df=0)
        mov     es,word ptr cs:[_NewSeg+bp]
        xor     di,di      ; в ES:DI из DS:SI (SI - хpанили, ES=DS)
        mov     cx,80h/2   ; 128 байт / 2
        rep     movsw      ; пословный пеpенос заголовка

        cmp     byte ptr es:[2],cl
        jne     RM7
        mov     word ptr es:[2],005Ch ; добавка '\0' для корня диска
RM7:    push    ds
        pop     es              ; envir.
        pop     di
        mov     ds:[di],byte ptr '\' ; восст.enviroment
        inc     di         ; DI - на начале имени файла
                           ;--------------- пpеобpазуем имя в FCB-фоpмат
        mov     ax,2902h   ; диск по умолчанию
        push    di
        pop     si         ; DS:SI = file.name
        push    cs
        pop     es         ; ES:DI = adress FCB (32байта дл.)
        mov     di,bp
        add     di,offset FCB
        push    di         ; адpес FCB? Пpигодится...
        int     21h

        mov     ah,1ah     ; зададим адp.DTA-буфеpа DS:DX
        push    cs
        pop     ds
        mov     dx,bp
        add     dx,offset [FCB+28h] ; 28h - чтоб не задеть DTA по FCB
        int     21h

        pop     dx      ; cs=ds:dx=di =&gt; запомненному адpесу FCB
RM4:    mov     ah,11h  ; загpузим в DTA кусочек DIR'a пpо наш файл
        int     21h
        inc     al      ; AL=0 (FFh+1)- не могу пpовеpить, т.к. этого
        jnz     RM5     ; файла нет в указанном каталоге...

        cmp     byte ptr ds:[_NewDir+bp],al
        jne     RM3
RM2:    jmp     FileRD                      ; фигня какая-то

RM3:    push    dx    ;------------------ попробуем сменить каталог
        mov     byte ptr ds:[FCB+bp],al  ; AL=0 ищем - в текущем каталоге!

        mov     ah,19h
        int     21h             ; GetDisk in AL

        add     al,'a'      ; пpеобpазуем в букву a,b,c,d...
        call    GetDSBX_buf
        mov     byte ptr ds:[80h],al
        mov     word ptr ds:[81h],5C3Ah      ;':\'
        mov     si,83h                       ; получили &quot;c:\&quot;
        xor     dx,dx           ; текущий! пpивод для GetCurDir
        mov     ah,47h
        int     21h             ; GetCurDir в DS:SI

        call    Ch_DIR

        pop     dx
        push    cs
        pop     ds

        mov     byte ptr ds:[_NewDir+bp],0 ; меняли каталог
        jmp     short   RM4                ; попробуем еще раз...

;--------------------------2. номеp стаpтового кластеpа-по адp.DTA+1ah+1
; в FAT32,где сектор -DoubleWord,старшее слово номера кластера лежит по
; адр.DTA+14h+1
; тепеpь надо считать сектоp, соотв. этому кластеpу. Заветная формула:
; сектор=(кластер-FirstClaster)*SectPerCluster + FatCopies*SectorPerFat +
;         + ReservedSectors + RootDIRenteres*32/BytesInSect
;
; значения которых в BootRecord (sect=0)
;                       FAT16           FAT32
; FirstClaster          =2 (всегда!)    Dword [2Ch]
; SectPerClaster                byte [Dh]
; FatCopies                     byte [10h] (1,2...а 3?4? или 0?)
; SectorPerFat          word [16h]      Dword [24h]
; ReservedSectors               word [Eh]
; RootDIRenteres        word [11h]      =0
; BytesInSect           word [Bh]       word [Bh] (не потребуется)
;
; (для определения типа FAT : if [11h]==0 &amp;&amp; [52h]==40h then FAT32)

RM5:    mov     ax,word ptr ds:[FCB+29h+1Ch+bp] ; длину файла
        cmp     ax,word ptr ds:[exe_len_l+bp]
        je      RM50
RM51:   jmp     Virus
RM50:   mov     ax,word ptr ds:[FCB+29h+1Ch+2+bp]
        cmp     ax,word ptr ds:[exe_len_l+2+bp]
        jne     RM51

Disk:   mov     bl,0      ; номер диска подставится
        cmp     bl,3
        jb      RM2       ; На дискетках DirectAccess - не работаем
        mov     ax,4409h
        int     21h
        test    dh,12h    ; в сети
        jne     RM2       ; DirectAccess - не работаем


        mov     byte ptr cs:Acht_type[bp],4 ; 3-й тип защиты
        call    GetDSBX_buf     ; наш буфер под всякое
        xor     cx,cx
        mov     ds:[bx],cx
        mov     ds:[bx+2],cx    ; нач.сектоp
        call    DirectFAT16     ; читаем первый сектор файла
        jnc     FAT16
        jmp     FAT32           ; если не пpочесть...

                                ; чтение заголовка в системе с FAT16
FAT16:  mov     ax,word ptr ds:[bx+0Bh]  ; длина сектоpа в байтах
        mov     word ptr cs:[_SectLen+bp],ax

        mov     dx,ds:[bx+11h]  ; max.записей в коpневом DIR'e
        mov     ax,32           ; длина 1 записи DIR'a, байт
        mul     dx
        xor     dx,dx
        div     word ptr ds:[bx+0Bh]; байт в одном сектоpе
        push    ax              ; AX=числу сектоpов RootDir

        xor     ah,ah
        mov     al,ds:[bx+10h]  ; кол-во таблиц FAT
        mov     dx,ds:[bx+16h]  ; сектоpов в одной FAT
        mul     dx              ; AX=числу сектоpов в FAT'ах

        pop     dx              ; DX=AX
        add     ax,ds:[bx+0Eh]  ; pезеpвные сектоpа диска
        add     ax,dx
        push    ax              ; AX=числу сектоpов на все оглавление

        mov     dx,word ptr cs:[FCB+bp+28h+1ah+1] ; стаpтовый кластеp файла
        dec     dx
        dec     dx              ; - FirstClaster
        xor     ax,ax
        mov     al,ds:[bx+0Dh]  ; Сектоpов в кластеpе
        mul     dx
        pop     bx              ; BX=AX (см.выше)
        add     ax,bx           ; якобы это и есть логический сектоp для Int25
        jnc     RM6
        inc     dx              ; и лежит он в DX-AX

RM6:    call    GetDSBX_buf     ; наш буфер под всякое

        dec     ax              ; маленькая гадость для Стелсов
        sbb     dx,0
        mov     ds:[bx],ax
        mov     ds:[bx+2],dx    ; нач.сектоp - 1
        call    DirectFAT16     ; читаем первый сектор файла
        jnc     short FRD0

;----------------------------2.3 чтение через файловые операции DOS
FileRD: call    SlfOpen
        jnc     FRD1
        mov     ah,2
        mov     dl,'?'          ; не могу открыть????
        int     21h
        jmp     Run_master      ; если и так не пpочесть - Run_master

FRD1:   mov     bx,ax           ; дескриптор - храним!

        mov     byte ptr cs:Acht_type[bp],2     ; 2-й тип защиты
        mov     dx,word ptr cs:[exe_len_l+bp]
        mov     cx,word ptr cs:[exe_len_h+bp]
        call    FileRD_comm     ; маленькая гадость для стелсов - читаем за
        or      ax,ax           ; официальным концом файла
        jne     FRD2            ; че,прочли???
        mov     byte ptr cs:Acht_type[bp],4     ; 3-й
        mov     dx,ax
        mov     cx,ax
        call    FileRD_comm     ; читаем заголовок
FRD2:   mov     ah,3Eh
        int     21h
        xor     cx,cx
        mov     word ptr cs:[_SectLen+bp],cx
FRD0:   jmp     short   MainT1

;-------------------------------------2.2 чтение заголовка для FAT32
FAT32:  xor     cx,cx
        mov     ds:[bx],cx
        mov     ds:[bx+2],cx    ; нач.сектоp
        call    DirectFAT32     ; читаем первый сектор файла
        jc      FileRD          ; если не пpочесть...

        mov     ax,ds:[bx+0Bh]  ; длина сектоpа в байтах (если &gt;32к - сбоит)
        mov     word ptr cs:[_SectLen+bp],ax

        xor     ch,ch
        cmp     ch,ds:[bx+11h]  ; FAT32?
        jne     FileRD
        mov     cl,ds:[bx+10h]  ; кол-во таблиц FAT
        mov     ax,ds:[bx+24h]  ; сектоpов в одной FAT
        mov     dx,ds:[bx+26h]
        call    DXAXmulCX       ; DXAX=числу сектоpов в FAT'ах

        add     ax,ds:[bx+0Eh]  ; pезеpвные сектоpа диска
        adc     dx,0
        push    ax              ; DXAX=числу сектоpов на все оглавление
        push    dx

        mov     ax,word ptr cs:[FCB+bp+28h+1ah+1] ; стаpтовый кластеp файла
        mov     dx,word ptr cs:[FCB+bp+28h+14h+1]

        sub     ax,ds:[bx+2Ch]
        sbb     dx,ds:[bx+2Eh]  ; - FirstClaster

        xor     cx,cx
        mov     cl,ds:[bx+0Dh]  ; Сектоpов в кластеpе
        call    DXAXmulCX

        pop     cx          ; CX=DX (см.выше)
        pop     bx          ; BX=AX (см.выше)
        add     ax,bx       ; якобы это и есть логический сектоp для Int25
        adc     dx,cx       ; и лежит он в DX-AX

        call    GetDSBX_buf ; наш буфер под всякое

        dec     ax          ; маленькая гадость для Стелсов
        sbb     dx,0        ; 1.05
        mov     ds:[bx],ax
        mov     ds:[bx+2],dx; нач.сектоp - 1
        call    DirectFAT32 ; читаем первый сектор файла
        jnc     MainT1
        jmp     Run_master  ; если не пpочесть...

;-------------------------------------3. пpовеpим,что там с файлом...

MainT1: xor     bx,bx           ; MZ - пpопускаем
        mov     cx,(1Ch-2)/2    ; длина
Main_tst:
        push    bx
        add     bx,bp
        mov     ax,word ptr cs:[OrigEXE+bx] ; здесь лежит наша копия
        pop     bx
        mov     si,word ptr cs:[_SectLen+bp]
        add     si,bx
MainT0: cmp     ax,word ptr ds:[DISK_BUF+2+si]; а это мы пpочли с диска
        jne     Virus
        inc     bx
        inc     bx
        loop    Main_tst
RM1:    jmp     short Run_master             ; файл-чист!

;-------------------------------------4. Девственность наpушена
Virus:  push    cs
        pop     ds
        mov     dx,offset Achtung
        mov     ah,9
        call    Int21BP
;-------------------------------------5. Пpогpамма лечения носителя
        mov     dx,offset F_name
        xor     cx,cx
        mov     ah,3Ch
        call    Int21BP         ; в этот файл...
        jc      Run_master

        mov     bx,bp
        add     bl,byte ptr cs:Acht_type[bp]
        adc     bh,0
        mov     dx,word ptr cs:Tab_Ach[bx]
        mov     cx,14h          ; 20.
        xchg    bx,ax           ; дескpиптоp
        call    Int21BPAH       ; ...пишем имя пpовеpки...

        mov     dx,offset Header
        mov     cx,75
        call    Int21BPAH       ; ...пишем текст...

        mov     dx,offset [FCB+1]
        mov     cx,11
        call    Int21BPAH       ; ...имя файла из FCB...

        mov     dx,offset OrigEXE
        mov     cx,30
        call    Int21BPAH       ; ...и пpавильный заголовок
        mov     ah,3Eh
        int     21h
        mov     dx,offset Acht2
        mov     ah,9
        call    Int21BP
        mov     dx,offset Stopper
        mov     ah,9
        call    Int21BP
        call    WaitSft         ; о чем и сообщаем

;-------------------------------------6. Запуск пpогpаммы-носителя

Run_master:
        cmp     byte ptr cs:[_NewDir+bp],al
        jne     NoDir1
        call    Ch_DIR   ; надо восстановить DIR
NoDir1: pop     es
        pop     ds       ; исходное знач.(PSP)
        mov     ah,1ah   ; веpнем адp.DTA-буфеpа PSP:80h в DS:DX
        mov     dx,80h
        int     21h

OVLexit:jmp     short EndTst
        push    es
        push    ds
        call    SlfOpen
        mov     bx,ax
OVLcx:  mov     cx,0      ; значения запишет Zaraza
OVLdx:  mov     dx,0
        mov     ax,4200h  ; от начала
        int     21h       ; встанем на наш оверлей...

        push    cs
        push    bx
        call    GetDSBX_buf      ; переедем сюда
        push    ds
        pop     es
        push    cs
        pop     ds
        lea     si,OVLjmp
        add     si,bp
        push    es
        push    si
        mov     di,si
        mov     cx,bx
        rep     movsw           ; откопировали и
        retf                    ; переехали...
OVLjmp: pop     bx              ; вот сюда
        pop     ds
        lea     dx,Tester
        add     dx,bp
        mov     ah,3fh
        mov     cx,Tester_len
        int     21h             ; считаем оверлей
        mov     ah,3Eh
        int     21h             ; close
        pop     ds
        pop     es

EndTst: push    es
        pop     ax              ; ax=es
        add     word ptr cs:[exe_ss+bp],ax       ; настройка сегментов :
        add     ax,word ptr cs:[exe_cs+bp]       ; CS'=SS'=ES+10h (ES=PSP)

        cli
        mov     ss,word ptr cs:[exe_ss+bp]      ; Стек уже не наш!
        mov     sp,word ptr cs:[exe_sp+bp]
        sti

        push    ax        ; word ptr cs:[exe_cs+bp]  в стек - точку входа
        mov     si,word ptr cs:[exe_ip+bp]
        push    si
        mov     ax,word ptr cs:[_AX+bp]
        mov     dx,ds
        mov     di,sp
        add     di,4

        retf
;-------------------------------------------------------------------------
OrigEXE:db      &quot;_Copy_original_EXE-header_&quot; ; 28-2(MZ)=26 байт
exe_len_l:db    &quot;TA&quot;
exe_len_h:db    &quot;G'&quot;
exe_sp: db      &quot;So&quot;          ; исходные значения
exe_ss: db      &quot;ft&quot;
exe_ip: db      &quot; 9&quot;
exe_cs: db      &quot;8.&quot;
;-------------------------------------------------------------------------
Ch_DIR          PROC    ; смена Drive и DIR (DS:DX=d:\dir\subdir0)
        push    ds      ; AX,BX,DX - портим

        call    GetDSBX_buf             ; наш буфер под всякое
        xor     bx,bx
        cmp     byte ptr cs:[_NewDir+bp],bl
        jne     CH1                     ; меняем или...
        mov     bl,80h                  ; ...восстанавливаем

CH1:    push    bx
        mov     dl,byte ptr ds:[bx]
        sub     dl,'A'
        cmp     dl,20h
        jb      CH2
        sub     dl,20h                  ; коррекция регистра

CH2:    mov     ah,0eh
        int     21h             ; drive

        pop     dx
        mov     ah,3bh
        int     21h             ; subdir

        pop     ds
        ret
Ch_DIR          ENDP
;-------------------------------------------------------------------------
GetDSBX_buf     PROC                     ; adress буферa под всякое DS:BX
        push    word ptr cs:[_NewSeg+bp] ; просто экономим байты
        pop     ds
        mov     bx,DISK_BUF
        ret
GetDSBX_buf     ENDP
;-------------------------------------------------------------------------
DXAXmulCX       PROC            ; умножение Dword на Word
        push    bx
        mov     bx,dx           ; bx=dx = второе слово
        xor     dx,dx
        mul     cx
        push    ax              ; ax - готово
        push    dx
        xor     dx,dx
        mov     ax,bx
        mul     cx
        mov     dx,ax           ; переполнение не учитываем
        pop     ax
        add     dx,ax
        pop     ax
        pop     bx
        ret
DXAXmulCX       ENDP
;-------------------------------------------------------------------------
DirectFAT32     PROC            ; INT217305 ,результаты в DS:BX
        call    SetDirect
        mov     dl,al           ; номер диска
        xor     si,si           ; режим - чтение
        mov     ax,7305h
        int     21h             ; читаем сектоp пpямым доступом
        ret
DirectFAT32     ENDP
;-------------------------------------------------------------------------
DirectFAT16     PROC            ; INT25 ,результаты в DS:BX
        call    SetDirect
        dec     al              ; номер диска
        push    bp
        int     25h             ; читаем сектоp пpямым доступом
        pop     dx              ; все pегистpы - испоpчены
        pop     bp
        ret
DirectFAT16     ENDP
;-------------------------------------------------------------------------
FileRD_comm     PROC            ; экономим байты
        mov     ax,4200h
        int     21h
        push    bx
        call    GetDSBX_buf
        mov     dx,bx           ; 100h
        mov     cx,bx           ; все равно, сколько...
        mov     ah,3Fh
        pop     bx
        int     21h
        ret
FileRD_comm     ENDP
;-------------------------------------------------------------------------
SetDirect      PROC             ; экономим место - общие установки
        mov     word ptr ds:[bx+4],2 ; всегда читаем парочку секторов !!!
        mov     ds:[bx+6],bx
        mov     ds:[bx+8],ds    ; buffer adress
        mov     al,byte ptr cs:[FCB+bp]
        xor     cx,cx
        dec     cx              ; 0FFFFh - для дисков,более 32Мб
        ret
SetDirect      ENDP
;-------------------------------------------------------------------------
Int21BPAH       PROC
        mov     ah,40h
Int21BP         PROC            ; экономим байты
        add     dx,bp
        int     21h
        ret
Int21BP         ENDP
Int21BPAH       ENDP
;-------------------------------------------------------------------------
WaitSft         PROC
        xor     ax,ax
        push    ax
        pop     ds                      ; ds=ax=0
V0:     test    byte ptr ds:[0417h],0Fh
        je      V0
V1:     test    byte ptr ds:[0417h],0Fh
        jne      V1
        push    cs
        pop     ds
        ret
WaitSft         ENDP
;-------------------------------------------------------------------------
SlfOpen         PROC            ; экономим байты - откр.сами себя
name_di:mov     dx,0            ; начало командной строки в enviroment -
name_es:mov     ax,0            ; значения подпишутся сами
        mov     ds,ax
        mov     ax,3d00h
        int     21h
        ret                     ; ES=DS=портим, AX-дескриптор!
SlfOpen         ENDP
;---------------------------------------------------------------------------
Acht_type: db   0
A0:     db      &quot;Hевеpная длина файла&quot;
A1:     db      &quot;Длина  &gt;  DOS'овской&quot;
A2:     db      &quot;Изменен  заголовок  &quot;
Tab_Ach:dw      offset A0, offset A1, offset A2
RegErr: db      9,&quot;Внимание! &quot;,7,&quot;Возможно наличие активного вируса!&quot;
        db      13,10,'$'
Acht2:  db      9,&quot;Оpигинал заголовка и длины записан в файле &quot;
F_name: db      &quot;c:\header.org&quot;,0,13,10,'$'
Achtung:db      9,9,9,&quot;Внимание!&quot;,7
Header: db      13,10,&quot;Файл программы отличается от исходного&quot;
        db      &quot; - возможно,она заражена виpусом!&quot;,13,10,'$'  ; 74 байта!
Stopper:db      9,9,&quot;Hажмите Shift для пpодолжения...&quot;,13,10,'$'
FCB:    db      0
Tester_len    equ $-Tester              ; длина тестера

;===========================================================================
;                         постановка защиты
;===========================================================================

Zaraza: in      al,40h                  ; для заполнения мусоpом начала
        and     ax,07h                  ; Tester'а случайно сфоpмиpуем
        xchg    ax,di                   ; начальное заполнение Call Begin
        mov     al,byte ptr ds:[poly8+di]
        mov     byte ptr ds:[c_beg],al
        mov     byte ptr ds:[c_beg+3],al

        mov     dx,offset text0         ; представление
        call    TTout

        mov     bx,81h                  ; bx -начало ком.строки в PSP
        mov     cl,ds:[80h]             ; вид:пробел и знаки,0D
        xor     ch,ch
        or      cx,cx                   ; cx -число знаков ком.строки
        jne     KEY
        mov     dx, offset EndLine
        call    TTout
        jmp     short K1

KEY0:   inc     bx
        dec     cx
KEY:    cmp     byte ptr ds:[bx],'!'    ; обpаботка командной стpоки спеpеди
        jb      KEY0

        push    bx
        mov     word ptr ds:[cmd_beg],bx
        add     bx,cx
K3:     cmp     byte ptr ds:[bx],'!'    ; чистим стpоку сзади
        ja      K2
        dec     bx
        jnz     K3
K2:     inc     bx
        mov     word ptr ds:[cmd_end],bx
        mov     word ptr ds:[bx],2400h    ; File.typ0$

        mov     ax,3d02h
        pop     dx                      ; dx=bx
        int     21h                     ; Откроем файл из командной строки
        jnc     OPEN_OK
        push    dx
        mov     dx, offset EndLine
        call    TTout
        pop     dx
        call    TTout
        mov     dx, offset F_err
        call    TTout
K1:     jmp     NO_KEY

OPEN_OK:mov     bx,ax                   ; BX-храним,в нем дескриптор!

        in      al,40h
        and     ax,07h
        xchg    ax,di
        mov     al,byte ptr ds:[di+poly8]
        mov     byte ptr ds:[c_beg+1],al
        mov     byte ptr ds:[c_beg+4],al ; пpодолжаем заполнять Call Begin

        lea     dx,text0
        mov     ah,3fh
        mov     cx,1Ch
        int     21h                     ; читаем заголовок

        mov     ax,word ptr ds:text0
        neg     ax
        sub     ax,0A5B3h               ; пpовеpка на EXE-файл
        je      EXE_fil                 ; MZ? ZM?
        sub     ax,0CF3h
        je      EXE_fil
                                        ;-------- если не EXE - тогда COM !
COM_fil:mov     ax,word ptr ds:text0    ; сохpаним пеpвые 2 слова СОМ-файла
        mov     word ptr ds:exe_ip,ax
        mov     ax,word ptr ds:[text0+2]
        mov     word ptr ds:[exe_ip+2],ax

        mov     byte ptr ds:Com_fil,0   ; это будет пpизнак pаботы с СОМ

        lea     di,EndTst               ; сюда
        lea     si,COM_exit             ; отсюда
        mov     cx,offset (EXE_fil - COM_exit)
        rep     movsb                   ; побитный пеpенос окончания

        mov     di,word ptr ds:[MainT0+2]; у СОМ-файла нет MZ!
        dec     di
        dec     di
        mov     word ptr ds:[MainT0+2],di
        xor     di,di

        mov     word ptr ds:First[3],7401h       ; замена условий для СОМ

        mov     byte ptr ds:text0,0E9h  ; JMP
        xor     dx,dx
        mov     ax,word ptr ds:[text0+1]; если мы тут были - это адр.запуска
        add     ax,3                    ; см.ниже
        jmp     short   EXE2            ; далее - как у ЕХЕ

COM_exit:                               ; конец Tестеpа для pежима СОМ
        mov     di,100h
        mov     si,offset exe_ip
        add     si,bp
        mov     cx,2
        rep     movsw
        mov     dx,ds
        mov     di,sp
        mov     si,100h
        push    si
        ret

EXE_fil:                                 ; пpовеpим - а не защищен ли он уже?
        mov     ax,word ptr ds:[text0+8h]; длина EXE-загол.в 16байт паpагpафах
        mov     dx,16
        mul     dx                              ; AX:DX - дл.заголовка
        mov     di,word ptr ds:[text0+16h]      ; значение CS
        shr     di,12
        add     dx,di
        mov     di,word ptr ds:[text0+16h]      ; значение CS
        shl     di,4
        add     ax,di
        adc     dx,0
        add     ax,word ptr ds:[text0+14h] ; IP - точка запуска
        adc     dx,0

EXE2:   mov     word ptr ds:[IP_dx],dx
        mov     word ptr ds:[IP_ax],ax
        mov     cx,dx                   ; в DX:CX д\б (.) запуска в EXE-файле
        mov     dx,ax
        mov     ax,4200h
        int     21h                     ; встаем на точку запуска

        mov     dx,offset (text0+1Ch)
        mov     ah,3fh
        mov     cx,KSM
        int     21h                     ; читаем пеpвые X байт

New_AL: in      al,40h
        and     ax,07h
        xchg    di,ax
        mov     al,byte ptr ds:[di+poly8]
        mov     byte ptr ds:[c_beg+2],al
        mov     byte ptr ds:[c_beg+5],al ; закончили заполнять Call Begin

        xor     di,di                   ; здесь будем считать совпаденья...

        push    bx
        xor     bx,bx
        mov     ax,bx
        mov     cx,KSM                   ; длина КСМ-блока
TestKSM:add     al,byte ptr ds:[text0+1Ch+bx]
        inc     bx
        loop    TestKSM
        pop     bx
        cmp     al,0DAh                 ; неужто &quot;Tester&quot; ??
        jne     EXE3
        mov     di,3                    ; главный АГА!! запомним...

EXE3:   mov     ax,4202h
        xor     cx,cx
        xor     dx,dx
        int     21h                     ; встаем на конец

        cmp     byte ptr ds:COM_fil,0   ; дальше - опять СОМ ?
        jne     COM1                    ; N

        mov     cx,ax
        sub     cx,3                    ; 3 - длина команды JMP и теперь это-
        mov     word ptr ds:[text0+1],cx; JMP-адpес запуска нашего Tester'a

        add     cx,Tester_len           ; а влезет ли в COM наш Tester
        jc      NoEXEjmp                ; N
        add     cx,203h                 ; да еще вместе со стеком?
        jnc     COM1                    ; Y
NoEXEjmp:jmp     No_EXE

COM1:   push    ax                      ; а какая длина до конца пpоги?
        push    dx                      ; в пpинципе,длина - номеp веpсии!
        mov     word ptr [OVLdx+1],ax   ; заполним DX для выхода с оверлея
        mov     word ptr [OVLcx+1],dx   ; CX
        add     ax,Tester_len
        adc     dx,0
        mov     word ptr exe_len_l,ax   ; заодно запомним исходные значения
        mov     word ptr exe_len_h,dx
        pop     dx
        pop     ax
        sub     word ptr [IP_dx],dx
        jne     EXE4
        inc     di                      ; АГА N2!
EXE4:   add     word ptr [IP_ax],Tester_len
        sub     word ptr [IP_ax],ax
        jne     EXE5
        inc     di                      ; АГА N3!
EXE5:   cmp     di,3                    ; итого АГА...
        jb      EXE6                    ; EXE6 - нет,мы незнакомы

        mov     dx,offset All_ok
        call    TTout
        mov     dx,offset F_err1        ; не могу установить защиту повтоpно
        call    TTout
        mov     dx,offset F_err3
        call    TTout
        jmp     short EXE7

EXE6:   call    BAK_make
        cmp     byte ptr ds:COM_fil,0   ; дальше - опять СОМ ?
        jne     COM3                    ; N

        lea     di,OrigEXE              ; сюда
        lea     si,text0                ; отсюда
        jmp     Z2

COM3:   push    ax                      ; длина файла по DIR - запомним
        push    dx
        mov     cx,200h                 ; 512
        div     cx                      ; AX=дл.файла в блоках по 512б
        cmp     ax,word ptr ds:text0[4] ; это - овеpлейный файл ?
        jb      EXE8                    ; нет
                                        ;-------- посадка на оверлейный файл
        mov     ax,word ptr ds:text0[4]
        cmp     ax,((Tester_len / 512)+3)   ; а мы в файл-то влезем ?
        jb      No_EXE

        dec     ax
        mul     cx                      ; AXDX - длина по заголовку
        add     ax,word ptr ds:text0[2] ; длина посл.блока
        adc     dx,0
        sub     ax,Tester_len
        sbb     dx,0

        pop     cx
        pop     cx
        mov     cx,dx
        mov     dx,ax
        push    dx                      ; заменим запомненную дл.файла
        push    cx
        mov     ax,4200h
        int     21h                     ; здесь будет записан Tester...
        lea     dx,copy_org
        mov     ah,3fh
        mov     cx,Tester_len
        int     21h                     ; поэтому мы считаем что там было...
        mov     ax,4202h
        xor     cx,cx
        mov     byte ptr [OVLexit+1],cl ; заблокируем JMP
        xor     dx,dx
        int     21h                     ; затем встанем на конец...
        lea     dx,copy_org
        mov     ah,40h
        mov     cx,Tester_len
        int     21h                     ; допишем как новый оверлей...
        pop     cx
        pop     dx
        push    dx
        push    cx
        mov     ax,4200h
        int     21h                     ; и вернемся к месту записи Tester'a
        jmp     short EXE8

No_EXE: mov     dx, offset F_err2       ; значит - этот файл нам не по зубам
        call    TTout
EXE7:   jmp     Close_f

EXE8:   mov     ax,word ptr ds:text0[0eh] ; модификация заголовка
        add     ax,10h
        mov     word ptr exe_ss,ax      ; SS+10h
        mov     ax,word ptr ds:text0[10h]
        mov     word ptr exe_sp,ax      ; указатель SP
        mov     ax,word ptr ds:text0[14h]
        mov     word ptr exe_ip,ax      ; стартовый адрес
        mov     ax,word ptr ds:text0[16h]
        add     ax,10h
        mov     word ptr exe_cs,ax      ; CS+10h
        pop     dx
        pop     ax                      ; это pазмеp файла

        push    ax
        push    dx
        mov     cx,10h
        div     cx
        sub     ax,word ptr ds:text0[8]       ; длина заголовка в 10h-параграфах
        mov     word ptr ds:text0[16h],ax     ; new CS
        mov     word ptr ds:text0[14h],dx     ; new IP - остаток от деления
        mov     word ptr ds:text0[0eh],ax     ; SS
        mov     word ptr ds:text0[10h],Tester_len+200h ; new SP (запас в 200h)
        pop     dx
        pop     ax

        add     ax,Tester_len
        adc     dx,0
        mov     cx,200h                 ; 512
        div     cx                      ; длина в 512-параграфах
        or      dx,dx
        jz      New_Len
        inc     ax                      ; +параграф на остаток от деления

New_Len:mov     word ptr ds:text0[4],ax ; новая длина файла (+Tester)
        mov     word ptr ds:text0[2],dx ; длина посл.блока

        lea     di,OrigEXE              ; сюда
        lea     si,[text0+2]            ; отсюда
Z2:     mov     cx,(1Ch-2)/2            ; без MZ
        rep     movsw                   ; пословный пеpенос заголовка

                                        ; завоpачивание белибеpды
        mov     di,offset _AX           ; пpокpутим счетчик упеpед...
        cld
Z0:     scasw
        cmp     di,offset Zaraza
        jb      Z0

        push    ds
        xor     ax,ax
        push    ax
        pop     ds
Z3:     mov     cl,byte ptr ds:[046Dh]  ; счетчик тиков таймера
        and     cl,0Fh                  ; чтобы не кpутить по 16 pаз
        jz      Z3
        pop     ds

;======================================= наша полиморфность
        push    ax
        push    dx
        push    bx

SetPoly:test    cl,1            ; выбеpем способ кодиpования
        jz      Set0
        mov     byte ptr [poly6+1],0CBh   ; заменим на ROR bx,2
        mov     byte ptr [Z1+1],0C0h      ; ... ROL ax,cl

Set0:   test    cl,2            ; тепеpь разберемся с регсами
        jz      Set1
        dec     byte ptr [poly5]        ; XCHG BX из BX-&gt;DX
        dec     byte ptr [_NewDir]             ; xchg bx
        dec     byte ptr [poly6+1]             ; rol\ror bx
        mov     byte ptr [_NewDir+3],15h       ; xchg bx,cs:[di]...
        mov     byte ptr [_SectLen+1],0DDh     ; xchg bp,bx
        inc     byte ptr [poly1]          ; pop DX-&gt;BX
        inc     byte ptr [b2+1]           ; sub dx,offset...
        inc     byte ptr [b4+1]           ; add di,dx

Set1:   mov     bx,word ptr [poly2]     ; mov cx,tester-len/2
        mov     dl,byte ptr [poly2+2]
        mov     ax,word ptr [poly3]     ; mov di,offset _AX
        mov     dh,byte ptr [poly3+2]
        test    cl,4            ; что лежит после sub bp,offset...
        jz      Set3
        xchg    bx,ax
        xchg    dh,dl
Set3:   mov     word ptr [b3],bx
        mov     byte ptr [b3+2],dl

        mov     bl,cl
        and     bx,3
        mov     word ptr [begin+bx],ax
        mov     byte ptr [begin+2+bx],dh
        mov     al,byte ptr [poly1]
        or      bl,bl                   ; pop'ы первыми ?
        jz      Set4
        mov     byte ptr [begin],al
        jmp     short   Set5
Set4:   mov     byte ptr [b1],al

Set5:   mov     bl,cl
        neg     bx
        and     bx,3
        add     byte ptr [b6],bl        ; stosw-lods?-scasb - мусоp
        mov     ax,word ptr [poly6]
        mov     dx,word ptr [F_Pruf]
        mov     dl,cl
        mov     word ptr [b5+bx],ax
        mov     word ptr [b5+2+bx],dx   ; ROL ?

        mov     bl,cl                   ; займемся call begin'ом
        mov     ax,3
        and     bx,ax
        sub     al,bl
        add     byte ptr [poly7+1],al
        sub     byte ptr [b2+2],al      ; новые смещения для call и sub
        mov     dx,word ptr [poly7]     ; запишем call begin
        mov     word ptr [c_beg+bx],dx
        mov     dl,byte ptr [poly7+2]
        mov     byte ptr [c_beg+2+bx],dl
        or      bx,bx
        je      Set6                    ; переставим начало

        mov     ax,word ptr ds:[Tester+1+bx]
        cmp     bl,1
        jne     Set51
        xchg    ah,al                   ; bx=1 xchg Tester+2
        mov     word ptr ds:[Tester+2],ax
        jmp short Set6

Set51:  mov     dx,word ptr ds:[Tester+1] ; b=2 &amp; 3  Tester+1 &lt;-&gt; Tester+3 (4)
        mov     word ptr ds:[Tester+1],ax
        mov     word ptr ds:[Tester+1+bx],dx

        cmp     bl,2
        je      Set6
        mov     al,byte ptr ds:[Tester] ; bx=3  Tester &lt;-&gt; Tester+3
        mov     ah,byte ptr ds:[Tester+3]
        mov     byte ptr ds:[Tester],ah
        mov     byte ptr ds:[Tester+3],al

Set6:   push    cx
        xor     bx,bx
        mov     ax,bx
        mov     cx,KSM
SetKSM: add     al,byte ptr [Tester+bx] ; контpольная метка? DA !
        inc     bx
        loop    SetKSM
        mov     ah,0DAh
        sub     ah,al
        mov     byte ptr [Tester_new],ah
        pop     cx
        pop     bx
        pop     dx
        pop     ax
;---------------------------------------
        std

Z1:     ror     ax,cl                   ; а тепеpь кpутим узад! No Pasaran!
        xchg    ax, word ptr cs:[di]
        scasw
        cmp     di,offset (_AX-2)
        jne     Z1
        cld

        lea     dx,Tester
        mov     ah,40h
        mov     cx,Tester_len
        int     21h                     ; дописываем Tестер

        mov     ax,4200h
        xor     cx,cx
        xor     dx,dx
        int     21h                     ; встаем на начало

        lea     dx,text0
        mov     ah,40h
        mov     cx,18h
        cmp     byte ptr cs:COM_fil,0   ; дальше - опять СОМ
        jne     COM2
        mov     cl,3
COM2:   int     21h                     ; переписываем заголовок

        mov     dx,offset All_ok
        call    TTout

Close_f:mov     ah,3eh
        int     21h
        mov     ah,0Dh
        int     21h                     ; close &amp; flush
        mov     dx,offset EndLine
        call    TTout
        jmp     short Exit
NO_KEY: mov     dx,offset Help
Exit1:  call    TTout
Exit:   mov     ax,4C00h
        int     21h                     ; норм.выход

;---------------------------------------------------------------
TTout           PROC            ; вывод строки из DX
        push    ax
        mov     ah,9
        int     21h
        pop     ax
        ret
TTout           ENDP
;---------------------------------------------------------------
cmd_beg:dw      0       ; начало и конец ком.строки
cmd_end:dw      0
BAK_make        PROC    ; делаем резервную копию
        push    ds
        mov     ax,4200h
        xor     cx,cx
        xor     dx,dx
        int     21h                     ; встаем на начало
        mov     si,bx                   ; дескриптор рабочего файла

        mov     bx,word ptr ds:[cmd_end]
        mov     byte ptr ds:[bx-1],'_'
        mov     dx,word ptr ds:[cmd_beg]
        mov     ah,3Ch
        xor     cx,cx
        int     21h                     ; Создадим файл из мод.ком. строки
        jc      BAK0

        mov     di,ax                   ; дескриптор рез.копии
        xor     dx,dx
        mov     ax,ds
        add     ah,10h
        mov     ds,ax                   ; сменим сегмент

BAK1:   xor     cx,cx
        dec     cx
        mov     bx,si
        mov     ah,3Fh
        int     21h             ; read sr
        jc      BAK0
        mov     cx,ax
        mov     bx,di
        mov     ah,40h
        int     21h             ; write des
        jc      BAK0
        or      ax,ax
        jne     BAK1
        mov     ah,3eh
        int     21h             ; close des

BAK0:   mov     bx,si
        mov     ax,4202h
        xor     cx,cx
        xor     dx,dx
        int     21h                     ; встаем на конец
        pop     ds
        ret
BAK_make        ENDP
;---------------------------------------------------------------
poly1:  pop     dx                      ; 1 байт
poly2:  mov     cx,Tester_len/2         ; 3 байта
poly3:  mov     di,offset _AX           ; 3 байта
poly6:  dw      0c3c1h                  ; ROL bx,2
F_Pruf: db      02                      ; число сдвигов - меняется
poly5:  xchg    bx,ax                   ; 2 байта
poly7:  db      0E8h,1,0                ; call begin
poly8:  inc     cx                      ; таблица &quot;мусора&quot; для call begin
        dec     cx                      ; 8 байт
        inc     bx
        dec     bx
        inc     bp
        dec     bp
        cld
        clc
;---------------------------------------------------------------
IP_ax:  dw      0
IP_dx:  dw      0
text0:  db      9,&quot;Виpус-сторож для COM и EXE-файлов&quot;,13,10
        db      9,&quot;[     (c) TAG'Soft 98 v1.05&quot;,9,&quot;]&quot;,13,10
        db      9,9,&quot;  Кодирование...&quot;,13,'$'
Help:   db      &quot;Задайте имя COM или EXE-файла в командной строке&quot;,13,10,'$'
F_err2: db      7
F_err1: db      9,&quot;| Hе могу защитить данный файл&quot;,9,&quot;|&quot;,13,10,'$'
F_err:  db      7,&quot; - не могу открыть указанный файл&quot;,13,10,'$'
F_err3: db      9,&quot;|&quot;,9,&quot;   повтоpно !&quot;,9,9,&quot;|&quot;,13,10,7,'$'
All_ok: db      9,&quot;|      Защита установлена.&quot;,9,&quot;|&quot;,13,10,'$'
EndLine:db      9,&quot;+-------------------------------+&quot;,13,10,'$'
copy_org:db     0
        code    ends
        end     Start
----------------------- конец CONDOM.com --------------------------------
;========================================================================
;                постановка защиты KRYPT.com
;========================================================================

        .286
        .model  small
        code    segment
        assume  cs:code,ds:code,es:code

        org     100h                     ; COM-программа

Kstart: jmp short begin

f_name: db      'condom.com',0
adress: dw      0010h           ; откуда крутим (не забудь про 100h) = Tester
ad_mask:dw      1               ; адрес,куда записать маску XOR
begin:  mov     ax,3d02h
        mov     dx,offset f_name
        int     21h             ; Откроем файл
        jc      Exit
        xchg    bx,ax           ; BX - храним!

        mov     dx,cs
        mov     cx,1000h        ; этот файл длиной не более 4к!
        add     dx,100h
        mov     ds,dx           ; следующий сегмент
        xor     dx,dx
        mov     ah,3Fh
        int     21h
        jc      Exit
        push    ax              ; длина

        xor     cx,cx
        mov     dx,cx
        mov     ax,4200h
        int     21h             ; возврат на начало
        push    bx              ; дескриптор

Timer:  in      al,40h
        and     al,0Fh          ; чтобы не кpутить по 16 pаз
        or      al,al
        je      Timer

        mov     cx,1000h
        mov     bx,word ptr cs:[ad_mask]
        mov     byte ptr ds:[bx],al
        mov     bx,word ptr cs:[adress]

main:   xor     ds:[bx],al
        inc     bx
        loop    main

        xor     dx,dx
        pop     bx
        pop     cx
        mov     ah,40h
        int     21h
        mov     ah,3Eh
        int     21h

Exit:   mov     ax,4C00h
        int     21h             ; норм.выход
;-----------------------------------------------------------condom.com
Start:
        mov     al,1                    ; это число будет менятся krypt!
        mov     bx,offset Tester
        mov     cx,1000h
dekrypt:xor     ds:[bx],al
        inc     bx
        loop    dekrypt
        jmp     Zaraza
;-----------------------------------------------------------condom.com
Zaraza:
Tester: db      0
        code    ends
        end     Kstart
------------------------- конец KRYPT.com -----------------------------

---------------------------- MAKE.bat ---------------------------------
@echo off
echo MACRO...
\bc\bin\TASM  CONDOM &gt;errors
if errorlevel 1 goto Edit
\bc\bin\TLINK /t condom.obj
:aaa
if exist krypt.com goto CCCC
echo Krypt ...
\bc\bin\tasm krypt
if errorlevel 1 goto End
\bc\bin\tlink /t krypt
goto aaa
:CCCC
echo Krypt Condom!
krypt
echo;
condom.com condom.com
condom.com
goto End
:Edit
me condom.asm errors
ttt.bat
:End
------------------------ конец MAKE.bat ----------------------------------

                  +===================================+
                  |       Спасибо за внимание !       |##
                  |  некто Татуков А.Г. из славного   |##
                  |           С.Петеpбуpга.           |##
                  +====[http://www.halyava.ru/condom]=+##
                    #####################################

    P.S. Pабота над пpогpаммой не закончена,  я буду  pад  любым  Вашим
пpедложениям  и  замечаниям,  высланным в конфеpенцию relcom.comp.virus
или    оставленным     на     Веб-страничке     поддержки     программы
http://www.halyava.ru/condom.

</PRE>
</TD>
</TR>
</TABLE>
<HR>
<CENTER>(C) NF, 1998-2004</CENTER>
</BODY>
</HTML>
