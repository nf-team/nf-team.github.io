<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>Грэхэм Вайдмэн</TITLE>
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>	
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
	
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
	
    <!---> 	


<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TD>
<CENTER>
<B><FONT FACE="Arial" COLOR="White" SIZE=2 >Грэхэм Вайдмэн</font><br>
<FONT COLOR="White" FACE="Arial" SIZE=4>Изучение LabVIEW с использованием QueryPerformanceCounter
</B></font><br>
<FONT COLOR="WHITE" FACE="Arial" SIZE=2>(Перевод: Климентьев К.Е, 2005. Оригинал находится на </font>
</b><A HREF="http://www.grahamwideman.com/"><I><U>
<FONT FACE="Arial" SIZE=2 COLOR="silver">http://www.grahamwideman.com/</I></U></A></font><font color="white">)</font>
</CENTER>
</TD>
</TR>
</TABLE>


<I><P>Статья написана 16 июня 1999 г. Внесены исправления после консультаций с National Instruments 1 июля 1999.</P></I>
<H3>Содержание</H3>
<P>Привязка ко времени в LabVIEW: функции ожидания</P>
<P>Виртуальный прибор, использующий QueryPerformanceCounter<BR>
Факторы, влияющие на временные характеристики<BR>
Общее введение<BR>
Тесты<BR>
Выполнение “спокойного” теста<BR>
Перемещение мыши<BR>
Открытие программного меню кнопкой “Пуск”<BR>
Минимизация окна<BR>
Максимизация окна<BR>
Запуск Excel<BR>
Выводы<BR>
Условия выполнения тестов<BR>
Комментарии к ранее написанному<BR>
Благодарности<BR>


<B><P>Привязка ко времени в LabVIEW: функции ожидания</P>
</B><P>Функции LabVIEW, снабжающие привязкой ко времени порядка миллисекунд, это “Wait” и “Wait For Next ms Multiple”. Обе онованы на одном и том же внутреннем механизме; я буду ориентироваться на функцию “Wait For Next ms Multiple”, используемую в стандартной конфигурации цикла, привязанного к реальному времени (см. диаграмму ниже). Для измерения моментов событий я использовал функцию Win API под названием QueryPerformanceCounter. Эта функция на платформах x86/Пентиум обращается к высокоточному аппаратному счетчику, который работает с частотой 1.2 МГц (или с периодом 0.8 мкс). Реальная разрешающая способность, с учетом накладных расходов, будет заметно хуже, но все еще во много раз меньше, чем 1 миллисекунда.</P>
<H3>Виртуальный прибор, использующий QueryPerformanceCounter</H3>
<P>Для изучения поведения узла "Wait For Next ms Multiple", я написал простой виртуальный прибор, который использует высокоточную функцию QueryPerformanceCounter. Диаграмма выглядит так:</P>
<P><IMG SRC="Image65.gif"></P>
<P>Этот прибор доступен для загрузки здесь: <A HREF="http://www.wideman-one.com/gw/tech/dataacq/labview/qpc_test11/GWQPCTimeTest11.vi"><U><FONT FACE="Arial" SIZE=2 COLOR="#0000ff">GWQPCTimeTest11.vi</FONT></U></A>.</P>
<P>Обратите внимание на минимум всяческой активности внутри цикла. Графики "Interval" и "QPC minus Iteration" должны снабдить нас информацией о регулярности временных характеристик в разных условиях. Вот несколько комментариев к программе:</P>

<UL>
<P><LI>Если вы скачали виртуальный прибор, вы увидите, как обращаться к измерителю производительности, если вы еще с этим аспектом не знакомы. Одна маленькая фишка касается того, что оба вызова ожидают 64-битного результата, который не поддерживается LabVIEW. Для этого мы используем два 32-битовых целых. Вообще-то, в обоих случаях нам достаточно иметь младший элемент массива. Счетчик должен рано или поздно переполниться, поэтому в серьезных приложениях мы должны использовать и старшие 32 бита, но в простых тестах мы можем их проигнорировать.</LI></P>
<P><LI>Ранее опубликованный вариант этого прибора имел обертку для QueryPerformanceXXX под именем "Run In UI", но сейчас это называется "Reentrant". Это реально увеличило производительность в некоторых сценариях, а вероятные причины этого описаны ниже.</LI></P></UL>

<B><P>Факторы, влияющие на время.</P>
</B><P>“<B>Другие активные процессы</B>”: наиболее важный нерегулярный фактор, зависящий от количества активных процессов, запущенных на PC. Этот фактор очень труден как для управления им, так и для наблюдения за ним.</P>
<B><P>Назначение для виртуального прибора различных исполняющих систем LabVIEW</B>. В тестах, использованных здесь, код диаграммы назначен исполняющей системе “Normal”, и пользовательский интерфейс обслуживается обычной исполняющей системой. Никакой активности пользовательского интерфейса нет во время исполнения критичных ко времени порций кода, и существует всего один прибор, так что единственная исполняющая система, которая активна, это и есть "Normal".</P>
<B><P>Установка приоритета ВП</B>. Каждый ВП имеет определенный приоритет, который может быть установлен программистом, и который изменяется от “Below Normal” до “Time Critical”. Под Win 95/98/NT эта опция устанавливает две вещи:</P>

<UL>
<LI>Приоритет ВП относительно любых других в рамках диспетчера исполнительной системы LV;</LI>
<LI>Приоритет потоков операционной системы, которые работают под исполняющей системой LV, устанавливая приоритет относительно других приложений.</LI></UL>

<B><P>Реентерабельность вызовов DLL-ок</B>. Установка DDL в состояние “non-reentrant” заставляет LV назначать их единственному потоку внутри UI Execution System для того, чтобы “синхронизировать” обращения к ним – т.е. для разрешения DDL-овскому коду не быть вызванным пока он вызывается другим кодом. Это может добавить задержки, но более важно, что заставляет диспетчер операционной системы ипсользовать преимущества вытеснять LV и запускать что-то другое. Итак, если вы знаете, что функции DLL имеют защищенные потоки (могут вызываться неоднократно и одновременно), или вы знаете, что они могут вызываться только однократно, то установите их в состояние “reentrant”.</P>
<B><P>Разделение кода на субVI</B>. Вызов субVI может вызвать переключение на другой поток, так что код будет выполняться по-другому (не обязательно хуже) по сравнению с кодом, не разделенным на субVI.</P>
<B><P>Различия в платформах между W95/98/NT</B>: диспетчер устроен по-разному в разных версиях Windows.</P>
<B><P>Приоритет приложения: </B>само приложение (LabVIEW или скомпилированная программа) может иметь различные приоритеты. Тем не менее, они не складываются и не вычитаются из приоритетов переднего плана, и могут не принести никаких выгод. Подробности – см. на других страницах этого сайта. </P>
<H3>Общее введение</H3>
<P>В общем, подход к изучению должен заключаться в прогоне тестов, в каждом из которых влияет только один изолированный фактор, и исследовании этого влияния. Тем не менее, один из полученных уроков заключается в наличии большого количества факторов, многие из которых пользователь/разработчик не могут контролировать, особенно это касается внутренней работы операционной системы. Выполнение одних и тех же тестов на разных машинах должно приводить к разным результатам.</P>
<B><P>Следовательно, мы предлагаем к рассмотрению лишь <I>примерные </I>ситуации, которые вы можете и должны модифицировать для исследования ваших конкретных ситуаций.</P>
</B><P>Мы выбрали некоторое количество относительно реалистичных сценариев, и прогнали каждый из них при приоритетах Normal и Time Critical для сравнения. Каждый сценарий был выполнен несколько раз для проверки устойчивости результатов. Заметим еще раз, что ни один из этих тестов не показал высокой статистической стабильности, да и на разных машинах выполнялся несколько по разному.</P>
<H3>Прогон “пустого” теста</H3>
<P>Этот прогон связан с несколькими другими обстоятельствами.</P>
<B><P>Нормальный приоритет и стандартное исполнение.</P>
</B><P><IMG SRC="Image66.gif"></P>
<B><P>Преимущественно миллисекундные интервалы</B>: интервалы вполне близки к 1 мс, наблюдаются редкие маленькие отклонения и еще более редкие большие отклонения.</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=9 WIDTH="100%">
<TR><TD WIDTH="52%" VALIGN="TOP" COLSPAN=2>
<P><B>Достигнуты маленькие выбросы</B>: каждый маленький положительный выброс на графике интервалов (меньший, чем миллисекундный интервал Wait) свидетельствует о незначительной задержке итерации. Эта ситуация следует за итерацией с укороченным интервалом и соответствует передаче управления планировщику. Внимательный взгляд на правый рисунок демонстрирует цикл номер 2931, при котором итерация задержана, причем он следует за укороченной итерацией.</TD>
<TD WIDTH="48%" VALIGN="TOP">
<P><IMG SRC="Image67.gif"></TD>
</TR>
<TR><TD WIDTH="19%" VALIGN="TOP">
<P><IMG SRC="Image68.gif"></TD>
<TD WIDTH="81%" VALIGN="TOP" COLSPAN=2>
<B><P>Большие выбросы=потерянные миллисекунды</B>: большие выбросы интервалов (&gt;1 мс) демонстрируют итерации более длинные, чем 1 мс и результат потерянных миллисекунд. На левом графике подробно изображен цикл 3070 с задержкой 4 миллисекунды. Это некомпенсированные серии коротких циклов – вместо миллисекунд, которые пропущены. Они вызывают соответствующие шаги на графике QPC-итераций, где текущее время опережает счетчик итераций. Можно ли избежать таких неожиданных задержек? Учитывая внешние источники задержек, это вполне нормальное поведение функции "Wait for Next ms Multiple". Тем не менее, это может быть не тем, чего хотел бы программист: 1000 итераций в пустом цикле с "Wait for Next ms Multiple" займут более 1000 мс.</TD>
</TR>
</TABLE>

<B><P>Дрейф</B>: также наблюдается медленный дрейф между QPC и счетчиком итераций, который можно видеть на проградуированном графике QPC-итераций. Это вызывается довольно медленным LV- механизмом для генерации миллисекунд. Поскольку он основан на временном кванте операционной системы, то скорей всего означает, что квант операционной системы несколько больше, чем 1 мс. (Обратите внимание, что пока LV работает, квант операционной системы установлен в “максимальное разрешение”), в отличие от обычных 10-20 миллисекунд. </P>
<B><P>Пустой – Time Critical: </B>тот же сценарий, что и выше, только приоритет прибора (и его потока) повышается до максимума, до TimeCritical.</P>
<P><IMG SRC="Image69.gif"></P>
<B><P>Выбросы более короткие, чем 1 мс:</B> мы должны иметь в виду, что при других прогонах мы наблюдали значительно большие выбросы, что можно объяснить обращениями операционной системы к диску.</P>
<H3>Перемещение мыши</H3>
<B><P>Приоритет: Нормальный</P>
</B><P><IMG SRC="Image70.gif"></P>
<B><P>Приоритет: Time Critical</P>
</B><P><IMG SRC="Image71.gif"></P>
<P>Повышение приоритета сильно уменьшает выбросы во время “мышиного” теста.</P>
<B><P>Нажатие кнопки “Старт” в Program Menu </P>
</B><P>Нажатие кнопки старт в Program Menu и других подменю вызывает чтение диска и возрастание выбросов.</P>
<B><P>Приоритет: Нормальный.</P>
</B><P><IMG SRC="Image72.gif"></P>
<P>Обратите внимание на выбросы длительностью выше 80 мс. Изредка при других прогонах этого сценария мы наблюдали выбросы длительностью до 250 миллисекунд.</P>
<B><P>Приоритет: Time Critical.</P>
</B><P><IMG SRC="Image73.gif"></P>
<P>Выбросы нейтрализованы. Видимо, активность диска менее приоритетна, чем Time Critical.</P>
<H3>Минимизация окна</H3>
<P>Во время теста некоторые окна минимизировались щелчком по кнопке минимизации на заголовке окна (см. циклы 1300, 2300, 3800 на графике Normal и 3500,4300,4800 на Time Critical).</P>
<B><P>Приоритет: Нормальный.</P>
</B><P><IMG SRC="Image74.gif"></P>
<B><P>Приоритет: Time Critical.</P>
</B><P><IMG SRC="Image75.gif"></P>
<P>Обратите внимание, как величина выбросов (т.е. протяженность отдельных циклов) существенно уменьшается при приоритете Time Critical, но количество разорванных циклов сильно увеличивается, как изображено на нижнем графике. Детальный анализ (см. ниже) выброса в районе цикла 4800 показывает 30 успешных циклов в течение 10 мс.</P>
<P><IMG SRC="Image76.gif"></P>
<H3>Распахивание окна</H3>
<B><P>Приоритет: нормальный.</P>
</B><P><IMG SRC="Image77.gif"></P>
<B><P>Приоритет: Time Critical.</P>
</B><P><IMG SRC="Image78.gif"></P>
<P>Влияние этого фактора ликвидируется приоритетом Time Critical.</P>
<P>&nbsp;</P>
<H3>Запуск Excel</H3>
<P>Я не уверен, нужно ли это использовать в качестве теста, но National Instruments применяет именно этот сценарий для в LabVIEW 5 при демонстрации приоритетов. Как бы то ни было, здесь мы сделаем нечто похожее. Обратите внимание, что вам надо перезагрузить систему между прогонами, поскольку Excel, будучи неоднократно запущен, работает быстрей, чем в самый первый раз, так как многие его компоненты остаются в памяти.</P>
<B><P>Приоритет: Нормальный.</P>
</B><P><IMG SRC="Image79.gif"></P>
<B><P>Приоритет: Time Critical.</P>
</B><P><IMG SRC="Image80.gif"></P>
<P>Time Critical снова сильно уменьшает самые крупные выбросы, и имеет определенное влияние на общее количество “потерянного времени”.</P>
<H3>Выводы</H3>
<P>Понятно, что все это не слишком адекватно характеризует поведение функции “Wait For” (при очень сильном влиянии многозадачности в операционных системах). Тем не менее, я считаю, что все это имеет некоторый смысл, и вот почему:</P>

<OL>
<LI>Используя "Wait For" и ожидая точность в несколько десятков или сотен миллисекунд, можно получить задержки такого же порядка, что существенно;</LI>
<LI>Повышая приоритет до "Time Critical", можно совершенно решить проблему;</LI>
<LI>Активность конкурирующих потоков, которая участвует в этих задержках, может быть вызвана активностью самого пользователя или операционной системы, так что избавиться от нее техническими методами может оказаться невозможным, зато просто не двигайте мышью и не нажимайте на кнопку “Start”!</LI>
</OL>

<P>Мнение, что LabVIEW работает плохо, - неверно, на самом деле это отражение свойств операционной системы. Тем не менее, играет роль, что программист, исследующий свои приложения (не обязательно написанные на LabVIEW), спокойно относится к возникающим задержкам. Во многих приложениях есть возможность компенсировать их, в других приложениях необходимо использовать внешние средства для выполнения критичных ко времени задач (например, оборудование LabVIEW RT).</P>
<P>Предсказание свойств ваших приложений должно быть существенно проще если существует адекватное описание временных характеристик среды, но у нас его нет, и это отдельная проблема, зависящая от многих факторов, многие из которых зависят от конкретной системы, на которой работает приложение. По сведениям, которые неформально сообщили мне люди из National Instruments, вот что актуально и для LabVIEW, и для других сред разработки:</P>
<I><BLOCKQUOTE>…различия, которые мы измерили в различных версиях NT с использованием усреднения для исключения загрузки операционной системы, показывают, что </I>[<I>авторитетная характеристика</I>]<I> почти невозможна, и если пользователь хочет получить детерминизм системы, ему необходимо сделать что-то похожее и исследовать это самостоятельно.</BLOCKQUOTE>
<BLOCKQUOTE>Поварившись во всем этом </I>[…], <I>можно было стать человеком, который знает, что он делает, используя LabVIEW, DOS, MacOS, Windows и другие “не-реально-временные” инструменты для построения детерминированных систем, потому что он сам сделал это, изучил это и настроил это. Потом такие люди отходили в сторону, и такие системы оказывались запущены в автономную работу. Добавление всего одного рисового зерна требует перенастройки всей системы. Windows NT сюда тоже относится. Если пользователи хотят получить статистику работы их сложных систем, они должны собрать данные, подвергнуть систему испытаниями и обратиться к нам, чтобы мы проинтерпретировали их результаты </I>[…] <I>LabVIEW RT – это попытка изменить такое положение дел. В среде реального времени большее количество людей будут делать все правильно и менее хаотично в ситуации, когда произошли изменения.</BLOCKQUOTE>
</I><H3>Условия тестирования</H3>
<P>Примеры, рассмотренные здесь, работали (и скриншоты это подтверждают) в следующей системе:</P>

<UL>
<LI>Intel Pentium II 233 MHz, 128 Meg RAM, NT 4 SP3. Система располагалась в локальной сети с другим PC, и сеть не была отключена. Тем не менее, никакой сетевой активности не ожидалось, и ее действительно не было, что показали светодиоды концентратора и сетевых карт;</LI>
<LI>LabVIEW 5.0 демо-версия;</LI>
<LI>Все выполнялось в среде LabVIEW и не компилировалось в EXE;</LI>
<LI>была включена опция "Run with multiple threads" (“Использовать многопоточность”) – эта опция включена по умолчанию;</LI>
<LI>приложение работало с Нормальным приоритетом процесса.</LI>
</UL>

<H3>Комментарии, добавленные после опубликования</H3>
<P>Я ожидал, что документация LabVIEW, или другие источники, скажут что-нибудь авторитетное о временных аспектах работы виртуальных приборов, но такого практически не наблюдалось. Всего две более-менее подходящих цитаты можно найти в документации LabVIEW 5:</P>
<I><P>Function and VI Reference: Wait Until Next ms Multiple: Ожидает, пока количество миллисекунд таймера не сравняется с ожидаемым количеством миллисекунд. Используйте эту функцию для синхронизации работы. Вы можете вызывать ее в цикле для управления временем выполнения цикла. Но это сильно зависит от оборудования, и на медленных системах, например, на i80386, вы получите худшую длительность цикла. </P>
<P>Контекстная помощь "Timing": функции работы со временем оперируют с миллисекундами, в то же время ваша операционная система может и не обеспечивать такой точности. </I>(<I>Windows 95/NT</I>)<I> . Таймер имеет разрешающую способность 1 мс. Но это сильно зависит от оборудования, и на медленных системах, например, на i80386, вы получите худшую разрешающую способность.</P>
</I><P>Только всплывающие подсказки LabVIEW для функций ожидания говорит вам: “разрешающая способность таймера зависит от системы, и может быть хуже 1 мс. Подробней - см. <I>Function Reference Manual</I>”. Но этот документ не содержит ожидаемых подробностей.</P>
<P>Имеющиеся прочие, довольно всесторонние материалы (и книги сторонних авторов), которые призывают очень осторожно обращаться с длительностью первого цикла (она не такова, как вы о ней думаете!), с использованием 386 машин, тем не менее обращают очень мало внимания на временные аспекты, вносимые планировщиком операционных систем, что привело меня к мысли о необходимости практически заново описывать подробности работы LabVIEW. Как показали данные исследования, многозадачность влияет на LabVIEW так же, как и на другие приложения. В NI меня поблагодарили за эту статью, поздравили с найденной ошибкой в документации и пообещали ее в какой-то мере исправить.</P>
<H3>Благодарности</H3>
<P>Эта статья во многом основана на данных, поправках и результатах, полученных от Greg McKaskle и Jim Balent из LabVIEW, от других бывших сотрудников этой компании, от корреспондентов, обитающих в “info-labview list server”, и особенно от Mark Hanning-Lee, который прислал мне виртуальный прибор с некоторыми исправлениями.</P>


    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

