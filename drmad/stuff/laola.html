<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<title=" Файловая система ЛАОЛА. Структурированное хранилище.  Двоичная структура OLE-документов">
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Courier; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>    
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
    
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
    
    <!--->  

<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
 <FONT SIZE=+3 COLOR="White">
  ФАЙЛОВАЯ СИСТЕМА ЛАОЛА<br>
</FONT>
<FONT SIZE=+1 COLOR="White">
Структурированное хранилище.  Двоичная структура OLE-документов<br>
</FONT>
<FONT SIZE=-2 COLOR="White">
(c) 1996, 1997 by Martin Schwartz, schwartz@cs.tu-berlin.de
</FONT>
</TH>
</TR>
</TABLE>

<br><a href="index.html"><img src="back.gif"></a><br>

<H2>     Пособие для хакинга</H2>

<A HREF="#ma">     A - Предварительные замечания</A><BR>
<A HREF="#mb">     B - Общие сведения</A><BR>
<A HREF="#mc">     C - Базовые понятия</A><BR>

<A HREF="#m1">     1. Блок заголовка</A><BR>
<A HREF="#m2">     2. Хранилище Больших Блоков</A><BR>
<A HREF="#m3">     3. Большие Блоки Данных</A><BR>
<A HREF="#m31">     3.1. Хранилище Малых Блоков</A><BR>
<A HREF="#m32">     3.2. Хранилище Набора Свойств</A><BR>
<A HREF="#m33">     3.3. Хранилище Свойств</A><BR>
<A HREF="#m34">     3.4. Где располагаются Малые Блоки Данных?</A><BR>
<A HREF="#m35">     3.5. Наборы Свойств</A><BR>
<A HREF="#m4">     4. Блоки Мусора</A><BR>

<A HREF="#mt1">     Таблица 1: Заголовок ЛАОЛы</A><BR>
<A HREF="#mt2">     Таблица 2: Хранилище Свойств</A><BR>

<p>
Только для белых

<H2>                    <A NAME="ma">A - Предварительные замечания</H2>

 <P>   Однажды я начал писать  некую  программу,  которая  должна
была иметь доступ к документам, созданным при помощи Microsoft
Wor for Windows 6.  Я хотел оставить  ее  совместимой,  а  для
этого   не  следовало  использовать  методы,  специфичные  для
операционных  систем.  Таким  образом,   я   решил   научиться
разбираться в двоичной структуре документов.
    <P>Посмотрев на двоичный дамп документа,  я слегка припух. На
первый взгляд формат  файла  документа  казался  очень  сильно
отличным  от  того,  который  создавался  в  Word  2.  Когда я
посмотрел  внимательней,  стало  ясно,  что  некоторые   очень
похожие  двоичные  куски  находятся  и  внутри  новых  наборов
данных. Фактически, документ Word 6 оказался похож на документ
формата   Word  2,  сохраненный  среди  прочих  дополнительных
данных.
    <P>Насколько я   знаю,   не   существует  публично  доступных
источников  информации,  как  эта  файловая  система   (формат
документа) работает. В общем надо бы, чтобы производители были
обязаны показывать,  какие ингридиенты есть в их продуктах.  В
случае  личных  систем я думаю,  что людям следовало бы знать,
какого рода дополнительная информация находится в их (возможно
публично  доступных)  документах.  Иными словами,  содержат ли
документы  информацию  про   дату   создания,   информацию   о
принтерах,  структурах  данных  и серийных номерах.  Или,  что
несколько хуже,  содержат ли документы или могут ли  содержать
другие приватные данные.
    <P>Суммируя эту тему для нижеописанного формата  файла, можно
сказать,  что  он  всегда сохраняет дату последней модификации
данных в объектах.  Вследствие слабой реализации Windows 3.x и
старых  версий  32-битных  Windows,  он все еще содержит некие
секции  &quot;мусора&quot;.  Эти  секции  могут  хранить   нежелательные
сведения об авторе.  Конечно,  в зависимости от принадлежности
программ,  и  другие  приватные   данные   могут   сохраняться
незаметно.
    <P>Этот текст   *не*   объясняет,   как  структурирован  файл
Microsoft Word.  Этот текст объясняет  как  работает  файловая
система,  которую ранние программы от Microsoft типа Microsoft
Word используют для сохранения своих  документов.  Фактически,
это  следовало бы назвать файловой системой OLE,  а философию,
на которой  это  основано  -  технологией  OLE/Com.  Но  ввиду
отсутствия  какой-либо технической низкоуровневой спецификации
касаемо этой темы,  мое объяснение может в  некоторых  случаях
отличаться  или  быть  неверным.  В  этих  случаях  я  не могу
уверенно объяснить файловую систему OLE,  но будет по  крайней
мере  похоже.  Таким  образом,  я решил дать своим разработком
похожее имя. Имя - LAOLA.
    <P>Копирование. Этот файл и исходные коды, на которые имеются
ссылки,  распространены в терминах GNU General Public License,
версия 2 от Июля 1991 г. Если у Вас нет копии, можете найти ее
здесь.

<H2>                      <A NAME="mb">B - Общие сведения</H2>

    <P>Цифровые документы обычно состоят  из  более,  чем  одного
файла.  При  сохранении  и  изменении  таких  документов  есть
проблема объединять все такие файлы вместе  в  соответствии  с
некими   иерархическими   соглашениями.  Формат  файлов  LAOLA
позволяет сохранять файлы  в  иерархическом  порядке  в  одном
общем файле.  Он может содержать один или более каталогов,  из
которых  каждый  может  содержать  один  или  более  файлов  и
каталогов.
    <P>На самом  деле  это  можно  успешно сделать использованием
некоторых популярных архивов типа &quot;zip&quot;.  Но  Microsoft  пошел
своим путем. Я думаю, не только вследствие своей маркетинговой
философии,  но также потому что  они,  наверное,  намеревались
разработать файловую систему, управляемую их философией &quot;OLE&quot;,
что требует иметь иерархическую файловую структуру.
    <P>К сожалению,  Microsoft не содержит механизмов верификации
документов.  То-есть,  если  документ  LAOLA поврежден,  то он
становится  недоступен.  Если  кто-то  вмешается  в  структуру
документа,  этого  никто  не  заметит.  Если документ содержит
много  неиспользуемого  пространства,  это  так  и  останется.
Microsoft стратегически не предусматривает никакой компенсации
недостатков своей новой файловой системы.

          <H2>           <A NAME="mc">C - Базовые понятия.</H2>

   <P> Никаких гарантий!   Этот  текст  описывает  предположения,
основанные на спекуляциях и экспериментах, и совсем немного на
документах.  Тем не менее,  даже если я считаю какой либо факт
верным, он может содержать ошибки!
    <P>Что такое файл LAOLA? Коротко, файл LAOLA это архив. Архив
может объединять файлы и каталоги.  Каждая точка входа в архив
имеет блок информации длиной 0х80 байт. Чтобы сохранять файлы,
архив содержит список больших блоков  данных  и  список  малых
блоков  данных.  Файлы  с размером меньше,  чем 0x1000 байтов,
будут сохранены в Малые Блоки данных,  а остальные - в Большие
Блоки данных.

<I>Типы данных.</I> Файлы LAOLA имеют три основных типа данных:

<OL>
<LI>4-байтовые целые (&quot;long&quot;) 0x12345678         -&amp;gt;0x78 0x56 0x34 0x12
<LI>2-байтовые целые (&quot;word&quot;) 0x1234 0x5678      -&amp;gt;0x34 0x12 0x78 0x56
<LI>1-байтовые целые (&quot;char&quot;) 0x12 0x34 0x56 0x78-&amp;gt;0x12 0x34 0x56 0x78
</OL>    

<P>Целые сохраняются в режиме &quot;little endian&quot; (&quot;VAX&quot;, &quot;x86&quot;).
Это означает, что они сохраняются группами по 8 бит, в которых
младший значащий бит - сначала.  Потоки символов сохраняются в
очереди: первый вошел, первый вышел.

<p><I>    Блоки. </I>Во время первого шага каждый файл LAOLA разделяется
на  0х200-байтовые  (512-байтовые)  &quot;большие  блоки&quot;,  так что
размер каждого файла  LAOLA  делится  без  остатка  на  0х200.
Каждый блок ссылается на перечисление, начинающееся с номера -
1 для первых 0х200 байтов,  если  считать  снизу  вверх.  Файл
состоит из множества блоков:
<PRE>
    файл &lt;=&gt; объединение больших блоков {-1, 0, 1 .. $maxblock},

    ($maxblock = (sizeof(file)-1) / 0x200 -1), $maxblock e {1, 2, .. }
</PRE>

   <I>  Базовые части.</I> Большие блоки делят файл на четыре базовые чаcти:
<OL>
     <LI>Блок заголовка
     <LI>Хранилище Больших Блоков
     <LI>Большие Блоки данных
     <LI>Мусорные блоки данных
</OL>    

<P>Неиспользуемая, но не мусорная  информация.  Блоки  LAOLA,
кажется,   содержит   некоторые   неструктурированные  данные.
Некоторые из них,  кажется,  (все еще?) абсолютно не нужны,  а
назначение других пока непонятно.  Тем не менее,  для создания
файлов LAOLA достаточно скопировать эти значения. В таблицах в
конце этого документа неизменяемые значения маркированы точкой
&quot;.&quot;, известные и изменяемые - восклицательным знаком &quot;!&quot;.

<H2>                        <A NAME="m1">  1. Блок Заголовка</H2>

    <P>Заголовок построен  из первого блока (блок -1, пробегающий
от смещения 0х00 до 0х1FF). Заголовок начинает с 8-байтовой 16
-ричной  строки {d0 cf 11 e0 a1 b1 1a e1}.  Заголовок содержит
некоторую первичную информацию о структуре.  Назначение  будет
объяснено ниже в этом документе.

<P>Пример:
<PRE>
    00000: d0 cf 11 e0  a1 b1 1a e1  00 00 00 00  00 00 00 00
    00010: 00 00 00 00  00 00 00 00  3b 00 03 00  fe ff 09 00
    00020: 06 00 00 00  00 00 00 00  00 00 00 00  01 00 00 00
    00030: 01 00 00 00  00 00 00 00  00 10 00 00  02 00 00 00
    00040: 01 00 00 00  fe ff ff ff  00 00 00 00  00 00 00 00
    00050: ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff *

00:  stream $laola_id           Идентификатор {d0 cf 11 e0 a1 b1 1a e1}
2c:  long $num_of_bbd_blocks    Количество их в Хранилище Больших Блоков
30:  long $root_startblock      1-й Большой Блок в Корневом Каталоге
3c:  long $sbd_startblock       1-й Большой Блок Хранилища Малых Блоков
4c[]:long $bbd_list[i]          массив из $num_of_bbd_blocks номеров  Больших Блоков

</PRE>

<P>(детальную информацию см. в <A HREF="#mt1">Таблице 1</A>)

<H2><A NAME="m2">2. Хранилище Больших Блоков</H2>

    <P>Хранилище Больших   Блоков   управляет  Большими  Блоками.
Большие Блоки имеют размер  в  точности  0х200  (512)  байтов.
Часто  Хранилище Больших Блоков будет состоять всего из одного
Большого Блока.

<P>  Хранилище Больших Блоков&lt;=&gt;Объединение Больших Блоков {bbd_list[i]},

<P>     bbd_list состоит  из $num_of_bbd_blocks элементов,  сохраненных в
              позиции  &lt;header:4c&gt;.

<P>Пример:
<PRE>
   00200: fd ff ff ff  05 00 00 00  fe ff ff ff  04 00 00 00
   00210: 06 00 00 00  fe ff ff ff  07 00 00 00  08 00 00 00
   00220: 09 00 00 00  0a 00 00 00  0b 00 00 00  fe ff ff ff
   00230: ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff *

</PRE>    

<P>
Хранилище Больших Блоков представляет собой массив номеров
блоков,  чей индекс начинается с  нуля.  Вхождение  0  в  этом
примере  со  значением  0xfffffffd (-3),  ссылается на блок 0.
Вхождение 1,  со значением 0x00000005  ссылается  на  блок  1.
Вхождение  2  соответствует  блоку  2 и т.д.  Каждое вхождение
может иметь одно из следующих значений:
<pre>
   0xfffffffd (-3) : это специальный блок
   0xfffffffe (-2) : конец цепочки
   0xffffffff (-1) : не используется
   0 .. $maxblock  : следующий элемент цепочки (номер Большого Блока)
   $maxblock+1 ..  : не определено
</pre>
<p>
    В заголовке   переменная   $root_startblock   должна  быть
проинициальзирована,  в примере ему присвоено значение 1.  Это
значение  указывает,  какой  блок  первый  в  цепочке  блоков,
принадлежащих корневому каталогу.  В примере это  должно  быть
прочитано так:
<p>
    Как читать  цепочку  блоков.  Начнем  с позиции 1.  Первый
блок,  принадлежащий корневому каталогу,  это блок 1. Значение
вхождения  в  Хранилище  Больших  Блоков  с  позицией  1 есть:
0x00000005.  Следующий блок, принадлежащий корневому каталогу,
это  блок  5.  Значение вхождения в Хранилище Больших Блоков в
позиции 5 это  0xfffffffe  (-2).  Это  означает:  здесь  конец
цепочки.   Итак,  корневой  каталог  окончательно  состоит  из
блоков: {1,5}.
<p>
    В заголовке    также    известно    значение    переменной
$sbd_startblock.  Попытайтесь  найти   это   значение,   затем
попытайтесь  получить  цепочку принадлежащих блоков!  (Если вы
хотите увидеть решение, посмотрите в конец этого документа).
<p>
<I>    Замечание</I>: во  время  чтения  цепочки  только  значения  в
диапазоне от 0 до $maxblock,  и -2, являются корректными. Если
в цепочке попадаются другие значения, то это ошибка.
<p>
<I>    Замечание</I>: Хранилище  Малых Блоков может отсутствовать.  В
этом случае $sbd_startblock имеет значение 0xfffffffe (-2).
<p>
<I>    Выводы:</I> с помощью  блока  Заголовка  и  Хранилища  Больших
Блоков  становятся  известны  значения  списка Больших Блоков:
@root_list и @sbd_list.
<h2>
    <A NAME="m3"> 3. Большие Блоки Данных
</h2>
<h3>
     <A NAME="m31">3.1. Хранилище Малых Блоков
</h3>

   <p> Хранилище Малых  Блоков обслуживает Малыми Блоками.  Малые
Блоки имеют длину в точности 0х40 (64) байтов. Часто Хранилище
Малых  Блоков  будет  состоять  в  точности из одного большого
блока.  Некоторые документы не имеют  Хранилища  Малых  Блоков
вообще.
<p>
 Хранилище малых блоков &lt;=&gt; объединение больших блоков {sbd_list[i]},
<p>
    sbd_list состоит из number of chain_elements(sbd_list) элементов.
             Список считывается из Хранилища Больших Блоков,
             начало списков - это $sbd_startblock (-&gt; Раздел 2)
<p>
Пример:
<pre>
    00600: 01 00 00 00  fe ff ff ff  ff ff ff ff  ff ff ff ff
    00610: ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff
</pre>
<p>
    Вхождения в  Хранилище  Малых  Блоков  *не*  ссылаются  на
абсолютную позицию в файле,  подобно как вхождения в Хранилище
Больших  Блоков.  Они  ссылаются на позицию в (файл состоит из
больших блоков) @sbd,  соответствующем списку больших  блоков.
Этот  список  отмечен отдельным вхождением в корневом каталоге
Хранилища  Свойств.  Таким   образом,   необходимо   объяснить
Хранилище Свойств.

<h3>
<A NAME="m32">3.2 Хранилище Набора Свойств
</h3>
<p>
    После прочтения Раздела 2 стало известно содержимое списка
Больших Блоков @root_list. Этии блоки содержат блоки Хранилища
Набора Свойств (ppss).
<p>
    блоки хранилища набора свойств &lt;=&gt; объединение больших блоков
                                       {root_list[i]}
<p>
    root_list состоит из  number_of_chain_elements(root_list)  элемен-
              тов. Список считывается из хранилища Больших Блоков,
              начало списков - это $root_startblock (-&gt; Раздел 2)

<h3>
<A NAME="m33">3.3 Хранилище Свойств
</h3>
<p>
    Блоки типа ppss (-&gt; раздел 3.2) делятся на  блоки размером
0х80   байт.  Эти  0х80-байтовые  блоки  составляют  Хранилище
Свойств (pps).  Каждый элемент типа pps - это число, начиная с
0. Каждый pps сылается на &quot;файл&quot; или представляет &quot;каталог&quot;.
<p>
Пример:
<pre>
00400: 52 00 6f 00 6f 00 74 00 20 00 45 00 6e 00 74 00 R o o t  E n t
00410: 72 00 79 00 00 00 00 00 00 00 00 00 00 00 00 00 r y
00420: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00430: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00440: 16 00 05 00 ff ff ff ff ff ff ff ff 03 00 00 00
00450: 00 09 02 00 00 00 00 00 c0 00 00 00 00 00 00 46
00460: 00 00 00 00 00 00 00 00 00 00 00 00 86 29 f6 1f
00470: ad 57 bb 01 03 00 00 00 00 0f 00 00 00 00 00 00

40:  word   $pps_sizeofname     размер структуры $pps_rawname
42:  byte   $pps_type           тип pps-объекта (1=хранилище|2=поток||5=корневой каталог)
44:  long   $pps_prev           предыдущий pps
48:  long   $pps_next           следующий pps
4c:  long   $pps_dir            каталог pps
74:  long   $pps_sb             стартовый блок свойств
78:  long   $pps_size           размер свойств
</pre>

<p>
(Для детальной информации см. <A HREF="#mt2">Таблицу 2</A>)

    <P>Первые 0х40  байтов  зарезервированы  под  имя pps.  Длина
имени  располагается  в  $pps_sizeofname.   Имя   может   быть
конвертировано  в  строку  ASCII  $pps_name  только  удалением
каждого четного символа.  В этом примере длина имени  0х16,  а
$pps_name - это &quot;Root Entry\00&quot;.  Завершающий \0 в стиле языка
С должен быть удален.  Если случится,  что $pps_sizeofname это
0,  то  этот  блок  размером  0х80  байтов  -  не pps и должен
игнорироваться.
    <P>Каждый объект  типа pps имеет префикс и окончание.  Каждый
pps также может быть каталогом (или  &quot;хранилищем&quot;). $pps_prev,
$pps_next,    $pps_dir   ссылаются   на   возрастающий   номер
0х80-байтовых блоков,  как объяснено выше. В этом примере pps,
который  начинается  с  0х400,  содержит номер 0,  pps c 0х480
содержит  1,  pps  с  500  содержит  2  и  т.д.  Если   читать
последовательно,  упорядоченный  список  pps-ов окончится (см.
функцию get_pps_chain в &quot;laola.pl&quot;).
<P>
 <I>    Типы свойств.</I> Каждый pps может быть одного из трех типов:

<ol>
     <li> Хранилище, это каталог
     <li> Поток, это файл
     <li> Корневой каталог, это корневой каталог
</ol>
<p>
    Если $pps_size  ненулевой,   то   $pps_sb   ссылается   на
начальный   блок   принадлежащего   свойства.  Начальный  блок
ссылается на Хранилище Больших Блоков,  если $pps_size  больше
или  равен 0x1000 (4096) байтов.  Если размер свойства меньше,
то $pps_sb ссылается на  Хранилище  Малых  Блоков.  Есть  одно
исключение:  $pps_sb  в  корневом  каталоге (это всегда pps 0)
всегда ссылается на Хранилище Больших Блоков.
<p>
    Теперь легко  читать  &quot;файлы&quot;:  список  Больших  или Малых
Блоков должен быть получен (как это делалось ранее  при помощи
root_list  и  sbd_list) из Хранилища Больших или Малых блоков,
так  что  соответствующие  блоки  должны  быть  прочитаны   на
следующем шагу, и размер должен быть усечен до $pps_size.
<p>
    Если тип pps это корневой каталог или хранилище,  то,  как
минимум,  переменные $pps_ts2d и  $pps_ts2s  инициализированы.
Вместе  эти  переменные  составляют  64-битовое  целое  число,
которое представляет время и дату. Эта переменная считает в 10
^-7  c,  начиная  с  01/01/1601  00:00.  Если  тип  - корневой
каталог,  то $pps_sb указывает на первый большой блок в списке
малых блоков @sb_list. См. ниже:

<h3>
<A NAME="m34">3.4 Где Малые Блоки данных?
</h3>

<p>
    Корневой каталог  -  это  0х1000-байтовое  исключение   из
правил  раздела 3.3.  Размер в примере равен 0хF00,  и значит,
должен принадлежать Хранилищу Малых Блоков. Фактически, файл в
корневом  каталоге всегда ссылается на таблицу Больших Блоков.
Стартовый блок здесь - это 3. Посмотрите:
<pre>
    00200: fd ff ff ff  05 00 00 00  fe ff ff ff  04 00 00 00
    00210: 06 00 00 00  fe ff ff ff  07 00 00 00  08 00 00 00
    00220: 09 00 00 00  0a 00 00 00  0b 00 00 00  fe ff ff ff
    00230: ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff *
</pre>
<p>
    Результирующая цепочка:  {3,  4,  6,  7,  8, 9, a, b}. Эта
&quot;урожайная&quot; цепочка дает блоки, которые снабжают пространством
для малых блоков.  Сылки на малые блоки соответствуют позициям
в &quot;файле малых блоков&quot;,  что в  данном  примере  построено  из
цепочки больших блоков, начинающейся с блока 3.
<p>
    small data blocks &lt;=&gt; объединение больших блоков {sb_list[i]}
</p>
<p>
    sb_list состоит   из   number  of  chain_elements(sb_list)
элементов. Список читается из хранилища больших блоков, начало
списка  -  это  $root_startblock  -&gt;  хранилище  свойств  0 -&gt;
pps_sb.
<p>
    Это все,  что требуется, чтобы вытянуть какой-либо файл из
архива LAOLA.  Вы должны проверить это при помощи &quot;lls -s&quot;. Но
есть еще кое-что.
<h3>
<A NAME="m35">     3.5. Наборы свойств
</h3>
<p>
    В противоположность  обычным  сохраненным  файлам   иногда
требуется  сохранять  специально  структурированные файлы &quot;баз
данных&quot;.  Эти структурированные  файлы  обращаются  к  наборам
свойств.  Существует хорошая статья про то,  как это сделано у
Microsoft,  &quot;OLE Property Sets Exposed&quot; от Charlie Kindel. Там
упоминается,   что   точная   информация  про  наборы  свойств
находится также в Win32 SDK.
<p>
   Выводы и дальнейшая информация - еще предстоит сделать! -

<h2>
<A NAME="m4">     4. Мусорные блоки
</h2>
<p>
    Последние 4  раздела  посвящены  &quot;мусорным блокам данных&quot;.
Эти мусорные блоки - это блоки,  сохраненные в  документе  без
каких-либо  ссылок  на  них  со   стороны  системы LAOLA.  Они
имеются не всегда.  Наиболее известный пример  этого  -  опция
Microsoft Word &quot;быстрое сохранение&quot; (отключите ее,  если этого
не  сделали).  Сохраненные  с  этой  опцией  документы  обычно
наполовину состоят из мусора. Другой пример - Star Writer 3.1,
который принципиально делает 2 больших блока мусора.
<p>
    Некоторые блоки  только  частично  состоят  из мусора,  их
можно было  бы  назвать  &quot;вонючими&quot;  блоками.  Это  происходит
потому,  что размер данных не всегда точно соответствует 0х200
(или 0х40 байт для малых  блоков).  Тогда  остаток  последнего
блока в цепочке всегда будет содержать мусор.
<p>
    Как и  любой  мусор,  мусорные  данные  - нежелательны.  В
простейшем случае они просто раздувают размер файлов.  Также в
любом случае они противоречат требованиям безопасности данных.
Поскольку вы не можете знать,  что внутри, вы теряете контроль
над  своими  данными.  В  Usenet-е даже сообщалось,  что таким
образом с Word-файлом &quot;уплывали&quot; секретные пароли  и приватные
письма.
<p>
    Но хорошо,   что   в  отличие  от  радиоактивных  отходов,
мусорные    данные    удаляемы.    Просто    посмотрите     на
демонстрационную  программу &quot;lclean&quot; в секции исходников.  Что
касается  мусорных данных,  то,  как я слышал, Microsoft знает
об  этой проблеме в OLE и пофиксили ее в Win32.  Тем не менее,
если  вы  используете  Windows  3.1,  вам,  вероятно,  поможет
lclean.

<p>
Ну и как?
<p>
Martin
<p>
<center>
                                - The End -
</center>

<H2>Таблицы</H2>

<H3><A NAME="mt1">Таблица 1: Блок 0 (заголовок laola)</H3>

<pre>
смещение тип значения      константа функция
00: stream  $laola_id           !  identifier {d0 cf 11 e0 a1 b1 1a e1}
08: long 0                      ?
0c: long 0                      ?
10: long 0                      ?
14: long 0                      ?
18: word 3b                     ? revision ?
1a: word 3                      ? version  ?
1c: word -2                     ?
1e: byte 9                      ?
1f: byte 0                      ?
20: long 6                      ?
24: long 0                      ?
28: long 0                      ?
2c: long $num_of_bbd_blocks     !  Number of big block depot blocks
30: long $root_startblock       !  Root chain 1st block
34: long 0                      ?
38: long 1000                   ?
3c: long $sbd_startblock        !  small block depot 1st block
40: long 1                      ?
44: long -2                     ?
48: long 0                      ?
4c[]: long $bbd_list[]          !  array of $num_of_bbd_blocks big block numbers    
</pre>

<P>Конец нулевого блока должен быть:  long -1                   .

<P>####

<h3>
<A NAME="mt2">Таблица 2: Хранилище свойств
</h3>

<pre>
смещение тип значения      константа функция
00:     stream $pps_rawname     !  name of the pps
40:     word $pps_sizeofname    !  size of $pps_rawname
42:     byte $pps_type          !  type of pps (1=storage|2=stream|5=root)
43:     byte $pps_uk0           !  ?
44:     long $pps_prev          !  previous pps
48:     long $pps_next          !  next pps
4c:     long $pps_dir           !  directory pps
50:     stream 00 09 02 00      ?
54:     long 0                  ?
58:     long c0                 ?
5c:     stream 00 00 00 46      ?
60:     long 0                  ?
64:     long $pps_ts1s          !  timestamp 1 : &quot;seconds&quot;
68:     long $pps_ts1d          !  timestamp 1 : &quot;days&quot;
74:     long $pps_sb            !  starting block of property
78:     long $pps_size          !  size of property
7c:     long                    ?
</pre>

<H2>Решение:</H2>

<P><I>Упражнение 1:</I>

    Найдите цепочку    блоков,    принадлежащих     переменной $sbd_startblock

<P><I>Решение:</I>
    <P>Значение находится   в   позиции   0х3С   заголовка.   Это
0х00000002 == 2. Значение вхождения в Хранилище Больших Блоков
в  позиции  2 - это 0хFFFFFFFE,  что означает:  конец цепочки.
Таким образом, sbd состоит только из большого блока 2.

<hr>
<p>
Перевод: (с) Constantin E. Climentieff aka DrMad,<br>
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> *
<a href="http://www.chat.ru/~drmad">http://www.chat.ru/~drmad</a>
</p>


    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

