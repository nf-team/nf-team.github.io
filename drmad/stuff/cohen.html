<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<title="Фред Коэн. Компьютерные вирусы: теория и эксперимент. (Первый и пока единственный перевод в Рунете!)">
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Courier; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>    
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
    
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
    
<table bgcolor="teal" width="100%"><tr><td>
<center>
<font face="" size="+2" color="White">КОМПЬЮТЕРНЫЕ ВИРУСЫ: ТЕОРИЯ И ЭКСПЕРИМЕНТЫ</font><br>
<font face="" size="+1" color="White">by Фред Коэн, 1984
</font>
</center>
</td></tr></table>                          


                          <center><h3>ВВЕДЕНИЕ И РЕФЕРАТ</h3></center>

<p>  Эта работа определяет проблему компьютерной безопасности, называемую
"вирусом".  Вирусы  интересны  из-за своей способности присоединять себя к
другим программам и превращать их в такие же вирусы.  Существуют  два  способа
написания этого термина:  "вируссы"  и  "вирусы".  Мы будем использовать тот способ,  который
можно найти в Вебстеровском 3-м Международном Полном Словаре.  С учетом
нынешнего  широкого  распространения  разделения доступа к компьютерным
системам,  значительна угроза вируса,  несущего в себе троянского коня [Anderson72]
[Linde75].   Хотя  с точки зрения политики  защиты  от  незаконного
распространения информации  существенная  часть  работы  уже  выполнена
[Bell73]  [Denning82],  и  для  множества систем осуществлена защита от
подобных атак [McCauley79] [Popek79] [Gold79]  [Landwehr83], но все-таки
в области предотвращения попадания информации в те сферы, где она может 
быть повреждена [Lampson73] [Biba77], сделано не так много. Существует
множество  путей  распространения информации между системами,  часть из
которых легальна и безопасна,  но не извесьно [Lampson73],  насколько
часто  пользователи  применяют обходные пути.  В этой
статье рассматривать подобные пути распространения информации мы не будем.</p>

    <p>Существуют общие подходы для обеспечения доказуемо  правильных схем
защиты [Feiertag79],  но они зависят от политики безопасности,  которая
эффективна лишь против конкретных типов атаки.  Даже для очень  простых
систем  защит невозможно доказать их безопасность [Harrison76].  Защита
от угроз типа "отказ в обслуживании"  требует  умения обнаруживать потенциально "сбоящие" 
программы, что, как хорошо известно, в общем случае невозможно
[Garey79].  Показано,  что проблема точного  выделения  информационного
потока в пределах системы [Fenton73] NP-полна. <a href="#m2">(*2*)</a> Использование защиты от
распространения не  заслуживающей  доверия  информации  [Woodward79]  между
пользователями неплохо изучена, но в общем случае решение этой задачи зависит от
способности  доказывать  правильность  программы,   что,   как   хорошо
известно, тоже обладает свойством NP-полноты.</p>

<p> Программа "червь  Xerox"  [Shoch82]  продемонстрировала способность
распространяться через сеть  и даже случайно вызвала  ситуацию  отказа в
обслуживании.  Другая разработанная игра, "войны в памяти" (core wars),
[Dewdney84] предусматривала сражение друг  с  другом двух программ.  
Множеством различных корреспондентов неофициально сообщались
и другие  примеры  на  эту  же тему,  но они по  большей  части  могут
рассматриваться  лишь в  контексте  ночных програмистских забав.  Термин
"вирус" также используется в связи с программированием на языке  на APL, и
относится к ситуации, когда  автор вставляет общий вызов в начале каждой функции,  
что в свою очередь заставляет препроцессор бесконечно размножать  фрагменты 
текста [Gunn74].</p>

<p> Проблема потенциальнах    угроз    безопасности   неплохо   изучена
[Hoffman82],  причем показано, что потенциальный ущерб  для  государственных,  финансовых,
деловых  и  академических учреждений крайне велик.  Следует отметить,
что эти учреждения стремятся использовать конкретные механизмы защиты в
ответ  на  конкретные  угрозы,  а не злоупотреблять теорией [Kaplan82].
Защищенность современных военных систем зависит в  большой  степени  от
изоляционизма, хотя  новые  системы допускают и многоуровневое
использование [Klein83].  Тем не менее, ни одна из опубликованных предлагаемых систем
не  определяет  и  не  осуществляет  такую  политику,  которая могла бы
остановить вирус.</p>

<p>    В этой  статье  мы  поднимаем новую проблему - защиты от компьютерных
вирусов.  В ней изучаются свойства  вирусной  инфекции  и демонстрируется,  что
последовательное   закрытие  доступа к разделяемой  информации  не  препятствует
заражению.  Будучи использованы совместно с Троянским конем,  вирусы могли  бы
вызвать массовые отказы в обслуживании и/или несанкционированный доступ
к данным.  Результаты нескольких экспериментов с компьютерными вирусами
показали,  что  вирусы являются серьезной
угрозой как для обычных, так и для хорошо защищенных операционных систем.
Пути  разделения  и  передачи информации  (т.е., в
общем случае,  все пути обработки информации) являются ключевыми сущностями
в проблеме защиты от компьютерных вирусов,  и это продемонстрировано в статье в результате
последовательного,  случай за случаем,  анализа. Показано, что
единственные  системы  с  потенциалом  защиты  от  вирусной атаки - это
системы с ограниченной транзитивностью и с ограничениями  на разделение
доступа,  системы  вообще  без разделения доступа,  и системы вообще не
обрабатывающие информацию  (варианты  машины  Тьюринга).  <a href="#m1">(*1*)</a>  Только
первый  случай представляет собой практический интерес для современного общества.
Показано,  что  в  общем  случае  проблема обнаружения  вируса  неразрешима  как
a-приори,  так  и  в  процессе анализа,  а без этого излечение
будет затруднено или невозможно.</p>

<p>    В статье предложены и   рассмотрены  несколько  конкретных  контрмер,  и  на
конкретных примерах изучаются свойства вирусов.  Системы с  ограничениями
транзитивности  считаются многообещающими, но показано,  что полноценная их
реализация невозможна, а использование частичных ограничений в общем случае могут привести к более или
менее  пригодным системам.  Изучено использование вирусных антител,  и
показано,  что результат их применения в общем случае  зависит  от  решения
проблемы излечимости.</p>

<p>    Получен вывод,   что  исследование  компьютерных  вирусов  является
важной    научно-исследовательской   задачей, касающейся многих
смежных сфер;  что существующие системы предлагают
плохую или вообще не  предлагают никакой защиты  от  вирусной  атаки,  и  что
единственная доказуемо эффективная политика безопасности - это изоляционизм.</p>

                         <center><h3> КОМПЬЮТЕРНЫЙ ВИРУС</h3></center>

<p>    Мы определяем  компьютерный  вирус  как  программу,  которая способна
заражать другие программы, модифицируя их таким образом, что внедряет
в них собственную,  возможно видоизмененную,  копию.  Обладая свойством
инфицирования, вирус может распространиться по компьютерной системе или
сети,  используя права доступа каждого пользователя, чтобы  заражать  их
программы.   Каждая   зараженная   программа   программа   может  также
действовать как вирус и, таким образом, инфекция распространяется.</p>

<p>    Следующая псевдо-программа  показывает,  как  на   псевдо-машинном   языке
можно было бы написать такой вирус.  Символ  ":="  использован  в качестве
определения, символ ":" означает утверждение, ";" разделяет утверждения,
символ  "="  использован  для  присвоения  или  сравнения,  символ  "~"
представляет собой отрицание, символы "{" и "}" группируют последовательности
операторов  вместе,  а символ "..." использован для указания на пропуск
неактуальных фрагментов программы. </p>

<pre>program virus:=
 {1234567;

subroutine infect-executable:=
 {
 loop:file = get-random-executable-file;
 if first-line-of-file = 1234567 then goto loop;
 prepend virus to file;
 }

subroutine do-damage:=
 {
  whatever damage is to be done
 }

subroutine trigger-pulled:=
 {
 return true if some condition holds
 }

main-program:=
 {
 infect-executable;
 if trigger-pulled then do-damage;
 goto next;
 }

next:
}
</pre>


                           <center><h3>Простой Вирус "V"</h3></center>

<p>    Этот демонстрационный вирус (V) ищет  "здоровый"  выполняемый  файл
программы (E), выбирая файлы без строки "1234567" в начале, и добавляет V к E,
превращая эту программу в  зараженный  файл  (I).  Затем  вирус V  проверяет,
выполняется   ли   определенное  условие,  и  если  да,  то  производит
некие разрушения.  Наконец,  V выполняет остальную часть программы, к которой
он был добавлен.  Когда пользователь пытается выполнить программу E, то
вместо этого выполняется программа I; она заражает другой файл, а потом
работает,  как будто бы она и есть E.  За исключением маленькой задержки,
вызванной  фрагментом  инфицирования,  работа программы   I   выглядит   в точности как
работа программы E, пока не сработает "зловредное" условие.</p>

<p>    Основной недостаток  подобных вирусов заключается в следующем.  Программные черви,
компьютерные игры типа "война в памяти" (Core War) и другие аналогичные программы имитируют  жизнь,  но  ни
одна  из них не инфицирует никого по настоящему.  Ключевой особенностью вируса
является способность заражать другие программы,  таким образом, осуществляя
транзитивное  замыкание  на множестве пользователей.  <a href="#m3">(*3*)</a>  Так
например,  если бы V заразил один из  модулей  (E) пользователя  A,  а
пользователь B после этого запустил бы программу E,  то вирус V мог бы распространиться
также и на файлы пользователя B.</p>

<p>    Надо отметить,  что вирус не обязательно может  использоваться  для
злономеренных целей или не обязательно должен быть Троянским конем. Так
например,  вполне можно написать сжимающий вирус,  предназначенный для
нахождения  ранеее  неинфицированных  модулей,  сжатия их  с  разрешения
пользователя,  и  добавления  себя  к  ним.  <a href="#m4">(*4*)</a>  Будучи   запущенной,
зараженная  программа "раскрутит" сама себя и выполнится нормально.
Поскольку  такой  вирус  всегда  спрашивает  разрешение,   прежде чем
выполнить  свои  действия,  то это - не Троянский конь,  но поскольку у
него есть свойство инфицирования,  то это - все еще вирус. Исследования
показывают,  что  такой  вирус  мог  бы в типичной системе помочь сэкономить свыше 50%  дискового
пространства.  Уменьшение быстродействия зараженных
программ, вызванное "раскруткой", должно быть незначительным.  Такой
сжимающий вирус мог бы выглядеть следующим образом:</p>

<pre>programme compression-virus:=
{01234567;

the subroutine infects-program:=
 {
 loop:file = get-free-executed-file;
 if first-line-file = 01234567 then goto cycle;
 the file of the compresses;
 add the compression-virus in file;
 }

main-program:=
 {
 if ask-permit, then infect-program;
 extract-rest-this-file in tmpfile;
 start tmpfile;
 }

}</pre>

                         <center><h3>Сжимающий вирус "C"</h3></center>

<p>    Эта программа (C) находит неинфицированную программу  (E),  сжимает
ее  и  добавляет к ней C, создавая таким образом зараженную программу (I).
Она затем "выгружает"  оригинальнную  программу  во  временный  файл  и
запускает ее на исполнение.  Когда программа I начинает работу,  то она ищет и
сжимает  какую-то другую  программу  перед  тем,  как "раскрутить"  и   "выгрузить"
программу   E   во   временный  файл, а потом запустить  ее.  Эффект  должен
распространяться  по  всей  системе,   сжимая   выполняемые   файлы   и
востанавливая их перед тем, как они должны быть выполнены. Пользователи
почувствуют небольшие задержки в то время,  как их  модули  извлекаются
перед выполнением.</p>

<p>    Хотя этот  пример  не слишком положителен,  давайте модифицируем 
программу V, добавив к ней процедуру "переключатель",
который  срабатывает после определенных даты и времени  и 
разрешает выполнение своих, возможно деструктивных, действий в  бесконечном  цикле.  
Учитывая наличие многочисленных информационных связей между системами, можно предположить,  что 
многие из них после этого окажутся неработоспособными.  Ликвидирование ущерба  от  такого  вируса
может потребовать много усилий. Этот вариант вируса проиллюстрирован ниже:</p>
<pre>...

subroutine does-damage:= {cycle: goto cycle;}

subroutine pulled trigger:=
{if year&gt;1984, then return truth otherwise inverse lie;}

...
</pre>
               <center><h3>Смертельный вирус</h3></center>

<p>    В качестве   аналога для   компьютерного   вируса  надо  рассматривать
биологическую  инфекцию,  которая  обладает  100%-ной  заражаемостью,
переносится между существами всякий  раз,  как  они общаются друг с другом,
убивает всех зараженных животных немедленно после определенного момента
времени,  но никак не проявляется до этого срока.  Если между началом
заболевания и его проявлением задержка составляет ровно одну неделю, то, весьма  вероятно, что эпидемия
должна миновать только  несколько удаленных стран,  и при этом уничтожить  большую  часть  современного
человечества. Если компьютерный вирус такого типа мог бы распространяться по
всем компьютерам мира,  то он должен был бы, вероятно, остановить использование
вычислительной  техники  на  значительный период времени и организовать
хаос в нынешних правительственных, финансовых, деловых и образовательных
учреждениях.</p>

                 <center><h3>ПРЕДОТВРАЩЕНИЕ КОМПЬЮТЕРНЫХ ЭПИДЕМИЙ</h3></center>

<p>    Мы представили читателю понятие вируса  и  фактически  определили
концепцию  существования вируса  в системах.  Сея зерна потенциально опустошительной
атаки,  вирусы, тем не менее, очень удобны для разработки и исследования  защитных
механизмов. Далее мы изучим предотвращение компьютерных эпидемий.</p>

                         <center><h3>Основные ограничения</h3></center>

<p>    Для того,  чтобы  пользователи были  способны  передавать друг другу
информацию,  должен  существовать путь,  по которому информация может
распространяться  от  одной системы  к  другой.  Мы  не  будем делать 
никакого  различия  между  пользователем и программой, поскольку программа всегда работает
от имени некоторого пользователя  при  любом использовании компьютера, и кроме того, мы
будем игнорировать скрытый путь распространения информации, выполняемый в  обход  системы
непосредственно  от  пользователя к пользователю.  Для того,  чтобы
использовать  модель  машины  Тьюринга,  мы  должны  учесть,  что  если
информация   может   быть  прочитана  пользователем  для  использования
совместно с машиной Тьюринга,  то она может быть скопирована,  а  копия
может затем рассматриваться как данные на ленте машины Тьюринга.</p>

<p>    Рассматривая универсальную систему, в которой пользователи способны
произвольно  использовать  находящуюся  в  их  владении  информацию,  а также
способны  обеспечивать передачу такой информации другим лицам - кому они
считают  нужным,  нам должно  быть  ясно,  что  способность  распространять
информацию   обладает свойством   транзитивности.   То  есть,  если  существует  путь  от
пользователя А к пользователю B,  и существует  путь  от  пользователя  B  к
пользователю  C,  то имеется  и путь от пользователя А к пользователю C с
вольным или невольным посредничеством пользователя B.</p>

<p>    Наконец, не существует фундаментального различия между  информацией,  которая
может быть использована как данные,  и информацией,  которая может быть
использована как программный код.  Это обстоятельство может быть проиллюстрировано  на
примере транслятора,  который берет исходный текст, редактирует его
как данные,  а потом интерпретирует его как  программу.  Как  результат,
информация   имеет   смысл   только  тогда,  когда  может  подвергаться
интерпретации.</p>

<p>    Как продемонстрировано выше, в системе,  где информация  может  быть  проинтерпретирована  своим
получателем   как   программа,   эта  интерпретация  может  закончиться
инфицированием. Если имеется разделение доступа, то
инфекция может распространиться в результате интерпретации коллективной
информации.  Если нет  ограничения  на  транзитивность  информационного
потока,   то   возможно  транзитивное  замыкание  (transitive  closure)
информационных потоков,  стартующих  из  любых  источников.  Разделение
доступа,    транзитивность    информационных    потоков    и   общность
интерпретации,  таким образом,  позволяют  вирусу  распространяться  на
транзитивно  замкнутое множество информационных потоков,  запускающихся
из любого источника.</p>

<p>    Ясно, что если информация не используется,  то  не  может  быть  и  никакого
ее распространения за пределы разбиения, к которому принадлежит вирус и,  таким
образом, никакая внешняя информация не сможет быть проинтерпретирована,
а  вирус не сможет распространяться за пределы своего подмножества.  Назовем
это термином "изоляционизм".  Подобно этому, система, в которой никакая
программа  не  может  быть  изменена и никакая информация не может быть
использована  для  принятия  решения,  не  может   быть   инфицирована,
поскольку  инфицирование  требует модификации транслируемой информации.
Мы называем такую систему "системой с установившимся  назначением первого
функционального  порядка".  Мы должны отметить,  что реально
полезная в научном или инженерном  смысле  система  потребует  общности
интерпретации, и поэтому изоляционизм неприемлем, если мы хотим выигрывать
в эффективности.  Тем не менее,  в некоторых ситуациях подобные решения проблемы вирусов могут
быть применены.</p>

       <center><h3>Модель разбиений</h3></center>

<p>    При распространении   информационного  потока  можно  рассматривать
разбиения,  которые разделяют пользователей на два подмножества:  на тех,
которые включены в транзитивное замыкание; и на тех, которые нет. Можно
сказать,  что разграничители информационных потоков,  которые  обеспечивают  образование
замкнутых подмножеств,  создают изолированные подсистемы.  Они замыкают
каждую инфекцию внутри одного-единственного разбиения.  Они  представляют
собой   жизнеспособные  средства  предотвращения  тотального  вирусного
распространения за счет ограниченного  изоляционизма,  и это эквивалентно
предоставлению каждому разбиению своего собственного компьютера.</p>

<p>    Модель целостности  [Biba77] - пример политики,  которая может быть
использована,  чтобы  разбивать  системы  на   замкнутые   транзитивные
подмножества.   В  модели  Biba  уровень  целостности  связан  со  всей
информацией.  Строгие свойства связности - "двойник"  свойств  политики
Bell-LaPadula;  никакой пользователь с определенным уровнем целостности
не может читать из объекта  с  более  низкой  целостностью  или  записывать
что-либо  в объект с более высокой целостностью.  В оригинальной модели
Biba различие было сделано между чтением и доступом на  исполнение,  но
этот  подход  не  может  не  быть  реализован  с  ограничением общности
информационной интерпретации,  поскольку программа  с  высоким  уровнем
целостности  может писать в объект с низким уровнем целостности,  делая
низкоуровневые собственные копии,  и затем читать и писать в объекты  с
низким уровнем целостности.</p>

<p>    Если модель  целостности и модель Bell-LaPadula сосуществует,  то в
результате получается форма ограниченного изоляционизма,  которая разбивает
пространство на транзитивно замкнутые подмножества. Если одни и те же
способы разбиения используются для  обоих  механизмов  (более  высокая
целостность   позволяет  писать  в  объекты  с  более  высоким  уровнем
безопасности), то изоляционизм приводит к перемещениям информации между
уровнями  безопасности и целостности,  а это недопустимо.  Когда модель
Biba  рассматривает   ограничения   в   пределах   ограничений   модели
Bell-LaPadula, то инфекция может распространиться только с более высоких
уровней целостности на более низкие, оставаясь в пределах одного уровня
безопасности.  Наконец,  когда  ограничения  Bell-LaPadula  находятся в
пределах ограничений Biba, то инфекция может распространиться только от
более  низких  уровней  безопасности к более высоким в пределах данного
уровня  целостности.  Всего  существует  9  вариантов,  относящихся  ко
всяческим соответствиям более низких ограничений более высоким, но три,
изображенных ниже, достаточны для понимания.</p>

<pre>Одинаковые     Biba в B-L.    B-L в Biba.
-------------- -------------- --------------
Biba B-L  Итог Biba B-L  Итог Biba B-L  Итог
---- ---- ---- ---- ---- ---- ---- ---- ----
|\\| |//| |XX| |\\| |//| |XX| |\\| |//| |XX|
|\\| |//| |XX| |\\| |  | |\\| |  | |//| |//|
|  |+|  |=|  | |  |+|  |=|  | |  |+|  |=|  |
|//| |\\| |XX| |//| |  | |//| |  | |\\| |\\|
|//| |\\| |XX| |//| |\\| |XX| |//| |\\| |XX|
---- ---- ---- ---- ---- ---- ---- ---- ----
\\ = не может писать; // = не может читать
XX = нет доступа; \ + / = X</pre>

<p>    Работа Biba  также  содержала  две  других  политики   целостности,
политику  "нижней водяной метки" (low water mark),  которая предусматривает для
выхода всегда более низкую целостность по сравнению с любым  входом;  и
"кольцевую" политику,  в которой пользователи не могут запускать на исполнение то, что
они  могут  прочитать.  Первая из них  стремится   перемещать   всю
информацию на более низкие уровни целостности, тогда как вторая при  помощи  универсальной
информационной интерпретации пытается различать, что  может, а что не  может  быть  выполнено.</p>

<p>    Подобно тому,  как  системы,  основанные  на  модели Bell-LaPadula,
заставляют информацию стремиться к перемещению на более высокие
уровни  безопасности,  постоянно  увеличивая  уровень с целью добраться до
пользователя самого верхнего уровня,  в то же время модель Biba стремится  перемещать
всю  информацию  на  более  низкие уровни целостности,  всегда уменьшая
целостность результатов до самой низкой доступной целостности. Мы также
знаем,  что  точное  решение проблемы системной целостности - NP-полно
(подобно тому, как ее "двойник" - NP-неполная). <a href="#m2">(*2*)</a></p>

<p>    Наиболее благонадежный программист - (по  определению) программист,
который может писать программы для большинства пользователей. Для того,
чтобы поддерживать политику Bell-LaPadula, высокоуровневые программисты
не   могут   писать   программы,   используемые  более  низкоуровневыми
пользователями.  Это означает,  что наиболее благонадежные программисты
должны  находиться  на  самом  низком уровне безопасности.  Это кажется
противоречивым.  Когда мы смешиваем модели Biba и Bell-LaPadula,  то мы
приходим к выводу, что результирующий изоляционизм защищает нас от вирусов, но не
разрешает пользователю писать программы,  которые могли бы использованы
для  всей  системы.  Подобно  тому,  как  мы  допускаем  шифрование или
расшифровывание данных,  чтобы перемещать их с  более  высоких  уровней
безопасности  на  более  низкие,  мы  должны быть способны использовать
тестирование и верификацию  программ,  чтобы  перемещать  их  с  низких
уровней целостности на более высокие.</p>

<p>    Другой часто  используемой политикой разбиения системы на закрытые
подмножества  является  политика  категорий, подобие которой широко используется в армии.  
Эта политика разделяет пользователей на категории,
и  каждый  пользователь  может  иметь  доступ  только   к   информации,
необходимой   для   выполнения  его прямых   обязанностей.   Если   каждый
пользователь в строгой системе категорий имеет доступ  только  к  одной
категории,  то  система  будет  устойчива  к вирусной атаке,  поскольку
категории изолированы.  К несчастью,  в реальных системах  пользователи
могут иметь одновременный доступ к нескольким категориям. В этом случае
инфекция  может  распространяться  через  границы  категории   на   все
транзитивное замыкание информационного потока.</p>

           <center><h3>Потоковые модели</h3></center>

<p>    В политиках,  которые не разделяют системы на транзитивно замкнутые
подмножества, тоже возможно ограничить распространение вируса. Политика
"дистанции   потока"  реализует  метрику  расстояния  для  слежения  за
расстоянием (за "удаленностью" границ),  которое преодалевает  информация.
Правила:  расстояние, на которое позволено удаляться выходной информации, 
является максимумом расстояний входной информации;  расстояние разделяемой  
информации  -  на  единицу больше,  чем  расстояние  той  же  самой  информации 
перед разделением.
Защита обеспечивается  установкой  порога удаленности,  при  превышении   которого
информация становится непригодной. Таким образом, файл с расстоянием 8,
доступный процессу с расстоянием 2,  увеличивает расстояние процесса до
9,  и весь последующий вывод будет характеризоваться, по крайней мере,
этим новым расстоянием.</p>

<p>    В качестве  примера  рассмотрим  поток, рассматривающий информацию  в
соответствии  с  метрической  системой  расстояний и порогом 1,  причем
каждый пользователь (A-E) способен  связаться  только  с  2  ближайшими
соседями.  Обратите внимание,  что информация,  порождаемая в C,  может
переместиться только к пользователю B или к пользователю D, но не может
транзитом перейти к A или E, даже через посредство B и D.</p>

<p>Правила:</p>

<p>  D(выход) = max(D(вход))<br>
  D(разделяемый вход)=1+D(неразделяемый вход)<br>
  Информация доступна, тогда и только тогда, если D &lt; const</p>

 <pre> A     B     C     D     E
 +-+   +-+   +-+   +-+   +-+
 |X|---|1|---|0|---|1|---|X|
 +-+   +-+   +-+   +-+   +-+</pre>

<p>Метрика с Порогом 1.</p>

<p>    Политика "список потоков" поддерживает список  всех  пользователей,
которые взаимодействуют с каждым объектом.  Вот правило, которые нужно,
чтобы  поддерживать  эту политику:  список  выходных  потоков  является
объединением списков потоков всех входов (включая пользователя, который
порождает  это  действие).  Защита  приобретает   форму   произвольного
логического   выражения   для   списков   потоков,   которое   определяет
доступность. Это - весьма общая политика, и она может быть использована,
чтобы   реализовывать любую   из   вышерассмотренных   политик,   посредством выбора
соответствующих логических выражений.</p>

<p>  На следующем рисунке изображен пример   системы,   использующей
списки  потоков и применяющей различные ограничения (упомянутые как A и
B) для разных пользователей (в  строке, колонке  1,3  и  2,5).  Обратите
внимание, что хотя информации позволено распространяться до 1,5, она не
может действительно оказаться там, поскольку нет пути из ее источника в
1,3.   Так   как   в   метрической  системе  расстояний  транзитивность
информационного потока не сохраняется, так что даже если бы информация,
помеченная как B, была бы способна достичь 2,3, она все равно не смогла
бы распространиться дальше.</p>

<p>Правила:</p>

<p>  F(выход)=Объединение(F(входы))<br>
Информация доступна тогда и только тогда, если B(F)=1</p>

<pre>   1     2     3     4     5     6
  +-+   +-+   +-+   +-+   +-+   +-+
1 |A|---|A|---|A|---| |---|A|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+
   |     |     |     |     |     |
  +-+   +-+   +-+   +-+   +-+   +-+
2 | |---| |---| |---| |---|B|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+
   |     |     |     |     |     |
  +-+   +-+   +-+   +-+   +-+   +-+
3 |B|---|B|---|B|---|B|---|B|---|B|
  +-+   +-+   +-+   +-+   +-+   +-+</pre>

<center><h3>Пример системы, основанной на списках потоков</h3></center>

<p>    Рассматриваемый пример   использует   довольно  простую  логическую
функцию, но в целом, доступность может быть определена при помощи очень
сложных условий.  Например,  пользователю могло бы быть позволено иметь
доступ только к информации,  созданной парами пользователей (B и C) или
(B и D),  но запрещено к той, которая создана пользователями
B, C, или D по отдельности.</p>

<p>    Это может быть использовано, чтобы осуществлять проверку доступности к информации
в B прежде,  чем C или D могут переслать ее на A. Система списков потоков
может также быть использована, чтобы реализовывать модели Biba и модели
расстояний. Например, модель расстояний может реализовываться следующим
образом:    @центр[ИЛИ    (пользователи    &lt;=    расстояние    1)     И
НЕ(ИЛИ(пользователи &gt; расстояние 1))].</p>

<p>    В системе  с  неограниченными  информационными  путями ограниченная
транзитивность может быть эффективной,  если пользователи не используют
все  доступные  пути,  но всегда имеется прямой путь между любыми двумя
пользователями,  и в этом случае всегда сохраняется  возможность  инфицирования.
Например,  в  системе  с  транзитивностью,  ограниченной расстоянием 1,
безопасно разделять информацию между любыми пользователями,  которым вы
доверяете,  без  необходимости беспокоиться о том,  что какой-нибудь из
этих пользователей неправомерно доверяет другому пользователю.</p>

<center><h3>Ограниченная интерпретация</h3></center>

<p>Ограничения общности  интерпретации   менее   ограничительны,   чем
фиксированная интерпретация  первого  порядка,  и  в этом случае способность заражать
остается  открытым  вопросом,  поскольку   инфицирование   зависит   от
разрешенных функций. Для инфицирования необходимы определенные функции.
Для этого требуется способность к записи,  но  ведь  и  любая  полезная
программа  должна уметь продуцировать выходные данные.  Возможно,  надо
определить набор операций,  которые не допускают инфицирования  даже  в
общем случае разделения и транзитивности,  но неизвестно, действительно
ли  такой набор включает не фиксированные функции первого порядка.</p>

<p>    Например, система с единственной  функцией  "показать  файл"  может
только   отображать   содержимое   файла   пользователю,   и  не  может
модифицировать никакие файлы.  В фиксированной базе данных или почтовой
системе это может найти практическое применение, но ни в коем случае не
в среде разработки.  Во многих случаях электронная почта -  достаточное
средство  связи,  и  пока  система  электронной почты связана с другими
приложениями так,  что никакая информация не может быть передана  между
ними,    за   исключением   скрытого   канала   непосредственно   через
пользователя,  такая схема может быть использована, чтобы защищаться от
инфекции.</p>

<p>    Хотя никакая  фиксированная  схема  интерпретации не может заразить
сама себя,  схема  интерпретации  более  высоких  порядков  может  быть
использована, чтобы заражать программы, интерепретируемые в этой схеме.
Например, компьютерный микрокод может быть фиксирован, но машинный код,
который  интерпретируется  этим микрокодом, обладает способностью инфицировать.  LISP,
APL,  и Basic - вот примеры фиксированных схем  интерпретации,  которые
могут   интерпретировать   любую   информацию.   С  их  способностью  к
интерпретации в общем возможно написать  программу  на  любом  из  этих
языков,  которая  заражала бы программы на любом другом из них,  или на
всех сразу.</p>

<p>    В системах  с  ограниченной  интерпретацией   инфекции   не   могут
распространяться  дальше,  чем  в универсальных системах интерпретации,
поскольку  каждая  функция  ограниченной  системы  должна  также   быть
способна  выполняться  в универсальной системе.  Предыдущие результаты,
следовательно, позволяют оценить верхние границы распространения вируса
в системах с ограниченной интерпретацией.</p>

                          <center><h3>Проблемы точности</h3></center>

<p>    Хотя изоляционизм  и ограниченная транзитивность предлагают решение
проблемы инфицирования,  они не идеальны в том смысле,  что разделение
ресурсов и данных обычно считается полезным свойством.  Из этих политик
только изоляционизм может быть точно осуществлен на практике, поскольку
трассировка  информационных  потоков  потребовала  бы  NP-полных затрат
времени,  а маркировка  потребовала  бы  слишком много  рабочего  пространства
[Denning82]. Это оставляет нам возможность использовать только неточные
методы.  Проблема неточных методов в том,  что они стремятся  приводить
системы к изоляционизму.  Дело в том, что они используют консервативную
оценку эффектов для предотвращения потенциального ущерба. В философском
смысле лучше быть безопасным, чем разочарованным.</p>

<p>    Проблема в том, что когда информация несправедливо рассматривается,
как  недоступная  для  чтения  конкретным  пользователем,  то   система
становится менее пригодной для этого пользователя. Это - форма отказа в
обслуживании в процессе доступа к информации,  к который доступ, на самом деле, не должен
быть запрещен. Такая система всегда стремится делать себя менее и менее
пригодной для разделения ресурсов и данных  вплоть  до  того,  что  или
становится полностью изолированной, или достигает точки равновесия, где
все оценки точны. Если такая точка равновесия существовала бы, то у нас
была  бы точная система в этой точке равновесия.  Поскольку мы знаем,
что любая точная точка равновесия означает изоляционизм, то требуется
решение   NP-полной  проблемы,  а  любое  не-NP-полное  решение  должно
приводить к изоляционизму.</p>

                           <center><h3>Итоги и выводы</h3></center>

<p>    Следующая таблица  суммирует пределы,    установленные    для
распространения  вирусов только что изученными методами защиты.  Термин
"неизвестно" использован для указания того,  что  особенности  конкрентных
систем известны,  и нет никакой теории,  чтобы предсказать ограничения
для этих категорий.</p>
<pre>
                     Пределы вирусного инфицирования

          Общая интерпретация         Ограниченная интерпретацию

           огранич.     общ.               огранич.      общ.

--------|-----------|-----------|       |-----------|-----------|
 общ.   |неогранич. | неогранич.|       |неизвестно |неизвестно |
--------|-----------|-----------|       |-----------|-----------|
огранич.|произвольн.| замыкание |       |произвольн.| замыкание |
--------|-----------|-----------|       |-----------|-----------|

 </pre>  

                          <center><h3>ИЗЛЕЧЕНИЕ ОТ КОМПЬЮТЕРНЫХ ВИРУСОВ</h3></center>

<p>    Поскольку предотвращение   компьютерных   вирусов    может    стать
необходимым  в  условиях  обширного  разделения  доступа  к программным
объектам, то биологическая аналогия приводит нас к возможности лечения,
как  средства  защиты.  Лечение  в  биологических  системах  зависит от
способности обнаружить вирус и возможности уничтожить  его.  Аналогично
дело обстоит и для компьютерных вирусов.  Здесь мы изучим потенциальные
возможности по обнаружению и удалению компьютерных вирусов.</p>

                          <center><h3>Обнаружение вирусов</h3></center>

<p>    Для того,  чтобы  определять,  что  данная  программа  P   является
вирусом,  необходимо установить,  что P заражает другие программы.  Это
неразрешимо,  поскольку P могла бы бы содержать решающую процедуру D  и
заражать  другие  программы  тогда  и  только тогда,  когда D придет к
выводу,  что P -  не  вирус.  Мы  будем  считать,  что  нам  необходима
программа,  которая  однозначно  различает  вирус  внутри  любой другой
программы,  изучая ее поведение. Чтобы продемонстрировать невозможность
существования   таких   программ,   в   следующем   примере   с   целью
запрограммировать V, мы используем гипотетическую решающую процедуру D,
которая  возвращает  "истину"  тогда и только тогда,  когда ее аргумент
является вирусом,</p>
<pre>
program contradictory-virus:=

{...

main-program:=

 {if ~D(contradictory-virus) then
    {infect-executable;
    if trigger-pulled then do-damage;
    }

 goto next;

 }
}
</pre>
                      <center><h3>Неоднозначность вируса "CV"</h3></center>

<p>    Модифицируя основную  программу  V,  мы  гарантировали,  что   если
процедура  D  проверяет  CV  на  соответствие  вирусу,  то  CV не будет
заражать другие программы и,  таким образом, не будет являться вирусом.
Если  же D определяет,  что CV - не вирус,  то CV будет заражать другие
программы   и,   таким   образом,   будет    вирусом.    Следовательно,
гипотетическая   решающая   процедура  D  противоречит  самой  себе,  и
однозначное определение понятия "вирус" невозможно.</p>

                            <center><h3>Эволюция вируса</h3></center>

<p>В наших экспериментах некоторые вирусы требовали менее  4000 байтов
для  выполнения  на  универсальном  компьютере.  Поскольку  мы могли бы
написать программу,  которая чередует  свою  деятельность:  то  она  не
останавливается,   то  завершается  в  течение  конечного  времени;  то
работает как вирус,  то безобидна,  -  в  общем,  количество  возможных
модификаций  одного  такого  вируса  может  быть очень большим.  В этом
примере эволюционирующего вируса EV мы допускаем  модификацию  V  таким
образом,   что  случайные  инструкции  вставляются  между  любыми  двумя
обязательными инструкциями. <a href="#m6">(*6*)</a></p>

<pre>program evolutionary-virus:=

{...

subroutine print-random-statement:=

 {
 print random-variable-name, " = ", random-variable-name;
 loop:if random-bit = 0 then
    {print random-operator, random-variable-name;
    goto loop;}
 print semicolon;
 }

subroutine copy-virus-with-random-insertions:=

 {
 loop: copy evolutionary-virus to virus till semicolon-found;
 if random-bit = 1 then print-random-statement;
 if ~end-of-input-file goto loop;
 }

main-program:=

 {
 copy-virus-with-random-insertions;
 infect-executable;
 if trigger-pulled do-damage;
 goto next;
 }

next:
}
</pre>
                      <center><h3>Эволюционирующий Вирус "EV"</h3></center>

<p>    В общем,  доказательство эквивалентности двух модификаций  одной  и
той  же программы P (пусть это P1 и P2) невозможно,  поскольку любая решающая
процедура  D,  способная  обнаруживать   их   эквивалентность,   должна
ознакомиться   и   с   P1,  и  с  P2.  Если  с  ее  помощью  обнаружена
эквивалентность,  то они будут выполнять  различные  действия;  а  если
обнаруживается  различие,  то они будут действовать одинаково,  и таким
образом  опять   станут  эквивалентными.   Это   поясняется   следующей
модификацией  программы  EV,  в которой решающая процедура D возвращает
"истину" тогда и только тогда,  когда две  программы,  поданные  на  ее
вход, эквиалентны.</p>

<pre>program undecidable-evolutionary-virus:=

{...

subroutine copy-with-undecidable-assertion:=

 {
 copy undecidable-evolutionary-virus to file till line-starts-with-zzz;
 if file = P1 then print "if D(P1,P2) then print 1;";
 if file = P2 then print "if D(P1,P2) then print 0;";
 copy undecidable-evolutionary-virus to file till end-of-input-file;
 }

main-program:=

 {
 if random-bit = 0 then file = P1 otherwise file = P2;
 copy-with-undecidable-assertion;
 zzz:
 infect-executable;
 if trigger-pulled do-damage;
 goto next;
 }

next:
}
</pre>
             <center><h3>Невозможность доказательства эквивалентности
                       модификаций вируса "UEV".</h3></center>

<p>    Программа UEV "перерождется" в один из двух типов программ:  P1 или
P2. Если тип программы равен P1, то значение "zzz" станет:</p>

  <pre>  if D(P1,P2) then print 1;</pre>

<p>в то же время, если программный тип есть P2, то "zzz" примет вид:</p>

   <pre> if D(P1,P2) then print 0.</pre>

<p>    На обе модификации "напустим"  решающую  процедуру  D,  чтобы   решить,
действительно   ли   они   эквиалентны?   Если  D  сочтет,  что  они  -
эквивалентны,  тогда P1 напечатает 1,  тогда как P2 напечатает 0,  и  D
будет противоречить самой себе.  Если D укажет, что они различны, то не
будет напечатано ничего. Пока они эквивалентны, D будет противоречивой.
Следовательно,  гипотетическая  решающая  процедура  D  противоречива в
своей основе, и точное определение эквивалентности этих двух программ -
невозможно.</p>

<p>    Если P1  и  P2 - модификации одной и той же программы,  то проблема
доказательства их эквивалентности неразрешима,  и если они обе являются
вирусами,  то неразрешимо и доказательство их вирусности. Программа UEV
также демонстрирует,  что две  различные  модификации  могут  обе  быть
вирусами. Модификации являются эквивалентами с точки зрения их вирусных
эффектов, но могут иметь разные проявления.</p>

<p>    Альтернатива обнаружению по внешнему  виду  -  это  обнаружение  по
поведению.   Вирус,   будучи   внедрен   в   программу,  имитирует  для
пользователя выполнение запрошенных пользователем системных сервисов, в
то  время  как  сам он при этом по всем правилам пользуется законными сервисами.
Вследствие этого вопрос обнаружения по поведению сводится к возможности
определить,  какое использование системных сервисов законно,  а какое -
нет, и только это позволит отличить вирус от "невируса".</p>

<p>    Пример "законного" вируса - компилятор,  который  компилирует  свою
новую  версию,  и  фактически  является вирусом в соответствии с данным
выше определением.  Он в эом случае - тоже программа,  которая заражает
другую  программу,  модифицируя ее таким образом,  чтобы включить в нее
возможно видоизмененную версию себя.  Поскольку  свойство  "вирусности"
принадлежит   большинству   компиляторов,   то   каждое   использование
компилятора является потенциальной вирусной атакой. Вирусная активность
компилятора  может быть отключена или возобновлена конкретными входными
данными,  и,  таким образом для того,  чтобы обнаружить  эту  ситуацию,
нужно  быть  способным  обнаруживать вирус по внешнему виду.  Поскольку
однозначное  обнаружение  по  поведению  в  этом  случае   зависит   от
однозначного обнаружения содержимого входных данных, и поскольку мы уже
показали,  что обнаружение по внешнему виду неоднозначно,  то из  этого
следует, что точное обнаружение по поведению также невозможно.</p>

                     <center><h3>Ограниченная вирусная защита</h3></center>

<p>    Ограниченная форма   вируса   разработана   [Thompson84]   в  форме
специальной версии компилятора с языка C,  который может  обнаруживать,
что  на входе у него имеется исходный текст программы проверки паролей,
и добавлять  Троянского  коня,  который  обеспечивает  автору  обход
проверки. Таким образом, автор мог бы иметь доступ к любой Unix-системе,
снабженной этим компилятором. Кроме того, компилятор может обнаруживать
компиляцию  новых  версий  самого  себя  и заражать их тем же Троянским
конем.  Действительно ли такой вирус существует, неизвестно (хотя ходят
слухи,   что  Агентство  Национальной  Безопасности  имеет  ее  рабочую
версию).</p>

<p>    Как контрмеру,   мы  можем  разработать  новую  программу  проверки
паролей (и компилятор с языка C),  достаточно отличные от первоначальных, чтобы
определить  их  эквивалентность  было очень трудно.   Если "лучший
искусственный интеллект" не способен обнаружить их  эквивалентность  на
текущий  момент времени,  и компилятор выполняет свою задачу достаточно
быстро,  то было бы разумным предоложить,  что  вирус  тоже  не  сможет
обнаружить  эквивалентность,  и следовательно,  не сможет размножаться.
Если точный способ обнаружения известен, то, вероятно, это будет совсем
просто сделать.</p>

<p>    Хотя мы  показали,  что  в   общем   случае   обнаруживать   вирусы
невозможно,  на  самом деле, любой конкретный вирус может быть обнаружен
конкретной схемой обнаружения.  Например,  вирус V мог  бы  быть  легко
обнаружен детекторами по первой строке программы "1234567". Если
окажется,  что  программа  заражена,  то она   не   будет   запущена,   и,
следовательно,  не  сможет размножиться.  Следующая программа может
быть использована вместо обычного системного загрузчика,  и  она  будет
отказываться выполнять программы, зараженные вирусом V:</p>

<pre>program new-run-command:=

{
 file = name-of-program-to-be-executed;
 if first-line-of-file = 1234567 then
 {
 print "the program has a virus";
 exit;
 }

otherwise run file;

}</pre>

                         <center><h3>Защита от вируса "PV"</h3></center>

<p>    Аналогично, любая  конкретная схема обнаружения может быть обойдена
конкретным  вирусом.  Так  например,  если  нападающий  знал  бы,   что
пользователь  использовал  программу  PV  как защиту от вирусной атаки,
вирус V мог бы легко быть заменен вирусом V',  в котором первая  строка
была  бы "123456" вместо "1234567".  Могут быть изучены и более сложные
вирусы и защитные схемы. Становится совсем очевидной аналогия со старой
поговоркой, пришедшей с Дикого Запада:  "Нет такой лошади, на которую нельзя было бы вскочить, но
и нет такого ковбоя,  которого  нельзя было бы сбросить".  Никакая  инфекция  не  может
существовать   без   того,  чтобы  не  быть  обнаруженой,  и  не  может
существовать никакой механизм обнаружения,  который не мог бы быть  сам
инфицирован.</p>

<p>    Этот результат  приводит  к  идее  того,  что могло бы существовать
равновесие между вирусами и защитами,  так что конкретный вирус мог  бы
поразить  лишь  часть  систем,  тогда  как данная схема защиты могла бы
защищать лишь против  конкретного  подмножества  вирусов.  Если  каждый
пользователь  и  злоумышленник  использовали  бы  идентичные  защиты  и
вирусы,  то существовали бы совершенный  вирус  и  совершенная  защита.
Имело  бы  смысл,  как с точки зрения нападающего,  так и с точки зрения
защищающегося, - иметь набор (возможно неполный) вирусов и защит.</p>

<p>    При условии, что вирусы и схемы защиты не развивались бы, это могло
бы  привести  к  некоторым фиксированным множествам немногих "выживших"
вирусов и защит,  но поскольку программы пишутся, чтобы развиваться, то
выжили   бы   программа,   которую   трудно  атаковать,  и  практически
необнаружимый вирус.  Так как эволюция все-таки происходит,  равновесие
постоянно  нарушается,  и  результат  становится неясным даже при самых
простых обстоятельствах.  Эта ситуация имеет  очень  много  аналогий  в
теориях  биологической  эволюции  [Dawkins78],  и хорошо укладывается в
генетические теории болезней. Аналогично, распространение вирусов между
системами могло бы быть хорошо проанализировано с использованием математических
моделей,   разработанных   для   исследования   инфекционных   болезней
[Baily57].</p>

<p>    Поскольку мы  не  можем однозначно обнаружить вирус,  мы остаемся с
проблемой определения потенциально незаконного использования при помощи
однозначных   и  легко  реализуемых  методов.  Мы  можем  пожелать  для
множества программ способность доказать,  что они не являются вирусами,
и  даже  пропускать  некоторые  вирусы  для  того,  чтобы  обнаруживать
основную массу вирусов.  Если  такое  событие  происходит  сравнительно
редко в "нормальных" условиях, то о нем можно получить достаточно много
информации, и мы можем определить, по какой причине оно произошло. Если
доступно  следящее оборудование,  то могут быть собраны списки потоков,
которые прослеживают всех  пользователей,  обратившихся  к  конкретному
файлу.  Пользователи,  которые  появляются во многих списках,  могли бы
считаться подозрительным.  Присутствие во многих списках могло бы  быть
хорошим указателем на вирус.</p>

<p>    Это средство  моло  бы быть ценным,  если бы сервисы,  используемые
вирусами, редко использовались бы другими программами, но на самом деле
имеется  несколько  проблем.  Если  условия,  при  которых возбуждается
вирусная тревога,  известны нападающему,  то может быть  создан  вирус,
работающий  вне  рамок  этих  условий.  Интеллектуальная следящая схема
могла  бы  приспосабливаться  так,  что  условия  не  моли   бы   легко
определяться  нападающим.  Хотя  эта  "игра" может легко прокручиваться
взад и вперед, частота опасных запросов может оказаться слишком низкой,
чтобы замедлить распространение необнаруженного вируса, не конфликтуя с
законным использованием сервисов.</p>

<p>    Было изучено  несколько  систем  на  наличие  в  них   способностей
обнаруживать  вирусную  атаку.  Удивительно,  но ни одна из этих систем
даже  не  сохраняла  список  программ,  запускающих  другие  программы.
Трассировка  подобного  типа почти несомненно должна быть использована,
если есть необходимость обнаружить даже простейшую вирусную атаку.</p>

<p>    Если вирус  уже  имплантирован,  он  не  может  быть  легко  удален
полностью.   Если   система  продолжает  работать  во  время  удаления,
программа может быть бы инфицирована повторно. Это означает бесконечную
погоню   за   собственным   хвостом.   Без   некоторого  ограничения  в
возможностях,  удаление вероятно  будет  невозможным,  если  программа,
выполняющая  удаление,  медленнее,  чем  процесс размножения удаляемого
вируса.  Даже в случаях,  когда удаление медленнее, чем вирус, возможно
позволять большинству активных процессов выполняться в течение удаления
без опаски еще более замедлить процесс  удаления.  Например,  можно  бы
изолировать пользователя или подмножество пользователей и лечить их, не
запрещая обмен с другими пользователями.</p>

<p>    В общих чертах,  точное удаление зависит  от  точного  обнаружения,
поскольку  без  точного  обнаружения  невозможно  даже  узнать точно,
следует ли удалять  данный  объект.  В  отдельных  случаях  может оказаться
возможным удаление  с  использованием  неточного
алгоритма.  Например,  каждый файл,  созданный после определенной даты,
мог  быть  просто  удален  для  того,  чтобы  уничтожить  любой  вирус,
стартовавший после этой даты.</p>

<p>    Единственное, что смущает, это существование шанса, что вирус может
быть сгенерирован спонтанно. Это сильно связано с вопросом, как долго N
обезьян должны стучать по  N  клавиатурам,  чтобы  написать  вирус  без
посторонней помощи.</p>

                 <center><h3>ЭКСПЕРИМЕНТЫ С КОМПЬЮТЕРНЫМИ ВИРУСАМИ</h3></center>

<p>    Для того,  чтобы продемонстрировать возможности  вирусной  атаки  и
степень угрозы, было выполнено несколько экспериментов. В каждом случае
эксперименты были выполнены с ведома и согласия администраторов систем.
После  выполнения  экспериментов все следы были тщательно аннулированы.
Критически важно,  что эти эксперименты не были основаны на оплошностях
реализации,   но   только   на   фундаментальных   недостатках  политик
безопасности.</p>

                             <center><h3>Первый вирус</h3></center>

<p>    3 ноября 1983 года был представлен эксперимент  с  первым  вирусом,
специально  подготовленный  для  доклада  на  еженедельном  семинаре по
компьютерной  безопасности.  На  этом  семинаре  сначала  автором  была
рассмотрена  концепция,  а  термин "вирус" был предложен Леном Адлеманом
(Len  Adleman).   После  8  часов  экспертной  работы  в   сильно
загруженной  системе VAX 11/750 под управлением Unix,  первый вирус был
завершен и подготовлен для демонстрации. В течение недели было получено
разрешение   на   проведение  экспериментов,  и  5  экспериментов  были
выполнены.  10  ноября  вирус  был  продемонстрирован  на  семинаре  по
безопасности.</p>

<p>    Исходная инфекция была имплантирована в vd,  - в программу, которая
изображает   файловые   структуры   Unix   наглядно   и   предоставляет 
эти сведения пользователям через системный информационный  бюллетень.  Поскольку  vd
была новой программой в системе,  никакие характеристики исполнения или
другие детали известны  не  были.  Вирус  был  имплантирован  в  начало
программы  так,  чтобы  он  исполнялся  перед  выполнением любых других
операций.</p>

<p>    Для того, чтобы держать атаку под контролем, были предприняты несколько
мер предосторожности.  Все инфицирования выполнялись вручную, и никакой
ущерб нанесен  не  был,  только  выводились  сообщения.  Была  включена
трассировка,    чтобы    гарантировать    для    вируса   невозможность
распространяться незаметно,  управление доступом  было  использовано  в
процессе инфицирования,  а код,  необходимый для атаки,  был заключен в
сегментах,  каждый из котрых был закодирован и защищен  таким  образом,
чтобы предотвращать незаконное использование.</p>

<p>    Во время каждой из пяти атак все системные права были предоставлены
нападающему в течение часа.  Самое короткое время было около 5 минут, а
среднее время составляло около 30 минут.  Даже те, кто знали, что атака
будет  происходить,  были  заражены.  В  каждом   случае   файлы   были
подвергнуты  дезинфекции после эксперимента,  чтобы гарантировать,  что
никакая секретность пользователя  не  будет  нарушена.  Ожидалось,  что
атака  будет  иметь  успех,  но  удивительным  было короткое время,  за
которое все это произошло. Кроме того, вирус сам по себе был достаточно
быстрым  (около  1/2  секунды),  так  что  что  задержки  в  выполнении
зараженных программ были незаметны.</p>

<p>    Как только  результаты экспериментов были объявлены, администраторы
извещали,  что  в их системе никакие   дальнейшие   эксперименты   по   компьютерной
безопасности  больше не  должны  проводиться.  Этот
запрет распространялся  даже  на  запланированное  формирование  трасс,
которое позволило бы проследить потенциальные вирусы, и на эксперименты
по  увеличению  длины пароля,  которые   могли   бы   потенциально усилить
безопасность.  Типичной  являлась  именно подобная явная реакция страха,
вместо того,  чтобы решать технические проблемы технически. Также часто
выбирались решения, связанные с ужесточением режима безопасности.</p>

<p>    После того,  как успешные эксперименты  были  выполнены  в  системе
Unix, стало абсолютно ясным, что те же методы должны работать во многих
других системах. Конкретно, эксперименты были запланированы для системы
Tops-20,  системы VMS, системы VM/370, и для сети, содержащий некоторые
эти системы.  В процессе переговоров  с  администраторами,  возможность
была  продемонстрирована посредством разработки прототипов и испытаний.
Атака  прототипа  для  системы   Tops-20   была   разработана   опытным
пользователем Tops-20 в течение 6 часов,  пользователем-новичком VM/370
с    помощью    опытного    программиста    через    30    часов,     и
пользователем-новичком  VMS без посторонней помощи через 20 часов.  Эти
программы демонстрировали способность  находить  файлы,  которые  нужно
заражать, и заражали их, преодалевая пользовательские ограничения.</p>

<p>    После нескольких месяцев согласований и административных пертурбаций,
эксперименты  более не  были  разрешены.  Офицер  безопасности  находился   в
постоянной оппозиции к экспериментам и отказывался рассматривать любые
предложения.  Особенно интересно  то,  что  ему  предложили  пригласить
системных программистов и специалистов по безопасности, чтобы наблюдать
за всеми аспектами экспериментов.  Кроме того, системные администраторы
отказывались   предоставлять   версии  регистрационных  логов,  которые
предполагалось  использовать  для  оффлайнового  анализа  потенциальной
вирусной   унрозы,   и   не   соглашались  добавлять  (силами  тамошних
программистов) дополнительную трассировку  системных  процессов,  чтобы
при их помощи обнаруживать вирусную атаку. Хотя эта работа не выглядела
опасной,  требовала небольших времени,  денег и усилий,  тем  не  менее
администраторы не были склонны разрешать исследования. Оказалось, что их
реакция была такой же, как и реакция страха администраторов систем Unix.</p>

            <center><h3>Системы, основанные на политике Bell-LaPadula</h3></center>

<p>    В марте 1984 г.  начались переговоры по выполнению экспериментов на
системе,  основанной на политике Bell-LaPadula [Bell73] и работавшей на
платформе  Univac  1108.  Эксперимент  был  рассчитан,  в  принципе,   на
несколько   часов,   но   потребовал   нескольких  месяцев  для  своего
завершения.  В июле  1984  г.  был  выделен  двухнедельный  период  для
экспериментирования. Цель этого эксперимента заключалась в демонстрации
возможности вируса поразить систему,  безопасность которой основана  на
политике Bell-LaPadula.</p>

<p>    Из-за чрезвычайно  ограниченного  времени  на  разработку (26 часов
работы пользователя,  который никогда  ранее  не  использовал  1108,  с
помощью  программиста,  который  не  использовал 1108 в течение 5 лет),
множество вопросов реализации  были  проигнорированы.  Конкретно,  были
проигнорированы   вопросы   временной  производительности  атаки  и  ее
масштабов.  В результате,  каждая инфекция требовала около  20  секунд,
хотя  на  самом  деле  это  могло быть легко сделано в течение секунды.
Следы вируса были оставлены в системе, хотя они могли бы быть устранены
в  значительной  степени  с  небольшими  усилиями.  Вместо того,  чтобы
заражать множество файлов сразу,  заражался  только  один  файл.  Такой
подход   допускал   распространение   вируса,  которое  можно  было  бы
обнаружить,  не включая при этом  в  процесс  много  пользователей  или
программ.  Вследствие мер предосторожности, система была использована в
выделенном режиме с только одним системным  диском,  одним  терминалом,
одним принтером,  а учетные записи были предназначены исключительно для
эксперимента.</p>

<p>    После 18-часового сеанса связи вирус для 1108 выполнил  свою первую
инфекцию.   Хост   обеспечил  довольно  полный  набор  пользовательской
документации,  доступ к системе  и  помощь  компетентного  пользователя
системы.  После  26  часов  экспериментов  вирус  был продемонстрирован
группе из 10 людей,  включая администраторов,  программистов и офицеров
безопасности.     Вирус     демонстрировал    способность    пересекать
пользовательские ограничения и  перемещаться  с  более  низкого  уровня
безопасности на более высокий.  Кроме того,  и это должно быть отмечено
особо, в этот процесс не были включены никакие специальные повреждающие
действия, но модель Bell-LaPadula вполне обеспечивала возможность
даже и этого.</p>

<p>    В общем,  выполнить атаку было не трудно. Код для вируса состоял из
5 строк сборочного кода, около 200 строк кода на языке Fortran, и около
50  строк  командных  файлов.  Оценено,  что   компетентный   системный
программист  мог  бы  написать  значительно  лучший вирус примерно за 2
недели.  Кроме того,  как только становится понятной  природа  вирусной
атаки,    легко    разработать   ее   специфический   вариант.   Каждый
присутствующий программист был убежден,  что они мог бы создать  лучший
вирус  за то же время.  (Это похоже на правду,  поскольку нападающий не
имел предварительного опыта работы на 1108).</p>

                             <center><h3>Оборудование</h3></center>

<p>    В начале августа 1984 г. было получено разрешение оснастить систему
VAX Unix средствами,  предназначенными для измерения разделения доступа
и анализа вирусного распространения.  Данные на этот  раз  были  совсем
ограничены,  но  позволили  обратить  внимание  на  новые  направления.
Оказалось,  что степень разделения доступа варьируется  существенно  от
системы  к  системе,  и  для того,  чтобы в этом убедиться,  необходимо
предварительно переоборудовать множество систем.  Небольшое  количество
пользователей  обладают  большими правами по разделению доступа,  можно
было   бы   существенно   ограничить   вирус,   защитив   именно   этих
пользователей. Защита нескольких "особо общительных" индивидуумов могла
бы также замедлить биологические болезни.  Следящее  оборудование  было
консервативным в том смысле,  что инфекция могла бы случиться и без его
участия, так что скорость атаки получилась нереально медленной.</p>

<p>    В результате применения в системе  такого  рода  оборудования  было
определено  множество  "особо  общительных" пользователей.  Присутствие
некоторых из них в этом списке удивило главного администратора системы.
Количество  пользователей  с административными правами оказалось весьма
высоким,  и если любой из них оказывался  заражен,  то  и  вся  система
заражалась  в пределах часа.  Предложенные довольно простые процедурные
изменения замедляли скорость  этой  атаки  на  несколько  порядков,  не
уменьшая при этом функциональных возможностей.</p>

                         <center><h3>Итоги распространения</h3></center>

<pre>         система 1                         система 2

 класс|  ##  |распр.| время|     класс|  ##  |распр.| время|
----------------------------    ----------------------------
|  S  |  3   |  22  |   0  |    |  S  |  5   |  160 |   1  |
|  A  |  1   |   1  |   0  |    |  A  |  7   |   78 | 120  |
|  U  |  4   |   5  |  18  |    |  U  |  7   |   24 | 600  |</pre>

<p>    Рассмотрены две   системы  с  тремя  классами  пользователей  (S  -
система, A - системный администратор, U - пользователь). '##' указывает
количество пользователей в каждой категории, "распр." (распространение)
является средним количеством пользователей,  на  которых  вирус  должен
распространяться,  а "время" является средним временем, использованным,
чтобы заразить их после входа в систему,  округленное в большую сторону
в ближайшую минуту. "Среднее время" вводит в заблуждение, поскольку, как
только  инфекция  достигает   root-а   на   Unix,   то   вирусу   сразу
предоставляется полный доступ.  Если это случается,  то требуется время
порядка одной минуты, поскольку с этого момента ограничивающим фактором
скорости распространения становится собственно время инфицирования. Это
совпадает с  предыдущими  экспериментальными  результатами,  в  которых
использовался реальный вирус.</p>

<p>    Пользователи, которые  не  участвовали  в разделении доступа,  были
проигнорированы в этих подсчетах,  но другие  эксперименты  показывают,
что  любой  пользователь  может участвовать в разделении доступа,  имея
доступ  к  системному  информационному  бюллетеню.   Детальный   анализ
продемонстрировал,  что  системные  администраторы  стремятся пробовать
новые программы,  как  только  они  появляются.  Это  дает  возможность
обычому   пользователю  заразить  системные  файлы  в  течение  минуты.
Системные  администраторы  использовали  свои  учетные  записи  для запуска
программ  других  пользователей и сохранения часто выполняемых системных
файлов,   также   некоторые   обычные    пользователи    имели    часто
использовавшиеся   файлы.  Эти  условия  делают  вирусную  атаку  очень
быстрой.  Было немедленно предложено использование  раздельных  учетных
записей  для системных администраторов в процессе нормальной работы,  а
также систематическое перемещение (после  проверки)  часто  исполняемых
программ в системную область.</p>

                          <center><h3>Другие эксперименты</h3></center>

<p>    Аналогичные эксперименты   были  проведены  в  ряде  систем,  чтобы
продемонстрировать возможность выполнения вирусов во  многих  системах.
Простые  вирусы были написаны для VAX VMS и VAX Unix на соответствующих
командных языках,  и ни одна программа не потребовала для своей  работы
более  10  строк  на  командном  языке.  Вирус  для  Unix  независим от
компьютера  на  котором  он  выполняется,  и,  следовательно,  способен
работать под IDRIS,  VENIX и в других UNIX-системах.  Вирус, написанный
на Бэйсике и состоящий из 100 строк, был реализован для Radio Shack TRS
-80,  IBM PC и нескольких других машин с расширениями языка Basic. Хотя
все это были низкоуровневые  вирусы,  которые  обнаруживаются  довольно
легко  создателем любой подобной программы,  все-таки редко бывает,
чтобы рабочая программа изучалась своим создателем после  того,  как  она
уже запущена.  Во всех этих случаях вирусы написаны таким образом,  чтобы по
трассам их распространения в соответствующих операционных системах было
невозможно определить источника вируса,  даже если сам вирус обнаружен.
Поскольку вирусы для UNIX и вирусы,  написанные на  Бэйсике,  могли  бы
легко распространяться через гетерогенную сеть, они рассматриваются как
особо опасные.</p>

<p>    И на этот раз мы опять не смогли получить разрешение  на наблюдение
или  эксперименты  в  любой  из  систем,  для  которых  эти вирусы были
написаны.  Результаты,  полученные для этих систем,  основаны  на  очень
простых  примерах и не могут отражать их общее поведение в системах при
обычном использовании.</p>

                            <center><h3>Итоговые выводы</h3></center>

<p>    Следующая таблица объединяет результаты экспериментов  на настоящий
момент. По горизонтали идут три системы (Unix, Bell-LaPadula и следящее
оборудование), тогда как по вертикали идет указывает производительность
(время   программирования   и  инфицирования,  количество  строк  кода,
количество   выполненных   экспериментов,   минимальное,   среднее    и
максимальное  времена  владения)  где  "время  владения"  -  это время,
которое требуется нападающему для владения  ресурсами,  чтобы  внедрить
вирус.</p>

                             <center><h3> Итоги атак</h3></center>

  <pre>
                | Unix-C|  B-L  | Instr |Unix-sh|  VMS  | Basic |
                -------------------------------------------------
        Time    | 8 hrs |18 hrs |  N/A  | 15min | 30min | 4 hrs |
                -------------------------------------------------
        Inf t   |.5 sec |20 sec |  N/A  | 2 sec | 2 sec | 10 sec|
                -------------------------------------------------
        Code    | 200 l | 260 l |  N/A  |  7 l  |  9 l  | 100 l |
                -------------------------------------------------
        Trials  |  5    |  N/A  |  N/A  |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Min t   | 5 min |  N/A  |30 sec |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Avg t   |30 min |  N/A  |30 min |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------
        Max t   |60 min |  N/A  |48 hrs |  N/A  |  N/A  |  N/A  |
                -------------------------------------------------</pre>

<p>    Оказалось, что  вирусная  атака  может  быть  легко  разработана за
короткое  время,  может  оставлять  мало  следов  в  самых  современных
системах,   эффективна   против   современных   политик   безопасности,
применяемых для многоуровневого использования,  и требует  минимального
опыта для своего осуществления.  Потенциальная угроза вирусов серьезна,
они  могут  распространиться  очень  быстро  по  компьютерной  системе.
Оказывается,  что они могут распространятья через компьютерные сети так
же,  как  они  распространяются  по  компьютерам  и,   таким   образом,
представляют  собой  обширную  и  актуальную угрозу для многих реальных
систем.</p>

<p>    Проблемы с  правилами,  которые  запрещают эксперименты с системами
безопасности,  понятны;  лишая пользователей способности продолжать их
работу,   тем   самым  провоцируются  незаконные  атаки;  и  если  один
пользователь сумел запустить атаку,  не используя  системные  дыры  или
специальные  знания,  то  и  другие пользователи также будут способными
сделать это.  Просто предупреждая пользователей, чтобы они не запускали
атаку,  невозможно  достичь цели;  пользователи,  которым доверяют,  не
будут запускать атаку; но нельзя доверять пользователям, которые
могут  нанести  вред,  так  что законная работа окажется заблокирована.
Перспектива,  что каждая допущенная атака  уменьшает  безопасность,  по
мнению автора - ошибка. Идея использовать атаки, чтобы изучать проблемы
даже  потребовала  участия  государственной  политики  для  обеспечения
надежности   систем  [Klein83]  [Kaplan82].  Будет  более  рациональным
использовать  открытый  и  управляемый  эксперимент,  как   ресурс   для
увеличения безопасности.</p>

               <center><h3>ОКОНЧАТЕЛЬНЫЕ ВЫВОДЫ И ДАЛЬНЕЙШИЕ ПЛАНЫ</h3></center>

<p>    Короче говоря,  абсолютная  защита  может  легко  быть   достигнута
применением  абсолютного  изоляционизма,  но  это  обычно  неприемлемое
решение.  Другие формы защиты,  как кажется,  связаны с  использованием
чрезвычайно  сложных  и/или  ресурсоемких  аналитических  методов,  или
неточных решений, которые делают такие системы все менее пригодными.</p>

<p>    Оказалось, что  предотвращение  вирусных  атак  включает   законные
ограничительные   действия,   тогда   как   лечение  может  потребовать
существенных нарушений принятых законов и  правил.  Точное  обнаружение
является  неразрешимыми,  тем не менее статистические методы могут быть
использованы, чтобы ограничить необнаруженное распространение вируса по
скорости  или количеству.  Поведение типичного пользователя должно быть
хорошо изучено для того,  чтобы использовать статистические  методы,  и
это  поведение  может  изменяться  от системы к системе.  Ограниченные
формы обнаружения и  предотвращения  могли  бы  быть  использованы  для
ограниченной защиты из вирусов.</p>

<p>    Продемонстрировано, что       потенциально      вирус      способен
распространяться в любой системе, которая допускает разделение доступа.
Каждая универсальная система,  используемая в настоящее время,  открыта
для, по крайней мере, ограниченной вирусной атаки.  Во многих  "надежных"
системах  вирусы  стремятся  распространяться  при  помощи "ненадежных"
пользователей.  Эксперименты показывают жизнеспособность вирусной атаки
и   указывают,   что  вирусы  распространяют  быстро  и  легко  в  ряде
операционных систем. Дальнейшие эксперименты все еще впереди.</p>

<p>    Настоящие результаты  не  специфичны  для  какой-нибудь  конкретной
операционной   системы   или   специфической  версии,  но  основаны  на
фундаментальных  свойствах  систем.  Более  важно,  что  они   отражают
реалистичные предположения о системах,  используемых в настоящее время.
Далее,  почти  каждая  "безопасная"  система,  разрабатываемая  сейчас,
основана  на  политике  Bell-LaPadula  или  табличных политиках,  и эта
работа  ясно  продемонстрировала,  что  эти  модели  недостаточны   для
предохранения  от  вирусной  атаки.  Вирус по существу доказывает,  что
управление целостностью  должно  считаться  существенной  частью  любой
безопасной операционной системы.</p>

<p>    Упомянем несколько пока еще нерешенных проблем,  касающихся вирусов
и мер антивирусного противодействия.</p>

<p>Это:</p>

<ul><li>Проблемы неразрешимости обнаружения
<li>Обнаружение вируса по внешнему виду
<li>Обнаружение вируса по поведению
<li>Обнаружение эволюций известного вируса
<li>Обнаружение переключающего механизма по внешнему виду
<li>Обнаружение переключающего механизма по поведению
<li>Обнаружение эволюционирующего переключающего механизма
<li>Обнаружение вирусного детектора по внешнему виду
<li>Обнаружение вирусного детектора по поведению
<li>Обнаружение эволюционирующего вирусного детектора</ul>

<p>    Несколько потенциальных  контрмер были изучены более или менее глубоко,
и ни одна  из  них  не  является  идеальным  решением.  В  этой  статье
предлагались некоторые методы, которые могли бы обеспечить ограниченную
вирусную  защиту,  но  применимость  их   на   текущий   момент   также
ограничена.  Чтобы  полностью  обезопасить себя от вирусной атаки,
система должна защититься от поступающего информационного потока, тогда
как,   чтобы   защититься  от  утечки  информации,  система  должна
защититься от исходящего информационного потока. Также определенный
информационный  поток  должен  обеспечивать работу систем с разделением
доступа.  Основной вывод этой статьи,  что цели  разделения  доступа  в
универсальной  многоуровневой  системе  могут прямо противоречить целям
вирусной безопасности,  что  делает  их  примирение  и  сосуществование
невозможными.</p>

<p>    Наиболее важное   в   данном  исследовании  -  влияние  вирусов  на
компьютерные сети.  Прежде всего интересно,  как быстро  вирус  мог  бы
распространиться на большинство компьютеров в мире.  Это делается через
упрощенные   математические    модели    и    исследования    вирусного
распространения  в  "типичных"  компьютерных сетях.  Последствия работы
вируса в безопасной сети  также  вызывает  большой  интерес.  Поскольку
вирус  приводит  нас  к  вере,  что  как целостность, так и безопасность
должны поддерживаться в  системе  для  того,  чтобы  предохраняться  от
вирусной  атаки,  сеть должна также поддерживать оба критерия с целью
недопущения многоуровневого разделения доступа  между  компьютерами.
Это  приводит  к  необходимости  введения  существенных  ограничений на
функции подобных сетей.</p>

<p>    Были разработаны примеры  эволюционирующих  программ  для  создания
множества  модификаций  конкретной программы.  Простой эволюционирующий
вирус уже разработан, и для него сейчас разрабатывается эволюционирующий
антивирус.  Механизм  списка потоков для Unix будет осуществлен,  когда
необходимые  аппаратные  средства  будут  доступны,  и  ожидается,  что
следящие   за  сетями  средства  появятся  после  получения  средств  и
ассигнований.  Статистические   методы   обнаружения,   основанные   на
результатах  работы  таких  средств, - также планируется разработать,  а
набор принципов и правил для уменьшения вирусной угрозы уже разработан.</p>

                             <center><h3>Благодарности</h3></center>

<p>    Вследствие специфической природы большинства  этих  исследований  и
экспериментов,  имеется  множество  людей,  которых  я  просто не смогу
отблагодарить.  Вместо того,  чтобы умолчать от таких  людях,  я  решил
просто назвать их имена. Len и David снабдили существенной поддержкой и
при исследованиях,  и при написании статьи,  и без них я бы не добрался
до этого места. John, Frank, Connie, Chris, Peter, Terry, Dick, Jerome,
Mike,  Marv,  Steve, Lou, Steve, Andy и Loraine совали свои носы во все
аспекты   не   менее,  чем  помогали  при  выполнении  экспериментов  и
публикации результатов, чем и поддерживали работу. Martin, John, Magdy,
Xi-an,  Satish,  Chris, Steve, JR, Jay, Bill, Fadi, Irv, Saul и Frank в
основном помалкивали,  но их  терпение  и  дружеское  участие  являются
неоценимыми.   Alice,   John,   Mel,   Ann   и  Ed  блокировали броски
в кольцо не хуже, чем баскетболисты.</p>
                  
<table bgcolor="teal" width="100%"><tr><td>
<center>
<font face="" size="+2" color="White">КОММЕНАРИИ ПЕРЕВОДЧИКА</font><br>
<font face="" size="+1" color="White">by Constantin E. Climentieff, 2004
</font>
</center>
</td></tr></table>                        

<center><h3><a name="m1">Примечание 1.</a></h3></center>

<p>    "Машина Тьюринга" - формальная математическая  модель, используемая
в  теории алгоритмов.  Представляет собой бесконечную ленту с ячейками. 
Каждая ячейка содержит некий символ,
принадлежащий  некоему  алфавиту (в том числе и символ "пусто").  Кроме
того,  над  лентой   перемещается   программно-управляемая   "головка",
способная  читать и записывать находящиеся в ячейках символы. Программа
для "машины Тьюринга" представляет собой таблицу команд,  зависящих  от
текущего   символа   и   текущего   состояния  машины.  Функциональными
эквивалентами  "машины  Тьюринга",  разработанной  в   1936   году   А.
Тьюрингом, являются "машина Поста", "нормальные алгоритмы Маркова", 
"рекурсивные функции" и некоторые другие формальные модели.</p>

<center><h3><a name="m2">Примечание 2.</a></h3></center>

<p>    Понятие "NP-полноты"   используется   для  описания  вычислительной
сложности алгоритмов.  В рамках теории алгоритмов рассматриваются:</p>
<ul>    <li>P  -  класс алгоритмов,  выполняющихся за "полиномиальное" время
(т.е.  за время,  рассматриваемое в  смысле  количества  шагов  "машины
Тьюринга"  и  описываемое  полиномиальной  функцией  от размера входных
данных);
    <li>NP  -  класс  алгоритмов,  включающих  себя некоторую (возможно,
неформальную) процедуру,  позволяющую сразу выбрать вариант "ответа"  и
доказать его правильность/неправильность при помощи алгоритма класса P.</ul>
<p>    Строго не доказано,  но общепризнано,  что |P|<|NP|.  Для  описания
подмножества экстремально сложных алгоритмов,  принадлежащих к NP, но не
принадлежащих к P, используется термин "NP-полные".</p>

<center><h3><a name="m3">Примечание 3.</a></h3></center>

<p>    "Транзитивное замыкание"   -   понятие   теории    множеств.    Это
подмножество  всех  пар элементов  множества,  находящихся  в  определенном
отношении друг с другом либо сразу непосредственно,  либо через  другие
элементы, находищиеся друг с другом в непосредственном отношении.</p>

<center><h3><a name="m4">Примечание 4.</a></h3></center>

<p>    Критику тезиса о "сжимающем вирусе" см.  в статье Весселина Бончева
"Являются ли хорошие компьютерные вирусы по прежнему плохой   идеей"   
(перевод   можно   найти   здесь:    <a href="http://www.nf-team.org/drmad/bontch.htm">http://www.nf-team.org/drmad/bontch.htm</a>).</p>

<center><h3><a name="m5">Примечание 5.</a></h3></center>

<p>    Политика безопасности   -  формальная  модель,  включающая  в  себя
определенную  систему  правил  и  призванная  обеспечить   "защищенность"
информационых   систем.   В  рамках  этих  моделей  пассивные  "объекты
доступа" подвергаются со стороны активных "объектов  доступа"  каким-то
действиям  в  соответствии  с определенными "методами доступа" (чтение,
запись,  исполнение и т.п.),  а  разрешение/заперещение  этих  действий
производится  "монитором  безопасности".  В общем случае существуют две
больших группы политик безопасности:</p>
    <ul><li>дискреционные, основанные  на  системах   разрешений/запрещений,
определенных для каждой тройки &lt;"субъект","объект","метод"&gt;;
    <li>мандатные, основанные  на  присвоении  каждому   "объекту"   или
"субъекту" определенной "метки безопасности" и на разрешении/запрещении
конкретного действия путем сравнения этих меток.</ul>
<p>    Модели Белла-ЛаПадулы и "низкой водяной метки" относятся ко второму
классу.</p>

<center><h3><a name="m6">Примечание 6.</a></h3></center>

<p>    Любопытно, что  из  контекста  статьи  вытекает  понятие "эволюции"
вируса гораздо более широкое,  чем  тривиальный  вирусный  полиморфизм,
приведенный автором в качестве примера.</p>

<hr>

Перевод: Constantin E. Climentieff aka DrMAD, 1997-98, 2004, 2008


    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

