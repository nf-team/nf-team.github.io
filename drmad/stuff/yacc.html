<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<tile="YACC - еще один компилятор компиляторов">
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>	
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
	
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
	
    <!---> 	
<BODY TEXT="Black" LINK="Teal" VLINK="Teal" ALINK="Olive">    

<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
 <FONT SIZE=+3 COLOR="White">  

          YACC - еще один компилятор компиляторов<br>
</FONT>
<FONT COLOR="White">  
Стефен С. Джонсон,   Bell Laboratories,  Murray Hill , New Jersey 07974
</FONT>
</TH>
</TR>
</TABLE>                    

<br><a href="index.html"><img src="back.gif"></a><br>


  <CENTER>                    <h2>Аннотация -- YACC</h2></CENTER>

<p>
     Входные данные  компьютерных  программ в общем обладают некоторой
структурой;  фактически  ,  любая  компьютерная  программа  ,  которая
выполняет ввод ,  может быть определена посредством "входного языка" ,
который она воспринимает.Входной язык может быть так же сложен  ,  как
язык  программирования  ,  или  так же прост ,  как последовательность
чисел.К сожалению обычные возможности  ввода  ограничены  ,  сложны  в
использовании и часто недостаточно обоснованы.
</p>
<p>
     Yacc снабжает общим инструментарием для описания  процесса  ввода
компьютерными  программами  .  Пользователь системы YACC специфицирует
структуру своего ввода вместе с кодом ,  необходимым для распознавания
этой структуры.YACC включает такую спецификацию в процедуру ,  которая
выполняет вводной процесс ;  часто это весьма удобно  и  соответствует
большинству   потоков  управления  ,  определяемых  пользователем  для
осуществления данной процедурой.
</p>
<p>
     Вводная процедура,   сгенерированная  системой  YACC  ,  вызывает
процедуры пользователя для выборки очередной  базовой  единицы  ввода.
Т.о.   пользователь   может   специфицировать  свой  ввод  в  терминах
индивидуальных образов ,  или в терминах  таких  конструкций  высокого
уровня ,  как имена или числа .Пользовательская процедура может так же
поддерживать  такие  идиоматические  понятия  ,  как  комментарий  или
продолжительные  соглашения  ,  которые  обычно не подчиняются простой
грамматической спецификации .
</p>
<p>
     YACC написан  на  компактном  диалекте Си .  Класс спецификаций ,
воспринимаемый системой в  общем  следующий  :  грамматика  LALR(1)  с
непротиворечивыми правилами.
</p>
<p>
     Кроме компиляторов с языков Си ,  АПЛ ,  Паскаль , Ратфор и др. ,
YACC  может  использоваться  так  же  с менее согласованными языками ,
такими как языки установки  прототипов  ,  некоторые  языки  табличных
вычислений  ,  системы  исправления  ошибок  в  документах  и отладчик
Фортрановских программ.
</p>
                                      31 июля 1978 г.

                          0. Введение

<p>
     YACC снабжает общим инструментарием ,  пригодным для наложения на
входные      данные      компьютерных      программ       определенной
структуры.Пользователь  системы  YACC  готовит  спецификацию  вводного
процесса;она включает правила описания структуры ввода,код,необходимый
в те моменты времени , когда эти правила распознаются и низкоуровневые
процедуры ,  выполняющие  базовый  ввод.После  этого  YACC  генерирует
функцию  управления  процессом  ввода.Эта  функция ,  которую мы будем
называть  разборщик  (  parcer  )  вызывает  написанные  пользователем
низкоуровневые  процедуры ввода ( лексический анализатор ),  чтобы они
выбирали базовые элементы ( токены ) из  входного  потока.Совокупность
токенов   и   правил   ,   описывающих   структуру   ввода  называется
грамматическим правилом ;  когда одно из этих правил распознается ,  к
этому  правилу  применяется  соответствующий код пользователя.Во время
выполнения этого процесса возможно  возвращать  определенные  числовые
значения , чтобы использовать их в другие моменты времени.
</p>
<p>
     YACC написан на компактном диалекте Си и все действия и процедуры
ввода соответствуют Си . Более того , многие синтаксические соглашения
системы YACC следуют традициям Си.
</p>
<p>
     Ядро спецификаций  ввода  представляет собой набор грамматических
правил.Каждое правило описывыет разрешенную структуру и  ставит  ей  в
соответствие   определенное  имя.Например,какое-нибудь  грамматическое
правило может иметь вид :
<p>
<pre>
                  ДАТА : МЕСЯЦ ДЕНЬ ',' ГОД ;

</pre>
<p>
     Здесь "ДАТА"  ,  "ДЕНЬ"  ,  "МЕСЯЦ"  и  "ГОД"  предствляют  собой
интересующие нас элементы структуры вводного процесса;предполагается ,
что сами эти элементы  описаны  в  другом  месте.Запятая  заключена  в
единичные  кавычки;это  означает  ,  что запятая появляется во входном
потоке непосредственно .Двоеточие и точка с запятой  -  суть  элементы
пунктуации,принятые при описании правила ;  они не играют определяющей
роли при управлении процессом ввода.
    Итак , следущее простое выражение
<pre>
                        ИЮЛЬ 4 , 1776
</pre>
соответствует вышеприведенному правилу .
</p>
<p>
     Важная часть процесса ввода выполняется лексическим  анализатором
.  Эта  пользовательская  процедура  читает  входной поток ,распознает
низкоуровневые  структуры   и   передает   эти   токены   разборщику.В
специальной     литературе     структура,распознаваемая    лексическим
анализатором называется терминальным символом ,  тогда как структура ,
распознаваемая  разборщиком  -  нетерминальным символом.Чтобы избежать
смысловой путаницы ,  терминальный символ будем почти во всех  случаях
ставить в соответствие понятию "токен".
</p>
<p>
     Существует некоторая двусмысленность при  определении  того,  чем
должна  обрабатываться конкретная структура - лексическим анализатором
или разборщикомю.Например, правила
<pre>
                      МЕСЯЦ : 'J''A''N';
                      МЕСЯЦ : 'F''E''B';
                      МЕСЯЦ : 'D''E''C';
</pre>
</p>
<p>
     могут быть использованы в  предыдущем  примере.Пусть  лексический
анализатор должен будет распознавать единичные буквы - и тогда МЕСЯЦ -
нетерминальный символ.Применение подобных никоуровневых правил ведет к
излишней  трате  времени  и  памяти  системой и может только усложнить
работу    YACC'а    вплоть    до    невозможности    им    производить
обработку.Достаточно,чтобы  лексический  анализатор просто распознавал
имя месяца и возвращал признак того ,  что прочитан элемент  "МЕСЯЦ";в
этом случае он играет роль токена.
</p>
<p>
     Литерал типа "," так же должен быть  пропущен  через  лексический
анализатор в качестве токена.
</p>
<p>
     Списки спецификаций  достаточно  гибки.Весьма  легко  добавить  к
предыдущему примеру правило
</p>
<pre>
               ДАТА : МЕСЯЦ '/' ДЕНЬ '/' ГОД ;
</pre>
,так что строка вида
<pre>
                           7/4/1776
</pre>
будет синонимом для
<pre>
                         ИЮЛЬ 4,1776
</pre>

<p>
     Во многих  случаях  новое  правило  может  быть  присовокуплено к
работающей  системе  без  больших  затрат  и  с  минимальной  степенью
опасности разрушить ранее определенную структуру.
</p>
<p>
     Читаемый входной поток может не совпадать со спецификацией. Такие
ошибки  ввода  распознаются  достаточно  легко  при сканировании слева
направо.Это снижает  шансы  пропустить  некорректные  данные.Обработка
ошибок,предусмотренная в спецификации,позволяет проигнорировать плохие
данные или индицировать их появление во входном потоке.
</p>
<p>
     В некоторых  случаях  YACC  прерывает продуцирование разборщика ,
описанного    некорректной    последовательностью    спецификаций    .
Например,спецификации  могут  противоречить  друг  другу,  либо  может
потребоваться  более  мощный  алгоритм  разбора  ,   чем   тот,который
поддерживается  системой  YACC.В первом случае мы имеем дело с ошибкой
проектирования;во втором случае иногда удается скорректировать процесс
применением  более  мощного  лексического  анализатора  или изменением
некоторых  грамматических  правил.Однако,в  случае,  когда   YACC   не
способен  обработать  все возможные спецификации ,  обычно бессильны и
другие подобные системы;  более того,конструкции,трудные для YACC'а  ,
как  правило,трудны  и для человека.Многие пользователи сообщали,  что
строгая   дисциплина   при   формулировании   спецификаций   позволяла
обнаруживать   ошибки  в  концепции  и  проектировании  раньше  ,  чем
начиналось собственно написание программы.
</p>
<p>
     Основные теоретически предпосылки построения системы YACC описаны
в [2,3,4].YACC широко использовался  в  практических  разработках  [5]
компактного  компилятора  с  Си  и в системе для набора математических
символов[7].
</p>
<p>
     Следующие несколько  глав  описывают  базовый  процесс подготовки
спецификаций системы YACC;глава 1 описывает подготовку  грамматических
правил , глава 2 - подготовку пользовательских действий,поставленных в
соответствие  этим  правилам,глава  3  -   использование   лексических
анализаторов.Глава 4 описывает процесс функционирования разборщика . В
главе  5  обсуждаются  различные  причины   невозможности   построения
разборщика  по  спецификациям  ,  и  что  при  этом  делать.В  главе 6
описывается простой механизм работы оператора  разбора  арифметических
выражений  .В  главе  7  обсуждаются  приемы обнаружения и исправления
ошибок.Глава 8  обсуждает  операционную  среду  и  особенности  разных
версий   системы  YACC.Глава  9  дает  некоторые  сведения  ,  которые
позволяют улучшить стиль и  увеличить  эффективность  программирования
спецификаций.В  главе  10  обсуждаются  некоторые  достаточно  сложные
примеры применения , а в главе 11 содержатся благодарности.
</p>
<p>
     Приложение А содержит простой пример использования , а приложение
В  -  сводку  синтаксических  правил  системы  YACC.В   приложении   С
предлагается пример , использующий несколько более сложные возможности
системы  YACC,и,наконец  в  приложении  D   описываются   средства   ,
сохранившееся в современной версии системы от более ранних разработок.
</p>

<h2>
1.Базовые спецификации.
</h2>

<p>
     Имена ссылаются  на  любой  токен  или нетерминальный символ.YACC
требует,  чтобы имена токенов были описаны как таковые.В добавление  к
тому,что  еще  будет  обсуждаться  в  главе  3,часто желательно бывает
включить  лексический  анализатор  в  список  спецификаций.Это   может
облегчить подключение других программ.
</p>
<p>
     Итак,каждый файл  спецификаций  содержит  три  секции  :   секцию
описаний  ,  секцию  грамматических  правил  и секцию программы.Секции
разделяются знакосочетанием "%%".Одиночный знак процента  используется
в спецификациях для изменения значения символа.
</p>
<p>
     Другими словами , полная спецификация выглядит так :
</p>
<pre>
                           ОПИСАНИЯ
                           %%
                           ПРАВИЛА
                           %%
                           ПРОГРАММА

</pre>
<p>
     Секция описаний  может  быть  пустой.Более  того,   если   секция
программ отсутствует,второй значок %% может быть опущен.Таким образом,
минимальная допустимая спецификация системы YACC будет :
</p>
<pre>
                           %%
                           ПРАВИЛА

</pre>
<p>
     Пробелы,знаки табуляции и  пустые  строки  игнорируются  ,  кроме
случая,когда   они   вставляются   внутрь   имен  или  многосимвольных
зарезервированных слов.
</p>
<p>
    Комментарии могут появляться в любой точке,они отмечаются
</p>
<pre>
                          /* ... */
</pre>
<p>
,как в языках Си или ПЛ/1.
</p>
<p>
     Секция правил   состоит   из   одного  или  более  грамматических
правил.Грамматическое правило имеет вид :
</p>
<pre>
                          А : ТЕЛО ;
</pre>
<p>
     "А" представляет собой нетерминальный символ,  а "ТЕЛО" -  пустую
или  непустую  последовательность  имен и символов.Двоеточие и точка с
запятой предусматриваются правилами пунктуации системы YACC.
</p>
<p>
     Имена могут   быть   произвольной   длины   ,   могут   содержать
литеры,точки,знак подчеркивания и  цифры.Прописные  и  строчные  буквы
различаются.Имена,используемые  в  теле  грамматического правила,могут
представлять токены или нетерминальные символы.
</p>
<p>
     Литерал состоит из символа,заключенного в одиночные кавычки.Как и
в Си ,  обратный слэш "\" изменяет значение  некоторых  символов  ,  и
здесь действительны все соглашения языка Си :
</p>
<pre>

                   '\n'    - перевод строки
                   '\r'    - возврат
                   '\''    - сама единичная кавычка
                   '\t'    - табуляция
                   '\b'    - шаг назад
                   '\f'    - перевод формата
                   '\xxx'  - число в 8-ричной форме

</pre>
<p>
     По техническим  причинам  нулевой  символ  ('\0')  не  разрешен в
грамматических правилах.
</p>
<p>
     Если встрачаются  несколько  грамматических  правил  с одинаковой
левой частью ,  то вертикальная черта "|" может  быть  использована  в
качестве  повторителя.  Запяточка  в  конце правила может быть опущена
перед вертикальной чертой . Таким образом , грамматическое правило
</p>
<pre>

                         A : B C D ;
                         A : E F ;
                         A : G ;
</pre>
<p>
    может быть представлено как
</p>
<pre>
                         A : B C D
                           | E F
                           | G
                           ;

</pre>
<p>
     Необязательно,чтобы все   грамматические  правила  с  одинаковыми
левыми частями появлялись вместе в секции грамматических правил,  хотя
это сделало бы текст более читабельным и изменябельным.
</p>
<p>
     Если нетерминальный символ соответствует пустой строке  ,  то  он
может быть определен очевидным образом :
</p>
<pre>
                            пусто :;

</pre>
<p>
     Имена, представляющие   токены  ,  должны  быть  описаны;наиболее
просто это можно сделать так
</p>
<pre>
                    % token имя1 имя2 ...

</pre>
<p>
     и поместить в секцию описаний ( см. главы 3,5 и 6 ).Каждое имя,не
прозвучавшее  в  секции описаний ,  рассматривается как нетерминальный
символ.Каждый нетерминальый символ должен появиться в левой части хотя
бы одного правила.
</p>
<p>
     Изо всех  нетерминальных  символов  один,  называемый   стартовым
символом,имеет особый смысл.Разборщик построен так,что первым делом он
ищет    стартовый    символ;этот    символ    представляет     главную
структуру,описанную  грамматическими  правилами.По умолчанию стартовый
символ находится в  левой  части  первого  грамматического  правила  в
секции  правил.Если это возможно ,  то желательно обозначить стартовый
символ ключевым именем %start :
</p>
<pre>
                        %start символ

</pre>
<p>
     Конец ввода отмечается специальным токеном  -  меткой  конца.Если
токен  использует  ,  но  не  содержит  метку  конца  со  структурой ,
соответствующей структуре  стартового  символа,то  функция  разборщика
возвращает  управление  той  программной еденице,  которая ее вызывает
после того ,  как обнаружит метку конца;она в  этом  случае  принимает
входные  данные  .Если  же  метка  конца  обнаружена  в  любом  другом
контексте, то это уже ошибка.
</p>
<p>
     Возвращать метку    конца    -   это   работа   пользовательского
лексического  анализатора  (см.   главу   3   ).Обычно   метка   конца
представляет  собой  своего  рода  событие  во время ввода/вывода типа
"обнаружен конец файла" или "конец записи".
</p>
<h2>
                          2.Действия

</h2>
<p>
     Пользователь может поставить в соответствие любому  распознанному
во время процесса ввода правилу действие, которое должно выполняться в
этот момент.Это действие может возвращать определенные  величины  ,  а
может и получать их от предыдущих действий .  Более того , лексический
анализатор может возвращать номер токена, если это необходимо.
</p>
<p>
     Действие -   это  произвольный  оператор  языка  Си,  выполняющий
функции типа ввода/вывода ,  вызова подпрограмм , модификации значений
внешних переменных и массивов.
</p>
<p>
     Действие ,  специфицированное  одним   или   более   операторами,
заключается в фигурные скобки "{" и "}".Например :
</p>
<pre>
                   A    : '(' B ')'
                        { hello( 1, "abc" ); }
</pre>
    и
<pre>
                   XXX  : YYY ZZZ
                        { printf("a message\n"); flag = 25; }
</pre>
<p>
    Это грамматические правила с действиями.
</p>
<p>
     Для удобства соединения действий с разборщиком оператор  действия
может  изменяться.  Символ  "знак  доллара  - $" сигнализирует об этом
системе YACC.
</p>
<p>
     Для возврата значений действие ставит в соответствие определенной
переменной псевдопеременную  "$$".Например  ,  действие  ,  ничего  не
выполняющее , но возвращающее величину 1, выглядит так :
</p>
<pre>

                          { $$=1; }

</pre>
<p>
     Для получения  значения,  возвращенного  предыдущим действием или
лексическим   анализатором   ,   это   действие   может   использовать
псевдопеременные  $1  ,  $2  и  др.,  которые  ссылаются на значения ,
возвращаемые компонентами из правой части  правила  и  читаются  слева
направо. Так , в правиле
</p>
<pre>

                          A : B C D;
</pre>

<p>
    $2 - это значение , возвращаемое С , а $3 - возвращаемое D.
    Рассмотрим более конкретный пример :
</p>
<pre>
                ВЫРАЖЕНИЕ : '(' ВЫРАЖЕНИЕ ')';

</pre>
<p>
     Величина,возвращаемая этим правилом -  это  значение  "ВЫРАЖЕНИЯ"
.Это может быть представлено так:
</p>
<pre>
                ВЫРАЖЕНИЕ : '(' ВЫРАЖЕНИЕ ')'
                         { $$=$2 ; }

</pre>
<p>
     По умолчанию значение правила - это значение его первого элемента
( $1 ).Грамматическое правило вида
</p>
<pre>
                            А : В
</pre>
<p>
    может и не предусматривать дополнительных действий.
</p>
<p>
     В предыдущих    примерах    действия    размещались    в    конце
соответствующих  правил.Иногда  бывает  желательно получить управление
еще до того,  как правило  будет  полностью  разобрано.YACC  разрешает
помещать   действия  в  середине  правила.Такое  правило  воспринимает
величину для возврата  посредством  обычного  механизма  использования
действия в его правой части.Иначе,  оно может иметь доступ к величинам
,  возвращенным  из   символов   ,   расположенных   в   левой   части
правила. Например , правило

<pre>
               A    : B
                         { $$ = 1; }
                      C
                         { x = $2; y = $3; }
                    ;
</pre>

<p>
     устанавливает x  в  единицу и ставит в соответствие переменную $3
символу C.
</p>
<p>
     Действия ,  которые не находятся в конце грамматического правила,
рассматриваются  системой  YACC  как  соответствующие  некому   новому
грамматическому  правилу  с  пустой  правой  частью.Выполнение  такого
действия вызывается распознаванием этого дополнительного  правила.YACC
фактически рассматривает предыдущий пример в виде :
</p>
<pre>

               $ACT :    /* empty */
                              { $$ = 1; }
                    ;
               A    :    B $ACT C
                              { x = $2; y = $3; }
                    ;

</pre>
<p>
     Во многих  случаях  процесс  вывода  осуществляется  не  во время
выполнения  действия  ;  структура   данных   (   дерево   разбора   )
конструируется   в   памяти   ,   и   вывод  генерируется  лишь  после
трансформаций этой структуры.Дерево разбора конструируется легко, т.к.
снабжается процедурами построения и поддержки.Например, допустим , что
существует написанная на Си функция , вызываемая оператором
</p>
<pre>
                        node(l,n1,n2)

</pre>
<p>
     ,выполняющая операцию над  узлом  дерева  с  полями  n1  и  n2  и
возвращающая   определенный   результат.Дерево   разбора   может  быть
построено применением следующих действий :
</p>
<pre>
               expr : expr '+' expr
                         { $$ = node( '+', $1, $3 ); }

</pre>
<p>
     Пользователь может  описывать  другие  переменные ,  используемые
действиями. Декларации и описания могут появляться в секции описаний ,
заключенные  между  %{ и %}.Эти декларации и описания имеют глобальную
видимость  ,  так  что  они  доступны  для   операторов   действий   и
лексического анализатора.Например,
</p>
<pre>
                       %{
                       int variable=0;
                       %}

</pre>
<p>
     может быть   помещено  в  секцию  описаний  и  делает  переменную
"variable" доступной для  всех  действий.Сам  разборщик  системы  YACC
использует  только  имена,  начинающиеся  с "yy";  пользователь должен
избегать таких имен в своей программе.
</p>
<p>
     В вышеприведенных  примерах  все  переменные  считались  целыми ;
обсуждение возможности использования переменных других типов вы можете
найти в главе 10.
</p>
<h2>
                     3.Лексический анализ

</h2>
<p>
     Пользователь может  применять  лексический  анализатор для чтения
входного потока и передачи токенов ( с включенными в них  значениями )
разборщику.Лексический  анализатор -это целочисленная функция языка Си
,  именуемая  yylex.Эта  функция  возвращает  целое  число  --   номер
очередного     прочитанного     токена.Если    существует    величина,
ассоциированная данному токену,  то ее значение содержится во  внешней
переменной yylval.
</p>
<p>
     Разборщик и лексический анализатор должны при  совместной  работе
использовать одни и те же номера токенов ,  расположенные в одинаковом
порядке.  Эти номера могут быть потом  затребованы  для  интерпретации
либо  системой  YACC  ,  либо  пользователем.В любом случае механизм "
#define " языка Си позволяет лексическому анализатору  возвращать  эти
номера  в  символьном  виде.Предположим  ,  что  токен  по имени ЦИФРА
определен   в   секции   описаний   в   файле   спецификаций   системы
YACC.Соответствующий фрагмент лексического анализатора может выглядеть
так :
</p>
<pre>
               yylex()
               {
                    extern int yylval;
                    int  c;
                    ...
                    c = getchar();
                    ...
                    switch (c) {
                              . . .
                    case '0':
                    case '1':
                    ...
                    case '9':
                         yylval = c - '0';
                         return DIGIT;
                         . . .
                    }
               . . .
               }

</pre>
<p>
     Предположим ,   что   возвращаются   токен    номер    ЦИФРА    и
величина,равная  числовому значению цифры.Код лексического анализатора
помещается в программную секцию  файла  спецификаций  ,  идентификатор
ЦИФРА будет описан номером токена , соответсвующим токену ЦИФРА.
</p>
<p>
     Этот механизм   обеспечивает   легкую   модификацию   лексических
анализаторов   ;   единственное   ,   чего   надо  избегать,  так  это
использования имен токенов,  имеющих особый смысл или зарезервировнных
в  языке  Си  ;  например  использование имен токенов "if" или "while"
может  послужить  причиной  затруднений  при  компиляции  лексического
анализатора .Имя токена "error" зарезервировано для обработки ошибок и
также не должно использоваться (см. главу 7).
</p>
<p>
     Как ранее уже упоминалось ,  номера токенов могут предназначаться
как для системы YACC ,  так  и  для  пользователя.По  умолчанию  номер
токена для литеры - это числовое значение символа в последовательности
символов.Остальные имена получают номера, начиная с 257.
</p>
<p>
     Для того ,  чтобы назначить токену номер , первое появление имени
токена или литерала в секции описаний может  непосредственно следовать
за  неотрицательным  числом.Это  целое  делает номер токена именем или
литералом.Имена и литералы, не описанные посредством этого механизма ,
сохраняют  свои прежние описания по умолчанию.Важно,  чтобы все номера
токенов были четко отслежены.
</p>
<p>
     Вообще говоря,  метка  конца должна иметь номер токена,  равный 0
или отрицательному числу.Этот номер токена не может быть переопределен
пользователем ;  так , все лексические анализаторы должны возвращать 0
или отрицательное число, как только будет достигнут конец ввода.
</p>
<p>
     Очень удобным    средством    для   конструирования   лексических
анализаторов является система LEX, разработанная Майком Леском [8].Эти
лексические  анализаторы  гармонично  сочетаются с разборщиком системы
YACC.Спецификации этих анализаторов  используют  регулярные  выражения
вместо  грамматических  правил.LEX  может  быть  легко использован для
разработки весьма сложных лексических анализаторов , но остаются языки
(  например  ,  Фортран  )  не  пригодные  для строгого теоретического
описания  ,  и  в  подобных  случаях  лексические  анализаторы  должны
разрабатываться пользователем самостоятельно.
</p>
<h2>
                   4.Как разборщик работает

</h2>
<p>
     Система YACC  превращает  файл  спецификаций в программу на языке
Си,  которая  разбирает  входной  поток  в  соответствии   с   данными
спецификациями.Алгоритм  этого  превращения  весьма  сложен и не будет
здесь рассматриваться.Но разборщик сам по себе относительно  прост  ,и
понимание  принципов  его работы,  пусть и не очень полное и строгое ,
желательно   при   обработке   обнаруженных   разборщиком   ошибок   и
двусмысленностей.
</p>
<p>
     Разборщик,построенный системой  YACC  функционирует  по  принципу
конечного автомата со стековой памятью.Разборщик также способен читать
и запоминать следующий вводимый токен (именуемый  последующим  токеном
).Текущее   состояние   конечного   автомата   соответствует   вершине
стека.Каждому состоянию конечного автомата поставлена  в  соответствие
целочисленная  метка;изначально автомат находится в состоянии 0,  стек
пуст и ожидается ввод последующего токена.
</p>
<p>
     Автомат обрабатывает  только  четыре  ситуации  :  сдвиг (shift),
свертка  (reduce)  ,  прием  и  отказ.Каждой   ситуации   поставим   в
соответствие одноименное соответствующее ей действие.Работа разборщика
выглядит следующим образом:
</p>
<p>
     1.Находясь в   определенном   состоянии   ,   разборщик   решает,
необходимо ли воспринять следующий во входном потоке токен и выполнить
соответствующее   действие;   если   это  действительно  необходимо  ,
разборщик вызывает процедуру  yylex  для  получения  этого  токена  из
входного потока.
</p>
<p>
     2.Находясь в определенном состоянии , в случае , если последующий
токен действительно необходим ,  разборщик опреденляет соответствующее
действие  и  выполнят  его.Это  может  происходить  в  случае  ,  если
состояние  втолкнуто  или  вытолкнуто  из стека ,  а последующий токен
подлежит или не подлежит обработке.
</p>
<p>
     Сдвиг --  наиболее  частое  действие  при работе разборщика.Когда
возникает ситуация  сдвига  ,  обязательно  существует  хотя  бы  один
непрочитанный последующий токен.Например,  когда разборщик находится в
состоянии 56 ,может возникнуть ситуация:
</p>
<pre>
                         IF shift 34

</pre>
<p>
     , и это означает , что если в состоянии 56 последующий токен есть
"IF" ,  то текущее состояние необходимо втолкнуть в стек,  а состояние
34 поместить на вершину стека и сделать текущим.Последующий  токен при
этом очищается.
</p>
<p>
     Обработка ситуации свертки  предохраняет  стек  от  безграничного
роста.Ситуация  свертки соответствует случаю ,  когда разборщик только
что прочитал правую часть грамматического правила  и  готов  поместить
правую   часть   правила   вслед  за  левой.Иногда  бывает  необходимо
проконсультироваться  с  последующим  токеном  --   действительно   ли
необходима  свертка;обычно бывает,  что нет;но "действие по умолчанию"
(обозначаемое  символом  ".")  очень  часто   означает   необходимость
обработки именно ситуации свертки.
</p>
<p>
     Действие свертки ставится в соответствие  грамматическим правилам
в    индивидуальном    порядке.Сами   грамматические   правила   также
пронумерованы целыми числами ,  что может привести к путанице.Действие
</p>
<pre>
                          .reduce 18

</pre>
<p>
     ссылается на грамматическое правило 18 , тогда как действие
</p>
<pre>
                         IF shift 34

</pre>
<p>
     ссылается на состояние 34.Предположим ,  что  ранее  подвергшееся
операции свертки правило выглядит так:
</p>
<pre>
                          A : X Y Z;

</pre>
<p>
     Действие свертки  зависит  от  символа  в  левой части правила (в
данном случае -- A ) и числа символов в правой части ( в данном случае
--  3  ).Операция  свертки  состоит в том ,  что три верхних состояния
выталкиваются из стека (  обычно  количество  выталкиваемых  состояний
равно  количеству  символов  в  правой  части  правила ).Эти состояния
находились в стеке,  пока шел процесс распознавания X,Y  и  Z  ,  а  в
дальнейшем  стали  не нужны.После выталкивания этих состояний из стека
текущим состоянием становится то , которое было им до начала обработки
правила.Если  использовать  это  восстановленное состояние и символ из
левой части правила, то можно получить тот же эффект, что и при сдвиге
A.Затем  новое  состояние  извлекается  ,  помещается  в стек и разбор
продолжается.
</p>
<p>
     Существует важное  различие  между  обработкой  символа  из левой
части правила и единичным  сдвигом  токена  ,  и  эта  ситуация  носит
наименование ситуации перехода.Если последующий токен очищен действием
сдвига , то он не имеет никакого отношения к действию перехода.В любом
случае восстановленное состояние подвержено воздействию вида:
</p>
<pre>
                          A goto 20

</pre>
<p>
     , которое приведет к тому , что состояние 20 запомнится в стеке и
станет текущим.
</p>
<p>
     Т.о. действие  свертки  "поворачивает  назад  время" при разборе,
выталкивая   состояние   из   стека   и   возвращаясь   к   состоянию,
соответствующему  правой  части первого прочитанного правила.Разборщик
при этом поступает так,  словно он только  что  прочитал  левую  часть
правила.Если  правая  часть  правила  пуста,  то  никакое состояние не
выталкивается из стека ,  и  восстановленное  состояние  соответствует
текущему.
</p>
<p>
     Ситуация свертки  также  важна  при  взаимодействии   применяемых
пользователем   действий  и  обрабатываемых  численных  значений.Когда
правило подвергается свертке ,  то  код  данного  правила  выполняется
перед  тем,  как  корректируется стек.Кроме стека состояний существует
работающий параллельно  с  ним  стек  значений,  содержащий  величины,
возвращаемые  лексическим  анализатором  и другими действиями.В момент
выполнения операции свертки внешняя  переменная  yylval  копируется  в
стек   значений.После   выполнения  кода  пользователя  завершается  и
операция  свертки.Когда   выполняется   действие   перехода,   внешняя
переменная yylval так же копируется в стек значений.Псевдопеременные $
1,$2 и др. аналогично ссылаются на стек значений.
</p>
<p>
     Следующие две ситуации концептуально более просты.Ситуация приема
индицирует,  что  весь  входной   поток   прочитан   и   соответствует
спецификации.Это  условие  выполняется  только  если последующий токен
есть метка конца и разборщик успешно завершил  работу.Ситуация  отказа
возникает,   когда  разборщик  не  может  более  продолжать  работу  в
соответствии  со  спецификацией.Входные  токены  прочитаны  вместе   с
последующим    токеном    и    не   могут   привести   к   корректному
результату.Разборщик сообщает об отказе и пытается  исправить ситуацию
и  продолжить  разбор;  исправление  ошибок  (  в противоположность их
простому детектированию ) будет обсуждаться в главе 7.
</p>
<p>
    Рассмотрим в качестве примера спецификацию:
</p>
<pre>
               %token DING DONG DELL
               %%
               rhyme:    sound place
                    ;
               sound:    DING DONG
                    ;
               place:    DELL
                    ;

</pre>
<p>
     Если YACC запущен с ключом -v ,  то продуцируется файл y.output с
понятным   человеку   текстом   описания  разборщика.Содержимое  файла
y.output ,  сгенерированное из предыдущей грамматики  будет  выглядеть
так :

</p>
<pre>
     state 0
          $accept : _rhyme $end

          DING shift 3
          .    error

          rhyme goto 1
          sound goto 2

     state 1
          $accept : rhyme_$end

          $end accept
          .    error

     state 2
          rhyme : sound_place

          DELL shift 5
          .    error

          place goto 4

     state 3
          sound : DING_DONG

          DONG shift 6
          .    error

     state 4

          rhyme : sound place_ (1)
          . reduce 1

     state 5
          place : DELL_ (3)
          . reduce 3

     state 6
          sound : DING DONG_ (2)
          . reduce 2

</pre>
<p>
     Отметим, что кроме ситуаций ,  соответствующих каждому состоянию,
здесь присутствует описание правил  разбора  ,  выполняемых  в  каждой
ситуации.Символ  подчеркивания  "_"  используется для индикации того в
каждом правиле, что уже прочитано и что еще продолжает обрабатываться.
Предположим, что на входе имеется
</p>
<pre>
                        DING DONG DELL

</pre>
<p>
     Полезно проследить за процессом разбора этой строки.
</p>
<p>
     Изначально текущее  состояние  имеет  номер  0.Разборщик   должен
обратиться  к  входным  данным  для того,  чтобы решить - какое именно
действие выполнять в состоянии 0;  после этого первый токен -  DING  -
становится  последующим.Ситуация в состоянии 0 при появлении DING есть
"shift 3" ("сдвиг 3") ,  и это означает,  что состояние 3 помещается в
стек,  а  последующий  токен  очищается.Текущим  состоянием становится
состояние 3.Следующий токен  ,DONG,становится  последующим.Ситуация  в
состоянии  3  для  токена  DONG  есть "shift 6" ("сдвиг 6") ,  и опять
шестое   состояние   помещается   в   стек,   а   последующий    токен
очищается.Итак,  стек содержит три состояния : 0,3 и 6.Кроме того, без
взгляда на последующий токен,  можно сразу сказать , что в состоянии 6
применима операция свертки по правилу 2:
</p>
<pre>
                      sound : DING DONG

</pre>
<p>
     Это правило  имеет  два  символа  в  правой  части,  так  что два
состояния ,  шестое и третье,  выталкиваются из стека,  и  на  вершине
остается  состояние  0.Проконсультировавшись  с описанием состояния 0,
можно обнаружить , что необходимо выполнять действие перехода :
</p>
<pre>
                         sound goto 2

</pre>
<p>
     Состояние 2 запоминается в стеке и становится текущим.В состоянии
2 должен быть прочитан следующий токен , а именно DELL.Соответствующая
ситуация - "shift 5" ,  так  что  состояние  5  вталкивается  в  стек,
который  теперь  содержит  0,2  и  5,  а  последующий  токен  при этом
очищается.Состояние 5 содержит ссылку на операцию свертки по отношению
к  правилу 3.Это правило имеет всего один символ в правой части ,  так
что   состояние   5   извлекается   из   стека   ,   а   состояние   2
восстанавливается.В  соответствии  с  левой  частью  правила  3 теперь
необходим переход из состояния 2 в состояние 4.На данный  момент  стек
содержит  0,2  и  4.Состояние  4 содержит ссылку на операцию свертки в
направлении правила 1.  Т.к.  в правой части его два символа ,  то  из
стека  извлекаются  два  первых состояния ,  и опять восстанавливается
состояние  0.Теперь  возникает  ситуация  перехода  к  состоянию   1.В
состоянии  1  происходит  очередной ввод и обнаруживается метка конца,
обозначенная  знакосочетанием  "$end"  в  файле  y.output.Ситуация   в
состоянии 1, когда метка конца прочитана, означает успешное завершение
разбора.
</p>
<p>
     Предлагается читателю  самому  проследить за работой разборщика в
случае появления на входе некорректных строк типа  DING  DONG  DONG  ,
DING DONG , DING DONG DELL и т.п. Несколько лишних минут , потраченных
на это, вероятно помогут вам при разборе более сложных ситуаций.
</p>
<h2>
                5.Двусмысленности и конфликты

</h2>
<p>
     Множество грамматических  правил  двусмысленно,  если  существует
некая  входная строка,  которая может быть структурирована несколькими
различными способами.
</p>
<p>
    Например, грамматическое правило
</p>
<pre>
                     expr : expr '-' expr

</pre>
<p>
     является естественным  описанием  того факта,  что арифметическое
выражение можно представить в виде двух других выражений и  знака  '-'
( минус  )  между  ними.К  сожалению  это  грамматическое  правило  не
однозначно описывает структуру.Например, входные данные вида
</p>
<pre>
                      expr - expr - expr
</pre>
<p>
    могут быть интерпретированы как
</p>
<pre>
                    ( expr - expr ) - expr
</pre>
<p>
    и как
</p>
<pre>
                    expr - ( expr - expr )  .

</pre>
<p>
     Первая интерпретация называется левым присоединением , а вторая -
правым.
</p>
<p>
     YACC детектирует подобные двусмысленности еще на этапе построения
разборщика.Поучительно   пронаблюдать,  как  ведет  себя  разборщик  ,
получив входную строку вида :
</p>
<pre>
                      expr - expr - expr .

</pre>
<p>
     Когда разборщик доходит до второго выражения,  то к этому моменту
уже прочитано
</p>
<pre>
                      expr - expr

</pre>
<p>
     ,что соответствует правой части грамматического правила.Разборщик
должен выполнить операцию свертки,  применяя правило;после  применения
его  входное  выражение  редуцируется (подвергается свертке) до expr (
левой части правила ).Затем разборщик должен прочитать  хвост  входной
строки:
</p>
<pre>
                            - expr

</pre>
<p>
     и снова  выполнить  операцию свертки.Эффект будет соответствовать
правилу левой ассоциации.
</p>
<p>
     В противоположность этому, когда разборщик встретит
</p>
<pre>
                         expr - expr

</pre>
<p>
     ,он должен   отложить   непосредственное   применение  правила  и
продолжить ввод, пока не прочитает
</p>
<pre>
                     expr - expr - expr .

</pre>
<p>
     Он должен  теперь  применить  правило  ко  всем  трем   символам,
редуцируя их до expr и оставляя
</p>
<pre>
                        expr - expr .

</pre>
<p>
     Теперь правило может быть редуцировано снова;эффект соответствует
случаю правой ассоциации.Итак, имея на входе
</p>
<pre>
                         expr - expr

</pre>
<p>
     разборщик может пойти  двумя  разрешенными  путями  :  начать  со
сдвига  или  начать со свертки ,  и не имеет возможности выбрать между
ними.Эта ситуация называется конфликтом  сдвига/свертки.Конфликт может
произойти   также   ,  если  разборщик  должен  выбирать  между  двумя
альтернативными видами свертки  ;  такая  ситуация  ,  как  не  трудно
догадаться  ,  называется конфликтом свертки/свертки.Кстати,  отметим,
что конфликта типа "сдвиг/сдвиг" в природе не существует.
</p>
<p>
     Если встречаются конфликты типа сдвиг/свертка или свертка/свертка
,  YACC все еще способен построить работоспособный разборщик.Он  может
сделать  выбор  между двумя разрешенными шагами.Правило ,  которым при
этом руководствуется система,  называется правилом непротиворечивости.
</p>
<p>
     YACC поддерживает правила непротиворечивости двух типов:

</p>
<p>
     1.При конфликте сдвиг/свертка по умолчанию выбирается сдвиг;
</p>
<p>
     2.Конфликт свертка/свертка  разрешается  по  умолчанию  в  пользу
более раннего грамматического правила.

</p>
<p>
     Правило 1 подразумевает,  что конфликт между сдвигом и сверткой ,
когда бы он ни  встретился,  разрешается  в  пользу  сдвига.Правило  2
позволяет   пользователю  самому  влиять  на  поведение  разборщика  в
соответствующей ситуации,  но лучше все-таки избегать конфликтов  типа
свертка/свертка.
</p>
<p>
     Конфликты могут возникать по причине ошибок ввода  или логических
ошибок  ,  или  если  грамматические  правила  требуют  более сложного
алгоритма разбора,  чем тот , который может быть смоделирован системой
YACC.Использование   действий  внутри  правил  также  может  послужить
причиной конфликта ,  особенно если это действие  выполняется  еще  до
того,   как  разборщик  полностью  распознает  правило.В  этом  случае
применение правил непротиворечивости крайне нежелательно,  ибо ведет к
построению   некорректного  разборщика.По  этой  причине  YACC  всегда
сообщает о количестве конфликтов типа сдвиг/свертка и свертка/свертка,
встреченных и обработанных при помощи правил 1 и 2.
</p>
<p>
     В целом же,  чем применять уточняющие правила  непротиворечивости
для   построения   корректного   разборщика,   лучше  переписать  сами
грамматические правила для того же  входного  потока.По  этой  причине
большинство других генераторов разборщиков рассматривают конфликты как
фатальные  ошибки.Однако,  наш  опыт  подсказывает,  что  в  отдельных
случаях  переписывание  заново  правил  неэффективно,  неестественно и
иногда ведет к существенному замедлению процесса разбора; поэтому YACC
обычно   завершает   построение   разборщика,  даже  если  встретились
конфликты.
</p>
<p>
     В качестве   примера   возможностей   правил   непротиворечивости
рассмотрим фрагмент языка  программирования,  содержащего  конструкции
"если-то-иначе":
</p>
<pre>
               stat :    IF '(' cond ')' stat
                    |    IF '(' cond ')' stat ELSE stat
                    ;

</pre>
<p>
     В этом  правиле  IF  и  ELSE  это токены ,  cond - нетерминальный
символ,  описывающий  оператор.Первая  часть   правила   соответствует
простому случаю "если", вторая часть - случаю "если-иначе".
</p>
<p>
     Эти две формы правил - многозначные,  двусмысленные  конструкции,
поскольку входная строка вида
</p>
<pre>
               IF ( C1 ) IF ( C2 ) S1 ELSE S2

</pre>
<p>
     может быть интерпретирована как
</p>
<pre>
               IF ( C1 ) { IF ( C2 ) S1 } ELSE S2

</pre>
<p>
     и как
</p>
<pre>
               IF ( C1 ) { IF ( C2 ) S1 ELSE S2 }.

</pre>
<p>
     Вторая интерпретация    общепринята    для   большинства   языков
программирования,   содержащих   подобные   конструкции.Каждое    ELSE
ассоциируется  с  последним предшествующим IF ,  у которого нет своего
ELSE.В данном примере рассмотрим ситуацию, когда разборщик встречает
</p>
<pre>
               IF ( C1 ) IF ( C2 ) S1

</pre>
<p>
     и ищет ELSE.  Эта строка может быть непосредственно  редуцирована
( подвержена свертке ) согласно правилу простого "если":
</p>
<pre>
                         IF (C1) stat

</pre>
<p>
     и затем произошло бы чтение оставшегося
</p>
<pre>
                           ELSE S2
</pre>
<p>
     и редуцирование до
</p>
<pre>
               IF ( C1 ) stat ELSE S2

</pre>
<p>
     по правилу  "если-иначе".Это   соответствует   первому   варианту
группировки элементов.
</p>
<p>
     В другом случае ELSE может быть сдвинуто ,  прочитано S2 и правая
часть выражения
</p>
<pre>
               IF ( C1 ) IF ( C2 ) S1 ELSE S2

</pre>
<p>
     может быть редуцирована по правилу "если-иначе" до
</p>
<pre>
                         IF (C1) stat

</pre>
<p>
     ,что может быть также редуцировано посредством применения правила
простого "если".Это ведет ко  второму  варианту  группировки,  который
более предпочтителен.
</p>
<p>
     Кроме того,    разборщик     способен     разрешать     конфликты
сдвига/свертки.Применение однозначного правила 1 требует от разборщика
применить  в  данном  случае  сдвиг,  и  это   приведет   к   желаемой
интерпретации.
</p>
<p>
     Это происходит,  только если конкретный символ ELSE попадается  в
структуре вида
</p>
<pre>
                      IF (C1) IF (C2) S1   .

</pre>
<p>
     В целом здесь может быть много конфликтов,  и каждый из них будет
соответствовать как текущему входному символу,  так и множеству  ранее
прочитанных  входных  данных.Предыдущие входные данные характеризуются
состоянием разборщика.
</p>
<p>
     Сообщения о  конфликтах  дают  наиболее  полную информацию,  если
процесс разбора запущен с ключом (-v).Например,  выходное сообщение  о
конфликте может иметь вид:

</p>
<pre>
     23: shift/reduce conflict (shift 45, reduce 18) on ELSE

     state 23
          stat : IF ( cond ) stat_      (18)
          stat : IF ( cond ) stat_ELSE stat

          ELSE shift 45
          . reduce 18
</pre>
<p>
     Первая строка   описывает   конфликт,сообщая  также  состояние  и
входной  символ.Обычно  описание  состояния  снабжается   ссылкой   на
активные   в   данном  состоянии  грамматическое  правило  и  действие
разборщика.Вспомним,что   знак   подчеркивания   "_"   -   это   часть
грамматического  правила,которое  только  что  было  прочитано.В нашем
примере в состоянии 23 разборщик прочитал на входе
</p>
<pre>
                        IF (cond) stat

</pre>
<p>
     ,и активны два грамматических правила.Разборщик  может  поступить
двояко.Если  входной  символ  ELSE,то  ,возможно,  произойдет  сдвиг к
состоянию 45.Состояние 45 будет содержать как часть описания строку
</p>
<pre>
                stat: IF (cond) stat ELSE stat
</pre>
<p>
    ,пока ELSE не будет сдвинуто в это состояние.
</p>
<p>
     Возвращаясь к   состоянию  23  ,  заметим  ,  что  альтернативное
действие описано точкой ".";  это происходит ,  если входной символ не
упомянут  просто  в  предыдущих  действиях;  итак  ,если в этом случае
входной символ - не ELSE, то разборщик построит грамматическое правило
18:
</p>
<pre>

                  stat: IF '(' cond ')' stat

</pre>
<p>
     Eще раз отметим,  что команды сдвига относятся к состояниям, в то
время как команды свертки - к номерам грамматических правил.
</p>
<p>
     В файле  y.output  номера  правил  печатаются  после  тех правил,
которые могут быть подвержены  свертке.В  большинстве  состояний,  где
количество  возможных  сверток  максимально,  они  являются командами,
выполняемыми по умолчанию.Пользователь,  который встречает неожиданный
конфликт сдвига/свертки,захочет,  вероятно, посмотреть на многословный
выход для определения того,  действительно ли выполнилась  команда  по
умолчанию.В  тяжелых случаях пользователь может захотеть больше узнать
о  о  конструкции  и  поведении  разборщика.Тогда  ему   рекомендуется
проконсультироваться в [2,3,4] ; может быть также полезен опыт местных
"гуру".
</p>

<h2>

                 6. Предварительные замечания

</h2>

<p>
     Существует типичная  ситуация,  когда  правила,   добавленные   в
спецификацию для устранения конфликтов,  не являются достаточными; она
часто возникает при разборе  арифметических  выражений.Наиболее  часто
встречается     конструкция    арифметических    выражений,    которая
характеризуется  помещением  операндов  перед  операторами  вместе   с
информацией  о левой или правой ассоциации.Это выключает двусмысленные
грамматики с соответствующими  однозначными  правилами  и  может  быть
использовано  для  написания разборщиков ,  которые работают быстрее и
легче  конструируются,  чем  разборщики  со  строго  непротиворечивыми
грамматиками.Основная идея состоит в том,  чтобы писать грамматические
правила в виде:
</p>

</pre>
                     expr : expr OP expr
</pre>

 и

<pre>
                      expr : UNARY expr
</pre>

<p>
     для всех желательных унарных  и  бинарных  операций. Это  ведет  к
использованию  довольно противоречивых грамматик с большим количеством
конфликтов.Вместо    однозначных    правил     пользователь     задает
предварительные замечания для всех операторов и правила ассоциации для
всех бинарных операторов.Эта информация  достаточна  для  того,  чтобы
позволить  системе  YACC  разрешить  конфликты  разбора  вместе  с  их
правилами и сконструировать разборщик,  который  использует  указанные
предварительные замечания и ассоциации.
</p>
<p>
     Предварительные замечания  и  ассоциации  помещаются   в   секции
описаний.Это  делается при помощи ряда строк,  начинающихся с ключевых
слов системы  YACC:%left,%right  и  %nonassoc,  следующих  за  списком
токенов.Все  токены,  на  которых  они  ссылаются,  имеют определенный
уровень предварения и ассоциации;такие строки помещаются  в  список  в
порядке возрастания этого уровня.Так, строки
</p>
<pre>
                        %left '+' '-'
                        %left '*' '/'
</pre>
<p>
     описывают предварения   и   ассоциации   четырех   арифметических
действий.Сложение  и вычитание описываются правилом левой ассоциации и
имеют меньший приоритет,  чем правила  умножения  и  деления,  которые
также   левоассоциированы.Ключевое   слово   %right  используется  для
описания правой ассоциации,  а ключевое слово %nonassoc - для описаний
знакосочетаний   типа   .LT.   в   Фортране,   которые   не  поддаются
ассоциации.Так, выражение
</p>
<pre>
                       A .LT. B .LT. C

</pre>
<p>
     недопустимо по правилам Фортрана ,и каждый такой  оператор должен
быть снабжен описателем %nonassoc.В качестве примера приведем описание
</p>
<pre>
               %right    '='
               %left     '+' '-'
               %left     '*' '/'

               %%

               expr :    expr '=' expr
                    |    expr '+' expr
                    |    expr '-' expr
                    |    expr '*' expr
                    |    expr '/' expr
                    |    NAME
                    ;

</pre>
<p>
     , которое может использоваться для структуры ввода типа
</p>
<pre>
                        a=b=c*d-e-f*g

</pre>
<p>
     и интерпретировать ее как
</p>
<pre>
                   a=(b=(((c*d)-e)-(f*g)))

</pre>
<p>
     Когда используется этот механизм,  унарные операторы должны быть,
в   общем,  снабжены  предварительными  замечаниями.Иногда  унарный  и
бинарный операторы имеют одинаковое  символическое  представление,  но
различные  предварительные замечания.В качестве примера можно привести
унарный и бинарный минус "-" ;  унарный минус  может  иметь  приоритет
выше,   чем   умножение,   бинарный   же  всегда  имеет  более  низкий
приоритет.Ключевое слово %prec изменяет уровень приоритета какого-либо
грамматического  правила.Это  ключевое  слово появляется исключительно
после тела грамматического правила,  перед действием  или  заключающей
запяточкой,  и  сразу  после  имени токена или литерала.Это приводит к
тому,  что  предварения  грамматических  правил  предшествуют   именам
токенов  и  литералам.Например,  если снабдить унарный минус такими же
предварительными заиечаниями,  что и умножение,  то эти правила  будут
похожи:
<p>
<pre>

               %left     '+' '-'
               %left     '*' '/'
               %%
               expr :    expr '+' expr
                    |    expr '-' expr
                    |    expr '*' expr
                    |    expr '/' expr
                    |    '-' expr       %prec '*'
                    |    NAME
                    ;


</pre>
<p>
     Токены, описанные  посредством  ключевых  слов   %left,%right   и
%nonassoc  не  обязательно  имеют,  но  могут  иметь описание ключевым
словом %token.
</p>
<p>
     Предварения и   ассоциации   используются   системой   YACC   для
разрешения    конфликтов    разбора;    они    увеличивают    "степень
однозначности" правил.Формально правила работают следующим образом:
</p>
<p>
     1.Предварения и  ассоциации  регистрируются   теми   токенами   и
литералами , которым принадлежат.
</p>
<p>
     2.Предварения и  ассоциации  поставлены  в  соответствие  каждому
грамматическому  правилу,  это  предварение  или ассоциация последнего
токена или литерала в теле правила.Если используется конструкция %prec
,  то  она  замещает  действие по умолчанию.  Некоторые грамматические
правила могут не иметь предварительных замечаний и ассоциаций.
</p>
<p>
     3.Когда встречается   конфликт  типа  сдвиг/свертка  и  при  этом
грамматическое  правило  и  входной   символ   имеют   предварение   и
ассоциацию,  то  конфликт  разрешается  в  пользу действия ( сдвиг или
свертка ), имеющего наивысший приоритет.Если предварения совпадают, то
используются   правила   ассоциации;  левая  ассоциация  подразумевает
свертку, правая - сдвиг; отсутствие таковых ведет к ситуации отказа.
</p>
<p>
     Конфликты, разрешенные  применением  правила  предшествования  не
подсчитываются системой  YACC  и  информация  о  них  не  выдается.Это
означает,  что  ошибки  в  спецификации предварительных описаний могут
маскировать ошибки во входной грамматике;хорошей идеей следует считать
технологию,  когда предварительные замечания экономятся и используются
только в необходимых случаях по мере приобретения  опыта.Файл y.output
очень  удобен для определения того,  действительно ли разборщик делает
то, что должен.
</p>
<h2>

                       7. Обработка ошибок

</h2>
<p>
     Обработка ошибок лежит в исключительно сложной области,  и многие
проблемы  возникают вследствие семантических ошибок.  Когда обнаружена
ошибка,  бывает  иногда  необходимо  просмотреть  всю  память   дерева
разбора,   уничтожить   или  изменить  таблицу  символьных  входов  и,
возможно,  установить  ключи,  чтобы  избежать  генерации  дальнейшего
вывода.
</p>
<p>
     Достаточно редко встречается случай останова всей обработки, если
обнаружена  ошибка;  более  удобно  продолжить  сканирование  входного
потока,  чтобы  найти  будущие  синтаксические  ошибки.  Это  ведет  к
проблеме  рестарта  разбора после ошибки.  Этим занимается целый класс
алгоритмов,  которые удаляют некоторые  токены  из  входной  строки  и
пытаются привести разборщик в порядок,  чтобы ввод был продолжен. Уасс
снабжает пользователя простым,  но действенным средством  контроля  за
процессом обработки.  Имя токена "error" зарезервировано для обработки
ошибок. Это имя может быть использовано в грамматических правилах, это
позволяет  отметить  точки,  в  которых возможно возникновение ошибок.
Разборщик вталкивает в стек,  пока находится в состояниях,  где  токен
"error"  допустим.  Он  ведет  себя,  как  если  бы  токен "error" был
непосредственно следующим токеном и выполняет необходимое действие ,не
считая  его номер.  Последующий токен при этом получает статус токена,
вызвавшего ошибку.  Если нет специальных правил  обработки  ошибок  то
обработка прерывается, как только ошибка детектируется.
</p>
<p>
     Для того,  чтобы предотвратить каскад предупреждений об  ошибках,
разборщик  после детектирования ошибки остается в этом состоянии, пока
какие-нибудь следующие три токена не  сдвинуться  или  не  прочитаются
успешно. В момент, когда детектируется ошибка, разборщик уже находится
в состоянии отказа, но сообщение об ошибке не выдается и входной токен
тихонько удаляетс
</p>
<p>
    Например, для правила вида
</p>
<pre>
                            stat : error

</pre>
<p>
     будет выполнена попытка пропустить оператор, в котором встретилаь
ошибка. Более точно, разборщик будет сканировать, глядя на три токена,
которые могут легально следовать за оператором ,и  выполнять обработку
первого  из  них;  если  начала  операторов  не  слишком  различаются,
разборщик может и выдать ошибку, когда ее нет.
</p>
<p>
     Определенные действия    могут    выполняться   под   управлением
специальных правил. Эти действия могут попытаться переинициализировать
таблицы, очистить таблицы символов и т.п.
</p>
<p>
     Правила обработки ошибок имеют  общий  характер,  но  сложны  для
контроля. Несколько более легкими являются правила вида
</p>
<pre>
                           stat : error;

</pre>
<p>
     Здесь, если  встречается  ошибка,  разборщик  пытается пропустить
оператор,  но будет делать это,  пропуская очередную точку  с  запятой
";".  Все  токены  после  error,  но перед ";" не смогут подвергнуться
операции сдвига и исключаются из таблицы.  Когда обнаружится  ";"  это
правило   будет   редуцировано   и   все   "очистительные"   действия,
соответствующие ему, будут выполняться.
</p>
<p>
     Другая форма   ошибочных   правил   проявляется  в  интерактивных
режимах,  где желательно,чтобы после ввода  неправильной  строки  была
возможность  переввести  ее заново.  Возможное правило может выглядеть
так:
<p>
<pre>

               input:    error '\n'
                              { printf( "Reenter last line: " ); }
                         input
                              { $$ = $4; }
                    ;


</pre>
<p>
     Существует одна потенциальная трудность в этом вопросе; разборщик
должен  правильно  обрабатывать три входных токена после ошибки.  Если
заново введенная строка содержит ошибки  в  первых  двух  токенах,  то
разборщик уничтожит эти токены и не сообщит об этом;  это неприемлемо.
В этом случае существует механизм,  который может быть использован для
того,  чтобы  заставить  разборщик поверить в то,  что ошибка была уже
полностью исправлена. оператор
</p>
<pre>
                                yerrok ;

</pre>
<p>
     внутри действия  сбрасывает  разборщик  в  нормальное  состояние.
Последний пример лучше было бы написать так:
</p>
<pre>
               input:    error '\n'
                              { yyerrok;
                                printf( "Reenter last line: " );
                              }
                         input
                              { $$ = $4; }
                    ;


</pre>
<p>
     Как указывалось ранее,  токен, обнаруженный непосредственно после
символа  "error" - это токен,  в котором скрывается ошибка.  Но иногда
это не выполняется,  например,  действие восстановления  ошибок  может
взять  на  себя  работу  по  поиску подходящей точки для возобновления
ввода.  В этом случае последующий токен на предыдущем шаге должен быть
очищен. Оператор
</p>
<pre>
                         yyclearin ;

</pre>
<p>
     в действии  выполняет  эту  работу.  Например,  предположим,  что
действие после ошибки состоит в том,  что вызывается сложная процедура
восстановления   временной  синхронизации,  написанная  пользователем,
которая  пытается  продвинуть  входной  поток  к   началу   следующего
допустимого   оператора.   После  того,  как  эта  процедура  вызвана,
следующий токен,  вызванный в переменной yylex, будет предположительно
первым токеном правильного оператора;  старый, ошибочный, токен должен
быть удален и состояние ошибки сброшено.  Это можно сделать  следующим
образом:
</p>
<pre>
               stat :    error
                         { resynch(); yyerrok ; yyclearin ; }
                    ;

</pre>
<p>
     Предложенный механизм  выглядит несколько грубым и прямолинейным,
но позволяет относительно просто и эффективно  восстанавливать  разбор
после многих ошибок;  более того, пользователь может брать в некоторых
случаях управление на себя.
</p>
 <h2>
                       8. Среда системы Yacc

</h2>
<p>
     Когда пользователь вводит спецификации системы Yacc, то на выходе
- файл программы на языке Си,  называемый Y.tab.c в большинстве систем
(в зависимости от принятых соглашений в общем случае имена  могут быть
различными).  Функция,  построенная системой Yacc, именуется yyparse ;
это целочисленная функция.  Когда она вызывается,  то в  свою  очередь
обращается  к  функции yylex,  лексическому анализатору,  применяемому
пользователем (см.главу 3) для приема входных токенов. В конце концов,
даже   если   есть   ошибки,   в   этом  случае  (если  невозможно  их
восстановление) функция ### возвращает  значение  1,  или  лексический
анализатор  возвращает токен метки конца и разборщик воспринимает его.
Этот случай соответствует возвращаемому 0.
</p>
<p>
     Пользователь должен  снабжать  определенной  суммой  разборщик  в
порядке получения работающей программы. Например, как и в случае любой
программы на Си,  программа,  именуемая main должна быть описана, но в
конце  концов  она  вызывает  yyparse.  Процедура   yyerror   печатает
сообщение, если встречается ошибка.
</p>
<p>
     Эти две процедуры в том или ином  выде  должны  быть  обязательно
использованы.  Для  облегчения  использования  и изучения системы Yacc
библиотека снабжена стандартными версиями процедур main и yyerror. Имя
этом  библиотеки  зависит от системы;  в большинстве систем библиотека
снабжена   аргументом   -ly   для   загрузчика.   Для   того,    чтобы
продемонстрировать простоту этих стандартных программ, исходные тексты
приведем ниже:
</p>
<pre>

               main()
               {
                    return( yyparse() );

               }
</pre>
и
<pre>
               # include <stdio.h>
               yyerror(s)
               char *s;
               {
                    fprintf( stderr, "%s\n", s );
               }

</pre>
<p>
     Агрумент функции yyerror - это строка,  содержащая  сообщение  об
ошибке,  обычно  это  "syntax  error".  Обычно бывает желательно иметь
больше,  чем такое простое сообщение.  Например, неплохо было бы иметь
трассу,  содержащую номера входных строк, и печатать эти номера вместе
с сообщениями об ошибках.  Внешняя переменная  yychar  содержит  номер
последующего токена в то время, когда обнаруживается ошибка; это может
быть полезно при расширении диагностики.  Поскольку главная программа,
вероятно, используется пользователем гораздо шире (например, для ввода
аргументов),  то библиотека системы Yacc  удобна  только  в  небольших
проектах или на ранних стадиях программирования.
</p>
<p>
     Внешняя целая переменная yydebug нормально установлена в  0. Если
она  имеет  ненулевую величину,  то разборщик будет выводить подробную
трассу своих действий, включая то, какой входной символ прочитан и что
разборщик в связи с этим делает.  В зависимости от операционной среды,
может  быть  возможным  устанавливать  значение  этой  переменной  под
отладчиком.
</p>
<h2>
              9. Замечания по подготовке спецификаций

</h2>
<p>
     Эта глава   содержит   разнообразные   замечания   по  подготовке
эффективных, легких для применения, правильных спецификаций. Отдельные
части главы более или менее независимы друг от друга.
<p>
<h3>
    Стиль ввода.
</h3>
<p>
     Снабдить правила действенными корректными  действиями  достаточно
трудно,  так  же  сложно  обеспечить читабельность файла спецификаций.
Следующие замечания во  многом  основываются  на  разработках  Брайана
Кернигана.
</p>
<p>
     а) Используйте заглавные буквы для имен токенов  и  строчные  для
нетерминалов.  Это правило позволяет быстро найти точку, где программа
"пошла криво".
</p>
<p>
     б) Помещайте грамматические правила и действия на разных строках.
Это позволит вносить изменения без перелопачивания текста.
</p>
<p>
     в) Помещайте   все   правила  с  одинаковой  левой  чатью  рядом.
Используйте форму с вертикальной чертой.
</p>
<p>
     г) Помещайте  запяточку  только  после последнего правила с левой
частью,  и помещайте  ее  на  отдельной  строке.  это  позволит  легко
добавить новые правила.
</p>
<p>
     д) Отделяйте тело правила одной табуляцией,  а действие  -  тремя
табуляциями.
</p>
<p>
     Пример в приложении А написан с использованием этого стиля, как и
все ранее приведенные примеры. Пользователь должен составить мнение об
этих стилистических  замечаниях;  главное,  конечно,  уметь  зрительно
отделить правила от действий.
</p>
<h3>
    Левая рекурсия.

</h3>
<p>
     Алгоритм, используемый  системой  Yacc,  поощряет  грамматические
правила,  которые легко разбираются по правилу  левой  рекурсии;  т.е.
правила вида
</p>
<pre>
                     имя : имя тело_правила;

</pre>
<p>
     Такие правила  часто  встречаются  при написании спецификаций для
последовательностей и списков:
</p>
<pre>
               list :    item
                    |    list ',' item
                    ;
</pre>

    ,и
<pre>
               seq  :    item
                    |    seq item
                    ;

</pre>
<p>
     В этих  случаях,  первое  правило  будет  редуцировано до первого
item,  а второе будет  редуцировано  до  второго  и  всех  последующих
вхождений item.
</p>
<p>
     Если встречаются правила,  написанные  в  соответствии  с  правой
рекурсией:
</p>
<pre>
               seq  :    item
                    |    item seq
                    ;

</pre>
<p>
     то разборщик должен читать и редуцировать  элементы  налево.  При
этом   существует   опасность   переполнения  стека  в  случае  чтения
достаточно длинных последовательностей.  С  этой  точки  зрения  левая
рекурсия предпочтительней.
</p>
<p>
     Заслуживает внимания  вопрос,  имеет  ли   последовательность   с
нулевыми  элементами  важное  значение  и  не  лучше  ли разбирать эту
последовательность, как пустую.
</p>
<pre>
               seq  :    /* empty */
                    |    seq item
                    ;

</pre>
<p>
     Первое правило будет  редуцировано  перед  тем,  как  прочитается
первый item, а далее второе правило будет редуцировано еще для каждого
прочитанного item. Разрешение пустых последовательностей часто ведет к
возрастанию общности. Зато конфликты могут возникать, только если Yacc
решает разобрать пустую последовательность, когда ее нет вообще.
<p>
<h3>
    Связь с лексическим анализатором.
</h3>
<p>
     Решения, которые принимаются лексическим анализатором,  во многом
зависят  от контекста.  Например,  лексический анализатор может хотеть
исключить пробелы во всех строках, кроме некоторых. Или другой случай:
имена  могут  быть  помещены  в  символьную  таблицу  описаний,  но не
помещены в таблицу выражений.
</p>
<p>
     Одной из  возможностей  обрабатывать  подобные  ситуации является
заведение глобального флага,  состояние которого известно лексическому
анализатору  и который может выставляться или сбрасываться действиями.
Например,  предположим,  что  программа  состоит  из   0   или   более
деклараций, следующих за 0 или более операторами. Рассмотрим следующий
текст:
</p>
<pre>

               %{
               int dflag;
               %}
               ... other declarations ...
               %%

               prog :    decls stats
                    ;
               decls:    /* пусто */
                              { dflag = 1; }
                    |    decls declaration
                    ;
               stats:    /* пусто */
                              { dflag = 0; }
                    |    stats statement
                    ;
                    ... other rules ...


</pre>
<p>
     Флаг dflag имеет значение 0 во время чтения операторов и значение
1 во время чтения деклараций, исключая первый токен первого оператора.
Этот токен должен быть прочитан разборщиком перед тем,  как он  сможет
определить,  что  секция  деклараций  завершилась  и  началась  секция
операторов.  Во многих случаях этот исключительный токен не влияет  на
лексическое сканирование.
</p>
<p>
     Подобные приемы   должны   быть   тщательно    продуманы    перед
использованием.  Тем  не  менее,  они могут позволить сделать то,  что
иными средствами недостижимо.
<p>
<h3>
    Зарезервированные слова.

</h3>
<p>
     Некоторые языки    программирования    разрешают     пользователю
использовать  слова типа "if",  которые обычно бывают зарезервированы,
как имена меток и переменных; при этом не возникает конфликта между их
стандартным использованием и использованием такого рода.  Но это очень
тяжело реализовать в  среде  системы  Yacc;  сложности  возникают  при
лексическом анализе,  когда невозможно отличить ключевое слово "if" от
переменной "if".  Пользователь может разрешить противоречие, используя
механизм, описанный ниже, но это достаточно сложно.
</p>
<p>
     Там представлен ряд рекомендаций, как выполнить это. Это возможно
для  словосочетаний,  зарезервированных  в качестве ключевых слов,  но
запрещено для имен переменных. Сему немало причин.
</p>
<h2>
                   10. Дополнительные возможности

</h2>
<p>
     В этой главе  обсуждаются  некоторые  дополнительные  возможности
системы Yacc.
</p>
<h3>
    Имитация ситуаций Error и Accept.

</h3>
<p>
     Ситуации разбора  Error  и Accept могут быть искусственно вызваны
использованием  макросов  YYACCEPT  и  YYERROR.  YYACCEPT   заставляет
функцию  YYPARSE  возвратить значение 0;  YYERROR заставляет разборщик
вести себя так,  словно текущий входной символ содержит синтаксическую
ошибку;  вызывается  функция  YYERROR и включается процесс исправления
ошибки.  Этот механизм может быть использован при имитации  разбора  в
случае множественных меток конца или в случае сложных контекстов.
</pre>
<h3>
    Доступ к значениям в отмеченных правилах.

</h3>
<p>
     Действие может   ссылаться   на  значения,  возвращаемые  другими
действиями в левую часть текущего правила. Этот механизм такой же, как
в обычных действиях; здесь знак доллара $ следует за числом, но только
в этом случае число может быть 0 или отрицательным.
</p>
<pre>
               sent :    adj noun verb adj noun
                              { look at the sentence ... }
                    ;
               adj  :    THE
                              { $$ = THE; }
                    |    YOUNG
                              { $$ = YOUNG; }
                         . . .
                    ;
               noun :    DOG
                              { $$ = DOG; }
                    |    CRONE
                              { if( $0 == YOUNG ) printf( "what?\n" );
                                $$ = CRONE;
                              }
                    ;
                            . . .

</pre>
<p>
     В действии,  следующем за словом CRONE, проверка выполняется так,
что предыдущий сдвинутый токен - не YOUNG.  Очевидно, что это возможно
только   если   известно,   что   предшествующий  символ  играет  роль
существительного. Так же ясно, что про этот пример нельзя сказать, что
он  написан структурно.  Но иногда этот механизм может спасать процесс
разбора от ошибок,  особенно если некоторые комбинации  предполагается
исключить из регулярной структуры.
<p>
<h3>
    Поддержка абстрактных типов.

</h3>
<p>
     По умолчанию  значения,  возвращаемые  действиями  и  лексическим
анализатором - целые.  Yacc так же поддерживает величины других типов,
включая  структуры.  Кроме  того,  Yacc  поддерживает  внешние  типы и
элементы об'единений для разных  модулей,  что  позволяет  в  конечном
счете  разборщику  осуществлять контроль за структурированными типами.
Стек значений системы Yacc описан так,что является общим для различных
типов  значений.  Пользователь  декларирует это об'единение и ставит в
соответствие  имена  его  членов  каждому  токену  и   нетерминальному
символу, который требует этого. Если значение ссылается на конструкции
$$ или $n, то Yacc автоматически вставляет подходящее имя об'единения,
так  что  нежелательные  преобразования  типов  исключены.  Кроме того
,команды контроля типов (см.Линт [5]) принесли бы здесь гораздо меньше
пользы.
</p>
<p>
     Существует три механизма,  позволяющие  осуществлять  контроль  и
преобразование типов.
</p>
<p>
     Первый -   это   механизм   описания   об'единения;   он   должен
использоваться  раньше  написания  всех  программ,  кроме лексического
анализатора, в которых необходимо знание имен общих членов.
</p>
<p>
     Второй -   это   механизм   установки  соответствия  имен  членов
об'единения с токенами и нетерминалами.
</p>
<p>
     И, наконец, третий - это механизм описания сложных типов.
</p>
<p>
     Для того,  чтобы  описать   об'единение   (смесь),   пользователь
включает в секцию декларации:
</p>
<pre>
                   % union { тело об'единения...}

</pre>
<p>
     Отныне стек  значений  системы  Yacc,  а также внешние переменные
yylval и yyval будут способны содержать элементы этого типа. Если Yacc
запущен с ключом -d , то описание об'единения копируется в файл y.tab.
h.  Наоборот,  об'единение может быть  описано  в  главном  модуле,  а
ключевое  слово  typedef  использоваться  для  определения  переменной
YYSTYPE,  представляющей это об'единение.  Так в головном файле должно
содержаться:
</p>
<pre>
               typedef union { body of union ... } YYSTYPE;

</pre>
<p>
     Если YYSTYPE  описана,  то  имена  членов  об'единения могут быть
поставлены  в  соответствие  различным  терминалам   и   нетерминалам.
Конструкция
</p>
<pre>
                              &lt;имя&gt;

</pre>
<p>
     используется для  указания  имени  члена  об'единеения.  Если она
следует за одним из ключевых  слов  типа  %token,  %left,  %right  или
%nonassoc,  то имя члена об'единения ставится в соответствие указанным
в списке токенам. Так, использовав описание
</p>
<pre>
                    %left &lt;optype&gt; '+' '-'

</pre>
<p>
     получим ссылку на значения,  возвращаемые этими двуми токенами со
стороны  элемента  под именем optype.  Другое ключевое слово - %type -
используется  для  установки  соответствия  элемента   об'единения   с
нетерминалом. Например, можно написать
</p>
<pre>
                  %type &lt;nodetype&gt; expr stat

</pre>
<p>
     Правда, остаются два случая,  когда эти механизмы не срабатывают.
Если имеется действие без  правила,  то  значения,  возвращаемые  этим
действием,  не  имеют  априорного типа.  Подобным же образом ссылка на
значение левого контекста (например - на $0 - см.  предыдущий,  пункт)
не  оставляет  системе Yacc возможности определить тип.  В этом случае
тип может быть принудительно установлен  по  ссылке  на  имя  элемента
об'единения,  между  &lt;and&gt;  и непосредственно после первого символа $.
Пример этого использования выглядит так:
</p>
<pre>

               rule :    aaa
                              { $&lt;intval&gt;$ = 3; }
                         bbb
                              { fun( $&lt;intval&gt;2, $&lt;other&gt;0 ); }
                    ;


</pre>
<p>
     Этот синтаксис  не  рекомендуется  применять  часто,   только   в
исключительных случаях.
</p>
<p>
     Простая спецификация  предложена  в   Приложении   С.   Средства,
описанные  в  этом  подпункте,  не  требуют  какого-либо  "включения";
использование словосочетания %type автоматически задействует их. Когда
они  используются,  включается  четкий  механизм  контроля.  Например,
использование  $n  и  $$   для   ссылки   на   что-либо   неописанное,
диагностируется  сразу.  Если  же  эти  средства  не подключены,  стек
значений системы Yacc содержит только целые величины.
</p>
<h2>
                         11. Благодарности

</h2>
<p>
     Существование системы  Yacc  стимулирует  деятельность  множества
пользователей,  которые  требуют  от  меня сверх моего желания и часто
сверх моих возможностей включения в систему "еще одного  средства". Их
раздражительное  нежелание  следовать  моим рецептам обычно приводит к
тому, что я начинаю следовать их рецептам; а потом выясняется, что они
были   правы.   Б.В.Керниган   (Kernighan),   П.Дж.Плоджер  (Plauger),
С.И.Фельдман (Feldman), С.Имагна (Imagna), М.Е.Леск (Lesk) и А.Шнайдер
(Snyder)  могут  обнаружить  многие  свои  идеи  в предлагаемой версии
системы Yacc.  С.Б.Хэлей (Haley)  способствовал  разработке  алгоритма
исправления  ошибок.  Д.М.Ритчи  (Ritchie),  Б.В.Керниган и М.О.Харрис
(Harris) помогли перевести этот документ на английский язык.  Эль  Ахо
(Al Aho) заслужил особый кредит за то, что привел гору к Магомеду и за
другие заслуги.
</p>
<pre>
                     ЛИТЕРАТУРА

</pre>
<ol>
     <li> B.  W.  Kernighan D.  M.  Ritchie, The C Programming Language,
Prentice-Hall, Englewood Cliffs, New Jersey (1978).
     <li> A.  V. Aho S. C. Johnson, "LR Parsing," Comp. Surveys Vol. 6(2)
pp. 99-124 (June 1974).
     <li> A. V. Aho, S. C. Johnson, J. D. Ullman, "Deterministic Parsing
of Ambiguous Grammars,"  Comm.  Assoc.  Comp.  Mach.  Vol.  18(8)  pp.
441-452 (August 1975).
     <li> A. V. Aho J. D. Ullman, Principles of Compiler Design, Addison
-Wesley, Reading, Mass. (1977).
     <li> S.  C.  Johnson, "Lint, a C Program Checker," Comp. Sci. Tech.
Rep. No. 65 (1978). updated version TM 78-1273-3
     <li> S.  C.  Johnson,  "A Portable Compiler:  Theory and Practice,"
Proc. 5th ACM Symp. on Principles of Programming Languages, pp. 97-104
(January 1978).
     <li> B.  W.  Kernighan  L.  L.  Cherry,  "A  System for Typesetting
Mathematics," Comm.  Assoc.  Comp.  Mach.  Vol.  18 pp. 151-157 (March
1975).
     <li> M.E.  Lesk,  "Lex - A Lexical Analyzer Generator," Comp.  Sci.
Tech. Rep. No. 39, Bell Laboratories, Murray Hill, New Jersey (October
1975).
</ol>
<h2>
                            ПРИЛОЖЕНИЕ   А
</h3>
<h3>
                            Простой пример

</h3>
<p>
     Этот пример  представляет  собой законченную спецификацию системы
Yacc для маленького настольного калькулятора;  этот калькулятор  имеет
26  регистров,  помеченных от "а" до "z" и воспринимает арифметические
выражения,  составленные из операторов +,  -,  ,  /,  %  (остаток),  &
(логическое  сложение)  и  оператора  присваивания.  Если выражение на
самом верхнем  уровне  есть  операция  присваивания,  то  значение  не
печатается, в противном случае это происходит. Как и в языке Си, целые
константы,  начинающиеся  с  0  воспринимаются  как  восьмеричные;   в
противном случае - как десятичные.
</p>
<p>
     Как пример  спецификаций  системы  Yacc,  настольный  калькулятор
выполняет  отображение  всех  действий  и  двусмысленностей,  а  также
детерминирует простейшую обработку ошибок. Гловное упрощение состоит в
том,  что фаза лексического анализа гораздо примитивней, чем во многих
реальных случаях,  и вывод осуществляется  непосредственно  строка  за
строкой.   Отметим,  что  десятичные  и  восьмеричные  целые  читаются
согласно грамматическим правилам.  Вероятно, это надо было бы поручить
лексическому анализатору.


</p>
<pre>
     %{
     # include &lt;stdio.h&gt;
     # include &lt;ctype.h&gt;

     int regs[26];
     int base;
     %}

     %start list
     %token DIGIT LETTER

     %left '|'
     %left '&'
     %left '+' '-'
     %left '*' '/' '%'
     %left UMINUS /* supplies precedence for unary minus */

     %%        /* beginning of rules section */

     list :    /* empty */
          |    list stat '\n'
          |    list error '\n'
                    { yyerrok; }
          ;

     stat :    expr
                    { printf( "%d\n", $1 ); }
          |    LETTER '=' expr
                    { regs[$1] = $3; }
          ;

     expr :    '(' expr ')'
                    { $$ = $2; }
          | expr '+' expr
                    { $$ = $1 + $3; }
          | expr '-' expr
                    { $$ = $1 - $3; }
          | expr '*' expr
                    { $$ = $1 * $3; }
          | expr '/' expr
                    { $$ = $1 / $3; }
          | expr '%' expr
                    { $$ = $1 % $3; }

          | expr '&' expr
                    { $$ = $1 & $3; }
          | expr '|' expr
                    { $$ = $1 | $3; }
          | '-' expr          %prec UMINUS
                    { $$ = - $2; }
          | LETTER
                    { $$ = regs[$1]; }
          | number
          ;

     number : DIGIT
                    { $$ = $1; base = ($1==0) ? 8 : 10; }
          | number DIGIT
                    { $$ = base * $1 + $2; }
          ;

     %%        /* start of programs */



     yylex()
     {              /* lexical analysis routine */

     /* returns LETTER for a lower case letter, yylval = 0-25 */

     /* return DIGIT for a digit, yylval = 0 through 9 */

     /* all other characters are returned immediately */
          int c;
          while( (c=getchar()) == ' ' ) {/* skip blanks */ }
                    /* c is now nonblank */
               if( islower( c ) ) {
                    yylval = c - 'a'; return ( LETTER );
               }
               if( isdigit( c ) ) {
                    yylval = c - '0'; return( DIGIT );
               }
               return( c );
          }

</pre>

<h2>
                      ПРИЛОЖЕНИЕ В
</h2><h3>
                   Входной синтаксис системы Yacc

</h3>
<p>
     Это приложение представляет собой  описание  входного  синтаксиса
системы Yacc в спецификациях самой системы.  Контекстные зависимости и
пр.  здесь не рассматриваются.  Ирония судьбы, но входная спецификация
системы  Yacc  наиболее  естественно  описывается  в грамматике LR(2);
соответствующая  часть   выполняется,   когда   в   правиле   различим
идентификатор,  и  это  правило  непосредственно следует за действием.
Если  этот  идентификатор  следует  за  двоеточием,  то   это   начало
следующего  правила;  другими  словами - это продолжение определенного
правила,  которое только что выполнило соответствующее  ему  действие.
Как уже реализовано, лексический анализатор смотрит вперед после того,
как увидит  идентификатор,  и  решает,  не  есть  ли  следующий  токен
(пропуская  пробелы,  пустые строки,  комментарии и т.п.) - двоеточие.
Если да,  то он возвращает токен C_IDENTIFIER.  В противном случае  он
возвращает   IDEENTIFIER.   Литералы   (заковыченные  строки)  так  же
возвращаются  под   именем   IDENTIFIERS,   но   никогда   как   часть
C_IDENTIFIERS.
<p>

<pre>
 /* grammar for the input to Yacc */

     /* basic entities */

     %token IDENTIFIER   /* includes identifiers and literals */
     %token C_IDENTIFIER /* identifier (but not literal) followed by
                              colon */
     %token NUMBER       /* [0-9]+ */

     /* reserved words: %type =&gt; TYPE, %left =&gt; LEFT, etc. */

     %token LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION
     %token MARK    /* the %% mark */
     %token LCURL   /* the %{ mark */
     %token RCURL   /* the %} mark */

     /* ascii character literals stand for themselves */


     %start spec

     %%

     spec :    defs MARK rules tail
          ;

     tail :    MARK
                    { In this action, eat up the rest of the file }
          |    /* empty: the second MARK is optional */
          ;

     defs :    /* empty */
          |    defs def
          ;

     def  :    START IDENTIFIER
          |    UNION
                    { Copy union definition to output }
          |    LCURL { Copy C code to output file } RCURL
          |    ndefs rword tag nlist
          ;

     rword:    TOKEN
          |    LEFT
          |    RIGHT
          |    NONASSOC
          |    TYPE
          ;

     tag  :    /* empty: union tag is optional */
          |    '&lt;' IDENTIFIER '&gt;'
          ;

     nlist:    nmno
          |    nlist nmno
          |    nlist ',' nmno
          ;

     nmno :    IDENTIFIER /* NOTE: literal illegal with %type */
          |    IDENTIFIER NUMBER /* NOTE: illegal with %type */
          ;

     /* rules section */

     rules:    C_IDENTIFIER rbody prec
          |    rules rule
          ;

     rule :    C_IDENTIFIER rbody prec
          |    '|' rbody prec
          ;

     rbody:    /* empty */
          |    rbody IDENTIFIER
          |    rbody act
          ;

     act  :    '{' { Copy action, translate $$, etc. } '}'
          ;

     prec :    /* empty */
          |    PREC IDENTIFIER
          |    PREC IDENTIFIER act
          |    prec ';'
          ;

</pre>
<h2>
                    ПРИЛОЖЕНИЕ С
</h2>
<h3>
                        Более сложный пример

</h3>
<p>
     Этот пример  использует  некоторые  дополнительные   возможности,
обсуждаемые  в  главе  10.  Настольный  калькулятор  из  приложения  А
модифицирован   так,   чтобы   реализовывать   плавающую   арифметику.
Калькулятор  понимает  константы  с  плавающей точкой,  арифметические
операции +,  -, , /, унарный минус и - знак присвоения =. Еще он имеет
26  плавающих  переменных,  помеченных от "а" до "z".  Более того,  он
воспринимает интервалы типа
<p>
<pre>
                              ( x, y )  ,

</pre>
<p>
     здесь x меньше или равен y. Существуют 26 интервальных переменных
от  "А" до "Z",  которые также могут быть использованы.  Использование
такое же,  как и в приложении А;  операции присваивания не  возвращают
значений и ничего не печатают; в это время выражения выводят результат
(плавающий или интервальный).
</p>
<p>
     В этом   примере  исследуются  некоторые  интересные  особенности
системы Yacc и языка Си.  Интервалы представляются в  виде  структуры,
состоящей из левой и правой части,  содержащихся в переменных двоичной
точности типа double.  Этой структуре дано новое имя типа - INTERVAL -
с использованием ключевого слова INTERVAL.  Стек значений системы Yacc
может содержать скаляры в форме с  плавающей  точкой,  а  также  целые
(используемые   в   качестве  индексов  массивов).  Отметим,  что  вся
примененная здесь стратегия сильно  зависит  от  наличия  в  языке  Си
средств  поддержки структур и об'единений (смесей).  Фактически многие
из действий состоят в вызове функций,  возвращающих  структуры,  а  не
числа.
</p>
<p>
     Также заслуживает внимания использование  механизма  YYERROR  для
обработки   ошибок   типа:   деление   на   интервал,   содержащий  0,
использование интервала,  представленного в неверном порядке и др. Как
результат  -  механизм  исправления  ошибок задействован для обработки
ошибочной строки без задержки.
</p>
<p>
     Кроме смешивания  типов  в  стеке значений,  эта грамматика также
демонстрирует интересное использование трассировки типов  (скаляров  и
интервалов) в выражениях. Заметим, что скаляр может быть автоматически
"повышен  в  звании"  до  интервала,  если   в   контексте   требуется
интервальное  значение.  Это  приводит  к большому числу конфликтов во
время  обработки  этой  грамматики   системой   Yacc:   например,   18
сдвиг/редуцирование  и  26  редуцирование/редуцирование.  Эту проблему
лучше всего рассмотреть на примере двух строк:
</p>
<pre>
                          2.5 + (3.5 - 4.)
</pre>
и
<pre>
                          2.5 + (3.5 , 4.)

</pre>
<p>
     Отметим, что  число  2.5  используется   во   второй   строке   в
интервальном выражении,  но этот факт не известен разборщику,  пока он
не прочитает запятую;  но число уже прочитано  и  разборщик  не  может
вернуться назад, чтобы изменить его "статус". Т.е. случаются ситуации,
когда необходимо заглянуть  чуть-чуть  вперед,  чтобы  определить,  не
требуется  ли  преобразование  скаляра в интервал.  Возникает проблема
содержания двух правил:  для  числа-скаляра  и  для  числа  в  составе
интервала. Во втором случае правый операнд тоже имеет смысл интервала,
так что преобразование может  быть  выполнено  автоматически,  поэтому
можно  уклониться  от  содержания  двух правил.  Но могут возникнуть и
другие случаи,  конфликт в которых не удастся  разрешить  "бескровно".
Придется  изучать  распечатку  правил,  содержащих  скаляры в подобном
применении;  можно так же поступить  совсем  просто  -  считать  числа
скалярами, пока не требуется явно преобразовывать их в интервалы.
</p>
<p>
     Этот способ обработки множественных типов весьма полезен,  но  не
имеет  широкого  применения.  Если  существует много типов выражениий,
более чем два,  то количество требуемых правил будет возрастать  очень
быстро,   и  разрешение  конфликтов  будет  приобретать  драматический
характер.  Хотя этот пример и имеет  большое  обучающее  значение,  но
более  практично  содержать  указание на тип числа в нем самом,  чем в
грамматическом правиле.
</p>
<p>
     Наконец, пару    слов   о   лексическом   анализе.   Единственной
особенностью является  обращение  к  константам  с  плавающей  точкой.
Библиотечная  процедура  языка Си atof используется для преобразования
из символьной строки  в  число  двоичной  точности.  Если  лексический
анализатор обнаруживает ошибку, то он реагирует возвращением неверного
токена,  провоцирует синтаксическую ошибку в разборщике и  уже  там  -
исправление ошибки.

</p>
<pre>
     %{
     # include &lt;stdio.h&gt;
     # include &lt;ctype.h&gt;

     typedef struct interval { double lo, hi; } INTERVAL;

     INTERVAL vmul(), vdiv();
     double atof();
     double dreg[ 26 ];
     INTERVAL vreg[ 26 ];
     %}

     %start lines
     %union { int ival; double dval; INTERVAL vval; }
     %token &lt;ival&gt; DREG VREG  /* indices into dreg, vreg arrays */
     %token &lt;dval&gt; CONST      /* floating point constant */
     %type &lt;dval&gt; dexp        /* expression */
     %type &lt;vval&gt; vexp        /* interval expression */

     /* precedence information about the operators */

     %left     '+' '-'
     %left     '*' '/'
     %left     UMINUS /* precedence for unary minus */
     %%



     lines:    /* empty */
          |    lines line
          ;


     line :    dexp '\n'
                    { printf( "%15.8f\n", $1 ); }
          |    vexp '\n'
                    { printf("(%15.8f , %15.8f )\n", $1.lo, $1.hi ); }
          |    DREG '=' dexp '\n'
                    { dreg[$1] = $3; }
          |    VREG '=' vexp '\n'
                    { vreg[$1] = $3; }

          |    error '\n'
                    { yyerrok; }
          ;


     dexp :    CONST
          |    DREG
                    { $$ = dreg[$1]; }
          |    dexp '+' dexp
                    { $$ = $1 + $3; }
          |    dexp '-' dexp
                    { $$ = $1 - $3; }
          |    dexp '*' dexp
                    { $$ = $1 * $3; }
          |    dexp '/' dexp
                    { $$ = $1 / $3; }
          |    '-' dexp       %prec UMINUS
                    { $$ = - $2; }
          |    '(' dexp ')'
                    { $$ = $2; }
          ;


     vexp :    dexp
                    { $$.hi = $$.lo = $1; }
          |    '(' dexp ',' dexp ')'
                    { $$.lo = $2; $$.hi = $4;
                      if( $$.lo > $$.hi ){
                         printf( "interval out of order\n" );
                         YYERROR;
                      }
                    }
          |    VREG
                    { $$ = vreg[$1]; }
          |    vexp '+' vexp
                    { $$.hi = $1.hi + $3.hi; $$.lo = $1.lo + $3.lo; }
          |    dexp '+' vexp
                    { $$.hi = $1 + $3.hi; $$.lo = $1 + $3.lo; }
          |    vexp '-' vexp
                    { $$.hi = $1.hi - $3.lo; $$.lo = $1.lo - $3.hi; }
          |    dexp '-' vexp
                    { $$.hi = $1 - $3.lo; $$.lo = $1 - $3.hi; }
          |    vexp '*' vexp
                    { $$ = vmul( $1.lo, $1.hi, $3 ); }
          |    dexp '*' vexp
                    { $$ = vmul( $1, $1, $3 ); }
          |    vexp '/' vexp
                    {
                      if( dcheck( $3 ) ) YYERROR;
                      $$ = vdiv( $1.lo, $1.hi, $3 );
                    }
          |    dexp '/' vexp
                    {
                      if( dcheck( $3 ) ) YYERROR;
                      $$ = vdiv( $1, $1, $3 );
                    }
          |    '-' vexp       %prec UMINUS
                    { $$.hi = -$2.lo; $$.lo = -$2.hi; }
          |    '(' vexp ')'
                    { $$ = $2; }
          ;


     %%

     # define BSZ 50 /* buffer size for floating point numbers */

     /* lexical analysis */

     yylex()
     {
          register c;
          while( (c=getchar()) == ' ' ) { /* skip over blanks */ }
          if( isupper( c ) ) {
               yylval.ival = c - 'A'; return( VREG );
          }
          if( islower( c ) ) {
               yylval.ival = c - 'a'; return( DREG );
          }
          if( isdigit( c ) || c=='.' ) {
                    /* gobble up digits, points,exponents */
               char buf[BSZ+1], *cp = buf;
               int dot = 0, exp = 0;
               for( ; (cp-buf)&lt;BSZ ; ++cp,c=getchar() ) {
                    *cp = c;
                    if( isdigit( c ) ) continue;
                    if( c == '.' ) {
                         if( dot++ || exp ) return( '.' );
                              /* will cause syntax error */
                         continue;
                    }
                    if( c == 'e' ) {
                         if( exp++ ) return( 'e' );
                              /* will cause  syntax error */
                         continue;
                    }
                         /* end of number */
                    break;
               }
               *cp = '\0';
               if( (cp-buf) &gt;= BSZ )
                    printf( "constant too long: truncated\n" );
               else ungetc( c, stdin ); /* push back last char read */
               yylval.dval = atof( buf );
               return( CONST );
          }
          return( c );


     }


     INTERVAL hilo( a, b, c, d )
     double a, b, c, d;

     { /* returns the smallest interval containing a, b, c, and d */
          /* used by *, / routines */
          INTERVAL v;
          if( a>b ) { v.hi = a; v.lo = b; }
          else { v.hi = b; v.lo = a; }
          if( c&gt;d ) {
               if( c&gt;v.hi ) v.hi = c;
               if( d&lt;v.lo ) v.lo = d;
          }
          else {
               if( d&gt;v.hi ) v.hi = d;
               if( c&lt;v.lo ) v.lo = c;
          }
          return( v );

     }



     INTERVAL vmul( a, b, v )
     double a, b; INTERVAL v;

     {
          return( hilo( a*v.hi, a*v.lo, b*v.hi, b*v.lo ) );

     }

     dcheck( v )
     INTERVAL v;
     {
          if( v.hi &gt;= 0. && v.lo &lt;= 0. ) {
               printf( "divisor interval contains 0.\n" );
               return( 1 );
          }
          return( 0 );

     }


     INTERVAL vdiv( a, b, v )
     double a, b;
     INTERVAL v;

     {
          return( hilo( a/v.hi, a/v.lo, b/v.hi, b/v.lo ) );

     }
</pre>
<h2>

                      ПРИЛОЖЕНИЕ Д
</h2>
<h3>
         Старые средства - поддерживаемые, но не поощряемые

</h3>
<p>
     В этом  приложении  упоминаются  синонимы  некоторых  средств;  и
средства устаревшие,  хотя и не исключенные из системы,  а потому - не
поошряемые.

</p>
<p>
     1. Литералы могут также заключаться между двойными кавычками.

</p>
<p>
     2. Литералы могут иметь длину  в  несколько  символов.  Если  все
символы его - буквы, цифры или знак подчеркивания "_", то этот литерал
рассматривается,  как если бы он не имел  кавычек.  С  другой  стороны
такие    литералы    сложно    различать   в   тексте.   Использование
многосимвольных литералов может ввести в заблуждение,  но  напоминает,
что   Yacc   способен  выполнять  работу,  которой  обычно  занимается
лексический анализатор.

</p>
<p>
     3. Во многих местах,  где  применяется  знак  процента  %,  может
использоваться и обратный слэш "\".  Сочетание \\ может заменить %%, а
\left - %left и т.п.

</p>
<p>
     4. Есть и другие синонимы:
<pre>
                   %&lt; соответствует %left
                   %&gt; соответствует %right
                   % binary и %2 соответствуют %nonassoc
                   %0 и % term соответствуют %token
                   %= соответствует %prec

</pre>
<p>
     5. Действия могут иметь вид:
</p>
<pre>
                          ={ . . . }

</pre>
<p>
     и такое  "кудрявое"  использование  можно   зарезервировать   для
действия - единичного оператора языка Си.

</p>
<p>
     6. Код  языка  Си  между  %{ и %} может быть разрешен в заголовке
секции правил также, как и в секции деклараций.
</p>
<hr>
<p>
Перевод: (с) Constantin E. Climentieff aka DrMad,<br>
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> * 
<a href="http://www.chat.ru/~drmad">http://www.chat.ru/~drmad</a>
</p>
<body>
</html>


    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

