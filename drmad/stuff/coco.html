<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<title>Cocol/R - язык для описания компиляторов</title>
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>    
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
    
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
    
    <!--->  

<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
<FONT SIZE=+3 COLOR="White">Cocol/R - язык для описания компиляторов<FONT><br>
                (c) Pat Terry, updated Monday 15 June 1992
</TH>
</TR>
</TABLE>                    

<br><a href="index.html"><img src="back.gif"></a><br>

<h2>
Содержание
</h2>

<p>
<A HREF="#m1">Общая структура</A><br>
<A HREF="#m2">Спецификация сканера</A><br>
<A HREF="#m3">Символы</A><br>
<A HREF="#m4">Токены</A><br>
<A HREF="#m5">Имена</A><br>
<a href="#m12">Прагмы</a><br>
<A HREF="#m6">Комментарии</A><br>
<a href="#m13">Разное</a><br>
<A HREF="#m7">Спецификация разборщика</A><br>
<A HREF="#m8">Продукции</A><br>
<A HREF="#m9">Выражения</A><br>
<A HREF="#m10">Слабые символы</A><br>
<A HREF="#m11">Требования к LL(1)</A><br>
</p>


<p>
     (Это модифицированная  версия  текстов от Professor Moessenboeck.
Модификации сделаны  для  того,  чтобы  привести  в  соответствие  эту
реализацию с языком Модула-2,  и для описания сделанных расширений.  С
полной  версией  текстов  должны  консультироваться  только  серьезные
пользователи).
</p>

<p>
     Описание компилятора может быть изображено как модуль, содержащий
импорт,   декларации  и  грамматические  правила,  которые  определяют
лексическую и синтаксическую структуру языка также,  как и правила его
трансляции в желаемый язык. Словарь Cocol/R использует идентификаторы,
строки и числа обычным образом:
</p>

<p>
<pre>
   ident  = letter { letter | digit } .
   string = '"' { anyButQuote } '"' | "'" { anyButApostrophe } "'" .
   number = digit { digit } .
</pre>
</p>

<p>
     Строчные буквы  отличаются  от  прописных.   Строки   не   должны
пересекать границ. Ключевые слова Cocol/R - это:
</p>

<p>
<pre>
     ANY CASE CHARACTERS CHR COMMENTS COMPILER CONTEXT END FROM
     IGNORE NAMES NESTED PRAGMAS PRODUCTIONS SYNC TO TOKENS WEAK
</pre>
</p>

<p>
     (NAMES - это расширение оригинального синтаксиса языка Оберон).
</p>

<p>
     Следующие метасимволы использованые  для  формирования  выражений
РБНФ:
</p>

<p>
<pre>
      (    )       для группировки
      {    }       для итераций
      [    ]       для опций
      &lt;    &gt;       для атрибутов
      (.  .)       для семантических фрагментов
      = . | + -    как объяснено ниже
</pre>
</p>

<p>
     Комментарии заключаются в "(*" и "*)" и  могут  быть  вложенными.
Семантические части могут содержать декларации или операторы на языках
высокого уровня (в данном случае, на Модуле-2).
</p>

<p>
<h2>
<a name="m1">Общая структура</a>
</h2>
</p>

<p>
     Описание компилятора состоит из следующих частей
</p>

<p>
<pre>
     Cocol =   "COMPILER" goalIdent
                ArbitraryText
                ScannerSpecification
                ParserSpecification
                "END" goalIdent "." .
</pre>
</p>


<p>
     Имя после ключевого слова COMPILER - это  имя  грамматики  и  оно
должно соответствовать имени после ключевого слова END. Имя грамматики
также означает самый верхний нетерминал (стартовый символ).
</p>

<p>
     После имени грамматики может следовать текст на Модуле-2,  но это
не отслеживается Coco/R.  Этот раздел обычно содержит  списки  импорта
модулей Модулы-2  и  описания  глобальных  объектов (констант,  типов,
переменных или процедур),  которые потом потребуются  в  семантических
операциях.
</p>

<p>
     Оставшиеся части     описания      компилятора      специфицируют
обрабатываемые   лексическую   и   синтаксическую   структуры   языка.
Целесообразно специфицировать две грамматики - одну  для  лексического
анализатора  (сканера)  другую  для  синтаксического анализатора,  или
(разборщика).   Нетерминалы   (обобщенные   токены),    распознаваемые
сканером, рассматриваются разборщиком как терминалы.
</p>

<p>
<h2>
<a name="m2">Спецификация сканера</a>
</h2>
</p>

<p>
     Сканер должен   читать   исходный  текст,  пропускать  незначащие
символы  и  распознавать  токены,   которые   должны   быть   переданы
разборщику.  Токены могут быть классифицированы как литералы (ключевые
последовательности) или классы токенов. Литералы (например, "END", "="
и пр.) записываются как строки и означают сами себя. Они располагаются
в  правой  части  продукций,  и  их  не  надо  объявлять  (описывать).
Обобщенные   токены   (например,   идентификаторы   или  числа)  имеют
определенную структуру, которая должна быть описана в виде регулярного
выражения  РБНФ.  Существует  много различных видов обобщенных токенов
(например, множество идентификаторов), которые распознаются как один и
тот же токен.
</p>

<p>
<pre>
ScannerSpecification =  {  "CHARACTERS" { SetDecl }
                         | "TOKENS"     { TokenDecl }
                         | "NAMES"      { NameDecl }
                         | "PRAGMAS"    { PragmaDecl }
                         | CommentDecl
                         | VariousDecl
                         } .
</pre>
</p>

<p>
     Спецификация сканера состоит из 6 необязательных частей,  которые
могут появляться в произвольном порядке.
</p>

<p>
<h2>
<a name="m3">Символы</a>
</h2>
</p>

<p>
     Эта секция обеспечивает  описания  имен  для  множеств  символов,
таких как буквы или цифры.  Эти имена могут быть использованы в других
секциях спецификации сканера.
</p>

<p>
<pre>
   SetDecl   = ident "=" Set ".".
   Set       = BasicSet { ( "+" | "-" ) BasicSet }.
   BasicSet  = ident
               | string
               | "CHR" "(" number ")" [ ".." "CHR" "(" number ")" ]
               | "ANY".
</pre>
</p>

<p>
     SetDecl присваивает  множеству  символов  ися.  Базовое множество
символов определяется как:
</p>

<p>
<ul>
     <li>string - множество, состоящее из всех символов строки;
     <li>ident - заранее определенное множество символов с его именем;
     <li>ANY - множество всех символов;
     <li>CHR(i) -  отдельный символ с порядковым номером (ординалом) i;
     <li>CHR(i)..CHR(j) - множество символов с ординалами между i и j.
</ul>
</p>

<p>
     Возможность специфицировать  диапазон  от  CHR(7)  до CHR(31) это
расширение над оригинальной реализацией языка Оберон.
</p>

<p>
     Множества символов  могут  быть  сформированы из базовых множеств
при помощи операторов:
</p>

<p>
     + (объединение) сложение множеств;
     - вычитание множеств.
</p>

<p>
      ПРИМЕРЫ:

<pre>
      digit="0123456789"            Множество всех цифр;
      hexdigit=digit+"ABCDEF"       Множество всех 16-ричных цифр;
      eol=CHR(13)                   Символ конца строки;
      noDigit=ANY - digit           "Не-цифра";
      ctrlChars=CHR(1)..CHR(31)     Управляющие символы ASCII.
</pre>
</p>

<p>
<h2>
<a name="m4">Токены</a>
</h2>
</p>

<p>
     Токен рассматривается  разборщиком  как терминальный символ,  для
сканера это - синтаксически структурированный  символ.  Эта  структура
должна быть лписана регулярным выражением в РБНФ.
</p>

<p>
<pre>
   TokenDecl    = Symbol [ "=" TokenExpr "." ] .
   TokenExpr    = TokenTerm { "|" TokenTerm } .
   TokenTerm    = TokenFactor { TokenFactor }
                  [ "CONTEXT" "(" TokenExpr ")" ] .
   TokenFactor  = Symbol
                  | "(" TokenExpr ")"
                  | "[" TokenExpr "]"
                  | "{" TokenExpr "}" .
   Symbol       = ident | string .
</pre>
</p>

<p>
     Токены могут быть описаны в произвольном порядке. Описание токена
определяет символ  совместн  с  его структурой.  Обычно символ в левой
части описания представляет собой идентификатор.  Он  описывается  для
того, чтобы раскрыть смысл правой части описания.
</p>

<p>
     Правая часть описания токена специфицирует структуру  токена  при
помощи  регулярного  выражения  РБНФ.  Это  выражение  может содержать
литералы,  означающие сами себя (например "END"),  так же как и  имена
множеств символов (например, букв), описывающие произвольный символ из
таких множеств.  Фраза CONTEXT в TokenTerm означает  тот  единственный
терм,  который  был  распознан,  когда  его правый контекст во входном
потоке - это TokenExpr, заключенный в скобки.
</p>

<p>
     В отдельных  случаях  левый  символ  может  быть строкой,  в этом
случае справа может не быть специфицировано ничего;  это используется,
если пользователь желает знаниматься разбором "вручную".  Вместо этого
правая часть декларации опускается, и сканер не генерируется.
</p>

<p>
      ПРИМЕРЫ:

<pre>
      ident   =   letter { letter | digit } .
      real    =   digit { digit } "." { digit }
                   [ "E" [ "+" | "-" ] digit { digit } ] .
      number  =   digit { digit }
                | digit { digit } CONTEXT ( ".." ) .
      and     =   "&" | "AND" .
</pre>
</p>

<p>
     Фраза CONTEXT  в предыдущем примере обеспечивает различение между
вещественными числами (например,  1.23) и  диапазонными  конструкциями
(например, 1..2),  что не может быть однозначно оттранслировано,  если
заглядывать вперед на один символ.
</p>

<p>
     ЗАМЕЧАНИЕ: сканер  экспортирует  две переменных,  pos (позиция) и
len (длина), которые представляют собой позицию и длину самого раннего
распознанного токена. Он также экспортирует процедуру
</p>

<p>
<pre>
                   GetName (pos, len, sourceText),
</pre>
</p>

<p>
которая может   быть   использованаа  для  доступа  к  действительному
содержимому токена в позиции pos длиной len).
</p>

<p>
<h2>
<a name="m5">Имена</a>
</h2>
</p>

<p>
     Обычно сгенерированные сканер и разборщик используют  беззнаковые
целые   литералы  для  обозначения  символов  и  токенов.  Это  делает
разборщики "нечитабельными".  Используя директиву компилятора  $N  или
параметр  командной  строки  /N,  можно  заставить Coco/R генерировать
символьные обозначения.  По умолчанию  эти  имена  имеют  стереотипную
форму.  NameDecl  можно использовать для предпочтительных определяемых
пользователем имен:
</p>

<p>
<pre>
            NameDecl = Ident  "=" ( ident | string ) "." .
</pre>
</p>

<p>
   ПРИМЕРЫ:
</p>

<p>
<pre>
       lss = "<" .
       ellipsis = ".." .
</pre>
</p>

<p>
     (Возможность использовать имена - это расширение над оригинальной
реализацией языка Oberon)
</p>

<p>
<h2>
<a name="m12">Прагмы</a>
</h2>
</p>

<p>
     Прагма - это токен,  который может встретится где-то  во  входном
потоке  (это  могут  быть символы конца строки или опции компилятора).
Довольно  затруднительно  обрабатывать  все  многочисленные  места,  в
которых  прагма  может  встретиться  в грамматике.  Поэтому существует
специальный механизм для  обработки  прагм  без  включения  их  внутрь
продукций.  Прагмы  объявляются  подобно  токенам,  но  им  может быть
назначено  семантическое  действие,  которое  будет  выполняться   вне
зависимости от того, распознаны ли они сканером или нет.
</p>

<p>
<pre>
   PragmaDecl   =  TokenDecl [ SemAction ] .
   SemAction    =  "(." arbitraryText ".)" .
</pre>
</p>

   ПРИМЕР:

<pre>
     option = "$" { letter } .
         (. Scanner.GetName(Scanner.pos, Scanner.len, str);
            i := 1;
            WHILE i < Scanner.len DO
              CASE str[i] OF
              ...
              END;
              INC(i)
            END .)
</pre>
</p>

<p>
<h2>
<a name="m6">Комментарии</a>
</h2>
</p>

<p>
     Комментарии трудно  (а  вложенные  -  даже  невозможно) описать в
терминах  регулярных  инструкций.  Это  вызывает  необходимость  иметь
специальнную конструкцию для обработки подобной структуры. Комментарии
описываются   специфицированием   их   открывающих    и    закрывающих
ограничителей.   Возможно   описывать   различные  типы  комментариев.
Ограничители не должны быть длинней двух символов.
</p>

<p>
<pre>
     CommentDecl =
     "COMMENTS" "FROM" TokenExpr "TO" TokenExpr [ "NESTED" ] .

     ПРИМЕРЫ:

     COMMENTS FROM "(*" TO "*)" NESTED
     COMMENTS FROM "--" TO eol
</pre>
</p>

<p>
<h2>

<a name="m13">Разное</a>

</h2>
<p>

<p>
     Следующие опции помогают гибко генерировать сканер.
</p>


<p>
<pre>
     VariousDecl = "IGNORE" ("CASE" | set).
</pre>
</p>


<p>
     "IGNORE CASE"   означает,   что   прописные  буквы  в  именах  не
отличаются от строчных.
</p>


<p>
     "IGNORE набор"  определяет  набор  незначимых  символов,  которые
пропускаются сканнером,  если он встречает их между токенов (например,
символы табуляции или конца строки). Пробел пропускается по умолчанию.
</p>

<p>
<h2>
<a name="m7">Спецификация разборщика</a>
</h2>
</p>

<p>
     Спецификация разборщика    является   главной   частью   описания
компилятора.   Она   содержит   продукции    атрибутной    грамматики,
специфицирующей синтаксис языка, который необходимо распознать, прежде
чем оттранслировать.  Продукции  могут  располагаться  в  произвольном
порядке. Допускаются ссылки на еще неописанный нетерминалы. Любое имя,
котрое предварительно не было описано как терминальный  токен,  должно
рассматриваться как нетерминал.
</p>

<p>
     Для каждого нетерминала должна быть  в  точности  одна  продукция
(или список   альтернативных  правых  частей).  Должна  присутствовать
продукция для начального символа, соответствующая имени грамматики.
</p>

<p>
<pre>
  ParserSpecification = "PRODUCTIONS" { Production } .
  Production          = ident [ FormalAttributes ]
                        [ LocalDecl ] "=" Expression "." .
  FormalAttributes    = "&lt;"  arbitraryText "&gt;" .
  LocalDecl           = "(." arbitraryText ".)" .
</pre>
</p>

<p>
<h2>
<a name="m8">Продукции</a>
</h2>
</p>

<p>
     Продукция может быть рассмотрена как процедура, которая разбирает
нетерминал.  Она имеет собственную  сферу  действия  для  атрибутов  и
локальных  объектов  и  состоит  из  левой  и  првой  частей,  которые
разделены  символом   равенства.   Левая   часть   специфицирует   имя
нетерминала  совместно  с  его  формальными  атрибутами  и  локальными
декларациями.  Правая часть состоит из контекстно-свободного выражения
в EBNF (РБНФ - расширенной форме Бэкуса-Наура),  которое специфицирует
структуру нетерминала, т.е. способ его трансляции. Формальный атрибуты
записаны как формальный параметры в Modula-2.  Они заключены в угловые
скобки.   По   аналогии   со   входными   и   выходными    параметрами
(параметрами-переменными)   мы  будем  использовать  термина  "входные
атрнибуты"  и  "выходные  атрибуты".  Локальные   декларации   -   это
произвольные  декларации  языка  Modula-2,  заключенные в "(." и ".)".
ПРодукция устанавливает сферу действия для своих  формальных атрибутов
и  их  локально описанных объектов.  Терминалы и нетерминалы,  в общем
случае называемые объектами,  а также импортированные модули  видны  в
любой продукции.
</p>

<p>
   ПРИМЕР:

</pre>
      Expression &lt;VAR x: Item&gt;                  (* параметры *)
                 (. VAR
                      y: Item;
                      operator: INTEGER; .)  (* локальные переменные *)
      = (* описание выражения *) .
</pre>
</p>

<p>
<h2>
<a name="m9">Выражения</a>
</h2>
</p>

<p>
     Выражение РБНФ описывает контекстно-свободную структуру некоторой
части  части  исходного  языка совместно с атрибутами и семантическими
действиями,  которые специфицируют трансляцию этой части  в  требуемый
язык.
</p>

<p>
</pre>
   Expression   = Term { "|" Term } .
   Term         = { Factor } .
   Factor       = [ "WEAK" ] Symbol [ Attributes ]
                  |  SemAction
                  |  "ANY"
                  |  "SYNC"
                  |  "(" Expression ")"
                  |  "[" Expression "]"
                  |  "{" Expression "}" .
   Attributes   = "&lt;"  arbitraryText "&gt;" .
   SemAction    = "(." arbitraryText ".)" .
   Symbol       = ident | string .
</pre>
</p>

<p>
     Нетерминалы могут иметь атрибуты.  Они пишутся как действительные
параметры   языка  Modula-2  и  заключаются  в  угловые  скобки.  Если
нетерминал  имеет  формальные   атрибуты,   каждое   появление   этого
нетерминала  должно  иметь  список  действительных атрибутов,  который
соответствует  формальным  аьрибутам  в   соответствии   с   правилами
совместимости языка Modula-2.  Соответствие, тем не менее, проверяется
только тогда,  когда компилируется  модуль  разборщика.  Семантическое
действие  - произвольная последовательность операторов языка Modula-2,
заключенная в "(." и ".)". Символ ANY означает любой терминал, который
ен  является  альтернативой  символу  ANY.  Обычно он используется для
разбора  структур,  которые  содержат  произвольный  текст.  Например,
трансляция списка атрибутов Cocol/R по существу такова:
</p>


<p>
</pre>
    Attributes &lt; VAR pos, len: LONGINT &gt; =
        "<"               (. pos := Scanner.pos + 1 .)
        { ANY }
        ">"               (. len := Scanner.pos - pos .) .
</pre>
</p>

<p>
     В этом   примере   закрывающая   угловая   скобка   это   неявная
альтернатива сивола  ANY  в  фигурных  скобках.  Смысл в том,  что ANY
соответствует любому терминалу,  за исключением "&gt;". Scanner.pos - это
позиция в   исходном   тексте   для   последенго  распознанного
терминала. Она экспортируется сгенерированным сканером.
</p>

<p>
<h2>
<a name="m9">Обработка ошибок</a>
</h2>
</p>

<p>
     Правильное и    эффективное    восстановление    после     ошибок
трудноосуществимо в   разборщиках,  основанных  на  идее  рекурсивного
спуска, поскольку когда ошибка происходит,  доступно мало информации о
процессе разбора. Что необходимо  сделать в случае ошибки:
</p>

<p>
     <ol>
     <li>Найти  все  символы,  с которыми разбор может быть продолжен с
определенной позиции в доступной грамматике,  начиная с позиции ошибки
(восстановимые символы).
     <li>Пропустить весь входной поток до  появления  первого  символа,
входящего во множество восстановимых.
     <li>Переместить разборщик  в  позицию,  где  восстановимый  символ
может быть распознан.
     <li>Продолжить разбор с этой позиции.
     </ol>

</p>

<p>
     В разборщиках,  основанных на рекурсивном  спуске,  информация  о
позиции разбора  и  об  ожидаемых  символах  неявно  содержится в коде
разборщика (и в процедуре call stack) и не может быть использована для
восстановления после   ошибок.   Один   из   методов   преодолеть  это
заключается в  динамическом  вычислении  восстановимого  множества  во
время разбора.  В  дальнейшем,  если  возникает ошибка,  восстановимые
символы уже известны и все,  что необходимо  сделать,  это  пропустить
ошибочный входной   поток   и   "раскрутить"  процедуру  stack  up  до
допустимой точки  продолжения  [Wirth  76].  Эта   техника,   хотя   и
автоматизируемая, замедляет  безошибочеый  разбор  и  увеличивает  код
разборщика.
</p>

<p>
     Другая техника  была  упомянута  в  [Wirth 86].  В восстановлении
принимают участие только некоторые синхронизирующие  точки грамматики.
Ошибки в других точках обнаруживаются,  но не подлежат восстановлению.
Разбор просто продолжается со следующей  синхронизируещей  точки,  где
грамматика и   входной  поток  снова  соответствуют  друг  другу.  Это
требует, чтобы    разработчик    грамматики    специфицировал    точки
синхронизации единственным  образом - не слишком сложная работа,  если
немножко подумать.  Преимущество   в   том,   что   никаких   множеств
восстанавливаемых символов  не  надо вычислять в процессе работы.  Это
делает разборщик маленьким и быстрым.
</p>

<p>
     Программисту необходимо иметь в виду несколько советов  для того,
чтобы Coco/R генерировал хороший и эффективный обработчик ошибок.
</p>

<p>
     Во-первых, необходимо специфицировать точки  синхронизации. Точки
синхронизации - это позиции в грамматике, где ожидаются особо надежные
терминалы, которые трудно пропустить или неправильно  оформить.  Когда
генерируемый разборщик  достигает  такой  точки,  он подгоняет входной
поток к следующему ожидаемому в этой точке символу.  Во многих  языках
хорошие кандидаты  на  точки  синхронизации  -  начала операторов (где
ожидается что-то вроде IF,  WHILE и т.п.), начала секций описания (где
ожидается что-то  вроде CONST,  VAR и пр.).  Символ конца файла всегда
один из  символов  синхронизации,  гарантирующий,  что   синхронизация
пркращается как минимум в конце исходного текста.  Точки синхронизации
специфицируются символом SYNC.
</p>

<p>
     Точка синхронизации транслируется в цикл,  который пропускает все
символы, не ожидаемые в этой точке (исключая конец  файла).  Множество
таких символов  может быть предварительно вычислено на этапе генерации
разборщика. Следующий пример показывает две точки синхронизации  и  их
двойников в сгенерированном разборщике.
</p>

<p>
<pre>
PRODUCTION                    SPIRIT OF GENERATED PARSING PROCEDURE
Declarations =
   SYNC                       WHILE ~ (sym IN {const, type, var, proc,
                                               begin, end, eof}) DO
                                 Error(...); Get
                              END;
{                             WHILE sym IN {const, type, var, proc} DO
  ( "CONST" { ConstDecl ";" }   IF sym = const THEN Get;...
  | "TYPE" { TypeDecl ";" }     ELSIF sym = type THEN Get;...
  | "VAR" { VarDecl ";" }       ELSIF sym = var THEN Get;...
  | ProcDecl                    ELSE ProcDecl
  )                           END;
  SYNC                        WHILE ~ (sym IN {const, type, var, proc,
                                               begin, end, eof}) DO
                                 Error(...); Get
                              END
}
</pre>
</p>

<p>
     Чтобы избежать ложных сообщений об ошибках, об ошибках сообщается
лишь когда  определенная  часть  текста  после  последней ошибки будет
корректно разобрана.
</p>

<p>
<h2>
<a name="m10">Слабые символы</a>
</h2>
</p>

<p>
     Обработка ошибок  может  быть  выполнена посредством спецификации
этих терминалов как "слабых" в текущем контексте. Слабый теминал - это
символ, в  котором  можно  допустить ошибку или пропустить его,  как в
точке с  запятой  между  операторами.   Слабый   терминал   отмечается
постановкой перед  ним  ключевого  слова WEAK.  Когда сгенернированный
разборщик не находит слабых терминалов,  он прогоняет входной поток до
следующего символа,   который  либо  является  допустимым  наследником
слабого символа,  либо символом, ожидаемым в любой точке синхронизации
(считается, что  символы  в точках синхронизации настольког "сильные",
что их никогда невозможно пропустить).
</p>

<p>
   ПРИМЕР:
<pre>
      StatementSeq = Statement { WEAK ";" Statement } .
</pre>
</p>

<p>
     Если разборщик  пытается распознать слабый символ и обнаруживает,
что он пропущен,  он информирует об ошибке и пропускает входной  поток
до тех  пор,  пока  правильный  наследник не будет найден (или символ,
котолрый ожидается  в  какой-нибудь  точке   синхронизации;   избегать
пропуск надежных  символов можно лишь эвристически).  Следующий пример
демонстрирует трансляцию слабого символа.
</p>

<p>
Идея генерируемого кода разборщика:
</p>

<p>
<pre>
Statement =
   ident                Expect(ident);
   WEAK ":="            ExpectWeak (becomes,
                                   {стартовый символ для Expression});
   Expression           Expression
</pre>
</p>

<p>
Процедура ExpectWeak в общих чертах реализована так:
</p>

<p>
<pre>
  PROCEDURE ExpectWeak (s: INTEGER; expected: Set);
  BEGIN
    IF sym = s THEN Get
    ELSE
       Error(s);
       WHILE ~ sym IN expected + {символы, ожидаемые в
                                  точках синхронизации} DO
         Get
       END
    END
  END ExpectWeak;
</pre>
</p>

<p>
     Слабые символы  дают разборщику еще один шанс для синхронизации в
случае ошибки.  Кроме того,  множество ожидаемыхх символов может  быть
заранее вычислено   на   этапе  генерации  разборщика  и  не  вызывать
замедления работы при безошибочном разборе.  Когда итерация начинается
со слабого  символа,  этот  символ  называется  слабым  разделителем и
обрабатывается особым  образом.  Если  он  не  может  быть  распознан,
входной поток пропускается до тех пор, пока не будет обнаружен символ,
содержащийся в одном из трех множеств:
</p>

<ul>
 <li>символы, которые могут следовать за слабым разделителем
 <li>символы, которые могут следовать за итерацией
 <li>символы, ожидаемые в любой точке синхронизации (включая eof)
</ul>

<p>
     Следующий пример демонстрирует трансляцию слабого разделителя.
</p>

<p>
<pre>
                           ГЕНЕРИРУЕМАЯ ПРОЦЕДУРА РАЗБОРА

     StatSequence =
     Stat               Stat;
     { WEAK ";" Stat }. WHILE WeakSeparator(semicolon, A, B) DO Stat END
</pre>
</p>

<p>
     В этом  примере  A  -  это  можество стартовых символов оператора
(идентификатор, IF,  WHILE  и  пр.),  а  B  -  множество   наследников
последовательности операторов (END,  ELSE, UNTIL и пр.). Оба множества
вычисляются предварительно    на    этапе    генерации     разборщика.
WeakSeparator реализуется следующими строками:
</p>

<p>
<pre>
   PROCEDURE WeakSeparator (s: INTEGER; sySucc, iterSucc: Set): BOOLEAN;
   BEGIN
     IF sym = s
       THEN Get; RETURN TRUE
       ELSIF sym IN iterSucc THEN RETURN FALSE
       ELSE
         Error(s);
         WHILE ~ sym IN (sySucc + iterSucc + eof) DO Get END;
         RETURN sym IN sySucc (* TRUE means 's inserted' *)
     END
   END WeakSeparator;
</pre>
</p>

<p>
     Читатель может  обратить  внимание,  что  множество  B   содержит
наследников  для  последовательности  операторов  в  любом  допустимом
контексте.   Это   множество   может   быть   очень   большим.    Если
последовательность  операторов  встречаетсч  в  операторе  REPEAT,  то
допустимый наследник - только UNTIL, но не END или ELSE. Мы согласны с
этим  замечанием  до  тех пор,  пока возможно предварительно вычислить
множество B на этапе генерации  разборщика.  Появление  END  или  ELSE
очень маловероятно в этом контексте и может быть причиной некорректной
синхронизации,  что  потребует  от  разборщика  пересинхронизироваться
снова.
</p>

<h2>
<a name="m11">Требования к LL(1)</a>
</h2>

<p>
     Разбор, основанный  на   рекурсивном   спуске,   требует,   чтобы
разбираемый язык  удовлетворял  свойствам LL(1).  Это означает,  что в
любой точке грамматики разборщик должен быть способен  принять решение
на основе единственного впереди идущего символа из избранного множества
возможных альтернатив. Например, следующая продукция не относится к LL
(1):
</p>

<p>
<pre>
   Statement = ident ":=" Expression
             | ident [ "(" ExpressionList ")" ] .
</pre>
</p>

<p>
     Обе альтернативы начинаются с символа ident, и разборщик не может
выбрать между  продолжением  идти  по  оператору  и  поиском  ident  в
качестве следующего входного символа.  Тем не менее,  продукция  может
быть легко трансформирована в:
</p>

<p>
<pre>
   Statement = ident (   ":=" Expression
                      |  [ "(" ExpressionList ")"  ]
                     ) .
</pre>
</p>

<p>
     где все альтернативы начинаются с различных  символов.  Существуют
конфликты в LL(1),  которые не так легко распознать,  как в предыдущем
примере. Для программиста может быть тяжело найти их,  если у него нет
инструмента для  проверки  грамматики.  В результата должен получиться
разборщик, который   в   некоторых   ситуациях    выбирает    неверную
альтернативу. Coco/R проверяет,  соответствует ли грамматика свойствам
LL(1) и выдает соответствующие  сообщения  об  ошибках,  что  помогает
скорректировать нарушение.
</p>

<hr>
<p>
Перевод: (с) Constantin E. Climentieff aka DrMad,<br>
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> * 
<a href="http://www.chat.ru/~drmad">http://www.chat.ru/~drmad</a>
</p>

    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

