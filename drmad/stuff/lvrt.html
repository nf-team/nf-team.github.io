<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>LabVIEW и реальное время</TITLE>
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>	
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
	
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
	
 <!---> 	

<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
<TR>
<TD>
<P>
<CENTER>
<B><FONT FACE="Arial" color="white" size="+2">LabVIEW и реальное время<br>
Климентьев К.Е., 2004</font><b>
</CENTER>
</P>
</TD>
</TH>
</TR>
</TABLE>

<table width="100%"><tr><td width="50%"></td><td width="50%">
<p>Статья постоянно обновляется и дополняется.<br>Последнее изменение внесено 13.03.06</p>
</td></tr></table>

<P><FONT COLOR="Teal"><b>Д</b></FONT>ля начала несколько определений:</P>
<P>Реальное время - режим работы автоматизированной системы, характеризующийся ограничениями на динамические (временные) характеристики процесса функционирования.</P>
<P>Наиболее важные динамические (временные) характеристики:</P>
1) моменты наступления внутрисистемных событий (например, моменты выполнения требуемых действий при работе "по расписанию");<br>
2) длительности нахождения системы в определенных состояниях (например, продолжительности выполнения фрагментов программы);<br>
3) время отклика системы на внешние события (например, время реакции на прерывание).
<P>Основное назначение систем, работающих в режиме реального времени, - взаимодействие с объектами реального мира в темпе процессов, протекающих в этих объектах. Точку зрения фирмы National Instruments на то, что такое реальное время, где оно применяется и почему оно важно, см. в <a href="nirt.html">Приложении А.</a></P>
<P>Операционные системы класса MS Windows (за исключением, быть может, Windows CE) не являются специализированными ОСРВ (RTOS), поэтому создание полноценных систем реального времени на их основе затруднено, а часто просто невозможно. Все недостатки MS Windows в полной мере отражаются на системах, реализованных в среде LabVIEW, и кроме того, LabVIEW накладывает и свои ограничения на возможность создания систем реального времени. Существенным недостатком LabVIEW является принципиальная невозможность обработки внешних прерываний. Это означает, что единственная возможность привязки ко времени в LabVIEW - это циклический опрос (polling) состояния какого-нибудь внешнего устройства, обладающего известными динамическими (временными) характеристиками, например: часов реального времени, системного таймера, счетчика процессорных тактов, подсистемы синхронизации последовательных портов, таймеров звуковой платы и т.п.</P>
<B><P>1. Базовые возможности работы со временем</P></B>
<P>В LabVIEW имеются несколько стандартных узлов, предназначенных для организации работы приложений в режиме реального времени (см. рис. 1).</P>
<P><CENTER><IMG SRC="Image50.gif"></CENTER></P>
<P><CENTER>Рис. 1. Стандартные виртуальные приборы для работы со временем</CENTER></P>
<P>"Будильник" возвращает количество миллисекунд, накопленных с момента старта Windows. "Наручные часики" всегда делают задержку на целое количество миллисекунд. "Метроном" тоже задерживает текущий процесс, но, в отличие от “часиков”, начинает отсчет не с начала миллисекунды, а с текущего момента времени, и заканчивает его тогда, когда системные часы превысят указанный интервал, в результате чего первая миллисекунда обычно отсчитывается не полностью, а последняя оказывается "лишней". </P>
<B><P>2. Системный таймер</P>
</B><P>Богатые возможности по организации приложений реального времени предоставляет встроенный программируемый системный таймер ПЭВМ. Краткое описание принципов его работы и методов программирования см. в учебном пособии "Основы графического программирования в среде LabVIEW". <a href="lv5.html">Там же</a> были разработаны и описаны простейшие виртуальные приборы для манипулирования 2-ым каналом этого таймера (см. рис. 2). </P>
<P><CENTER><IMG SRC="Image51.gif"></CENTER></P>
<P><CENTER>Рис 2. Виртуальные приборы для работы со 2-м каналом таймера</CENTER></P>
<I><P>Примечание 1. Возможен также доступ к 0-му каналу таймера. Но этот канал обычно используется Windows для организации многозадачности и поэтому не может быть произвольно перепрограммирован. Возможно только считывание накопленного с момента старта Windows количества тактовых импульсов таймера, поступающих с частотой 1.19 МГц. Это осуществляется посредством обращения к стандартной функции API32 QueryPerformanceCounter</I>()<I>, реализованной в WINMM.DLL. Если быть более точным, то в современных чипсетах могут присутствовать и дополнительные, более высокочастотные таймеры, а операционные системы класса Windows NT/2000 </I>(<I>но не Windows 95/98/ME</I><I> могут использовать для организации многозадачности и реализации функции QueryPerformanceCounter</I>()<I> именно их. Текущую разрешающую способность QueryPerformanceCounter</I>()<I> можно определить при помощи функции QueryPerformanceFrequency</I>()<I>. Технику обращения к QueryPerformanceCounter</I>()<I>средствами LabVIEW см. в <a href="lvideman.html">Приложении Б</a>. Кстати, эти &quot;высокочастотные&quot; альтернативные таймеры (например, используемый в Windows XP APIC-таймер) на практике могут оказаться гораздо менее точными, чем &quot;стандартный&quot; системный таймер.</P>
</I>
<P>Следующий виртуальный прибор (см. рис. 3), использующий узлы "Timer Init", "Timer Read" и "Timer Status", может служить иллюстрацией методов программирования таймера.</P>
<P><CENTER><IMG SRC="Image52.gif"></CENTER></P>
<P><CENTER>Рис 3. Пример программирования системного таймера</CENTER></P>
<P>На рис 3. хорошо виден декремент значения таймерного счетчика и "опрокидывание" сигнала OUT (ему соответствует старший бит в байте состояния канала). </P>
<P>Системный таймер может быть использован для организации временных задержек с длительностью 1 мс и менее. Идея этого использования заключается в следующем. В регистр справочной константы загружается значение коэффициента пересчета, соответствующее требуемой задержке. Известно, что каждые <FONT FACE="Symbol" SIZE=1>D</FONT> T <FONT FACE="Symbol" SIZE=1>»</FONT>0.84 мкс. из счетчика вычитается число 2. Следовательно, для того, чтобы значение счетчика обнулилось за время T мкс, необходимо предварительно загрузить коэффициент пересчета K=(T/<FONT FACE="Symbol" SIZE=1>D</FONT>T)*2. Далее необходимо в цикле сканировать значение счетчика до тех пор, пока не произойдет его перезагрузка. Виртуальный прибор "Timer Delay", использующий эту идею, изображен на рис. 4.</P>
<P><CENTER><IMG SRC="Image53.gif"></CENTER></P>
<P><CENTER>Рис. 4. Задержка на малые интервалы времени</CENTER></P>
<P>Теоретически, минимальная величина задержки составляет 0.84 мкс., максимальная 27 мс (а если несколько усложнить метод и учитывать значение сигнала OUT, то 55 мс). В результате многочисленных экспериментов на различных, даже самых быстрых машинах, выяснилось, что реальная разрешающая способность - примерно 3-5 мкс.</P>
<P>Продемонстрируем также возможность точного измерения малых интервалов времени (например, длительности выполнения узла "millisecond multiple").</P>
<P><CENTER><IMG SRC="Image54.gif"></CENTER></P>
<P><CENTER>Рис. 5. Измерение времени срабатывания “Метронома”</CENTER></P>
<P>Теоретически, разрешающая способность метода составляет 0.84 мкс. Реально - те же самые 3-5 мкс.</P>
<B><P>3. Реальное время в условиях многозадачности</P>
</B><P>На любые программы, работающие в среде Windows, огромное влияние оказывает режим разделения времени между различными процессами, конкурирующими за системные ресурсы. Известны два способа разделения процессорного времени между процессами:</P>
<UL>
<LI>кооперативный (cooperative);
<LI>вытесняющий (preemptive).
</UL>
<P>При "кооперативном" способе организации многозадачности процессы сами передают управление друг другу в те моменты времени, в которые сочтут нужным (возможно, что только после своего завершения). При "вытесняющем" способе каждому процессу выделяется определенный временной интервал ("квант времени", timeslice), по истечении которого работа процесса принудительно прерывается и управление передается какому-то другому (а возможно, и тому же самому) процессу (см. рис. 6). Порядок передачи управления процессам зависит от "приоритета" процесса, - целого числа, определяющего его привилегии в системе. В Windows 3X реализована "кооперативная" многозадачность, а в Windows 9X/ME/NT/2000/XP - "вытесняющая".</P>
<P><CENTER><IMG SRC="Image55.gif"></CENTER></P>
<P><CENTER>Рис. 6. Передача управления между процессами <br>
при "вытесняющей" многозадачности, основанной на прерываниях от таймера</CENTER></P>
<I><P>Примечание 2. В разных версиях Windows продолжительность кванта времени и периода таймерных прерываний различны, более того, они могут изменяться в течение сеанса работы. Типичное значение кванта времени – от 20 </I>(<I>Windows NT/2K WorkStation</I>)<I> до 120 </I>(<I>Windows NT/2K Server</I>)<I> миллисекунд. Период таймерных прерываний </I>(<I>по умолчанию в Windows 9X он (якобы) 5 мс, а в Windows NT – 10 мс, в LabVIEW принудительно 1 мс</I>)<I> может быть изменен программно при помощи API32-функций timeBeginPeriod</I>()<I> и timeEndPeriod</I>()<I>, реализованных в WINMM.DLL. Кстати, от этого параметра очень сильно зависит точность срабатывания API32-функции Sleep</I>()<I>, на работе которой основаны стандартные средства организации временных задержек в LabVIEW </I>(<I>см. рис. 1</I>)<I>.</P>
</I><P>Продемонстрируем влияние &quot;вытесняющей&quot; многозадачности на работу приложений LabVIEW. Модифицируем виртуальный прибор, изображенный на рис. 5 таким образом, чтобы он многократно измерял "пустое место" (т.е. накладные расходы на организацию цикла измерений).</P>
<P><CENTER><IMG SRC="Image56.gif"></CENTER></P>
<P><CENTER>Рис. 7. Измеритель "пустого места"</CENTER></P>
<P>Эксперименты производились на разных компьютерах в разных версиях Windows. На рис. 8 приведены типичные результаты измерений (на гистограмме масштаб - логарифмический).</P>
<P><CENTER><IMG SRC="Image57.gif"></CENTER></P>
<P><CENTER>Рис. 8. Времена выполнения цикла для P-II Celeron 360МГц Windows 98</CENTER></P>
<P>Очевидно, работа в таких условиях противоречит требованиям, возлагаемым на системы (жесткого) реального времени. По крайней мере, любые методы измерения временных интервалов и генерации временных задержек, основанные на циклическом опросе состояния внешних процессов и устройств, будут приводить к заметным погрешностям. </P>
<B><P>4. Методы улучшения динамических характеристик приложений LabVIEW</P>
</B><P>Время выполнения &quot;пустого&quot; цикла может рассматриваться как случайная величина, причем качественный характер ее поведения одинаков на разных компьютерах и в разных версиях операционных систем. Обобщенная плотность распределения этой случайной величины имеет вид, изображенный на рис. 9.</P>
<P><CENTER><IMG SRC="Image58.gif"></CENTER></P>
<P><CENTER>Рис. 9. Обобщенное распределение времени выполнения цикла</CENTER></P>
<P>Анализ результатов измерений позволяет предположить, что случайная величина, характеризующая длительность выполнения цикла, есть комбинация трех составляющих:</P>
<CENTER><FONT SIZE=4><P>T = </FONT><FONT FACE="Symbol" SIZE=4>a</FONT><FONT SIZE=4> + </FONT><FONT FACE="Symbol" SIZE=4>b</FONT><FONT SIZE=4> + </FONT><FONT FACE="Symbol" SIZE=4>g</FONT><FONT SIZE=4>.</CENTER></P>
</FONT><P>Случайная величина <FONT FACE="Symbol" SIZE=1>a</FONT> распределена по усеченному (на интервале от 0 до нескольких десятков микросекунд, в зависимости от быстродействия компьютера) экспоненциальному закону и соответствует времени, которое тратится на выполнение цикла системой “процессор-память”. Сюда включается время выполнения команд (с учетом конвейеризации) и нерегулярные задержки, связанные с переключением банков памяти; с кэшированием команд и данных; с регенерацией динамической памяти и т.п. <B>Минимизировать это время можно, выбрав более быстродействующий компьютер.</P>
</B><P>Случайная величина <FONT FACE="Symbol" SIZE=1>b</FONT><FONT FACE="Arial" SIZE=1> в общем случае многомодальна и распределена на интервале от нескольких десятков микросекунд до 1 мс (в редких случаях - до десятков мс). Свой вклад в эти задержки вносят обработчики прерываний от многочисленных внешних устройств: от HDD и FDD, от видеоадаптера, от сетевой карты, от таймера и т.п. Сюда же входят задержки, получившиеся в результате переключения на задачи, которые в итоге "отказываются" полностью использовать свой квант времени. <B>Минимизировать это время можно, удалив из компьютера такие устройства, как сетевые карты; не обращаясь к таким устройствам ручного ввода-вывода, как мышь и клавиатура; отключив в BIOS Setup опции энергосбережения и т.п.</B> Но полностью избавиться от этих задержек, видимо, невозможно.</P>
<P><i>Примечание 3. К этому же классу задержек можно отнести задержки, связанные с обращениями к диску во время переключения страниц памяти. Эти задержки проявляются при работе с большими массивами данных, расположенными в вытесняемой памяти, и имеют порядок - несколько десятков миллисекунд.</i></P>
<P>Случайная величина </FONT><FONT FACE="Symbol" SIZE=1>g</FONT><FONT FACE="Arial" SIZE=1> распределена сравнительно узким пиком, который располагается на временной оси в районе от нескольких десятков до нескольких сотен миллисекунд (в зависимости от версии Windows и от количества конкурирующих процессов). Ей соответствуют ситуации, когда квант времени текущего процесса заканчивается, и управление получает какой-то другой процесс (процессы), которые также используют свой квант до конца. <B>Минимизировать это время можно, удалив из памяти все “посторонние” процессы и повысив приоритет текущего процесса (см. рис. 10).</B> Анализ влияния параметра “priority” на динамические характеристики виртуальных приборов см. в <a href="lvideman.html">Приложении Б</a>.</P>
</FONT><P><CENTER><IMG SRC="Image59.gif"></CENTER></P>
<FONT FACE="Arial" SIZE=1><P><CENTER>Рис. 10. Изменение относительного приоритета виртуального прибора LabVIEW</CENTER></P>
<I><P>Примечание 4. Если быть точным, то большинство фоновых процессов не дорабатывают свой квант до конца, например, напрасно ожидая пользовательского ввода. Эти задержки лежат в области </I><FONT FACE="Symbol" SIZE=1>b</FONT><I>, и именно их я назвал их выше &quot;прерываниями от таймера&quot;.</P></I>
<I><P>Примечание 5. В терминологии фирмы Microsoft &quot;процесс&quot; - это объект, потребляющий статические ресурсы </I></FONT><FONT FACE="Arial" SIZE=1>(</FONT><I><FONT FACE="Arial" SIZE=1>оперативную и дисковую память</I></FONT><FONT FACE="Arial" SIZE=1>)</FONT><I><FONT FACE="Arial" SIZE=1>, а процессорное время потребляется объектами под названием “потоки” (“нити”, “threads”), которых внутри одного “процесса” может быть несколько. Итоговый приоритет “потока” складывается из базового приоритета, назначаемого “процессу”, и собственного относительного приоритета. Параметр “priority”, рассмотренный выше, влияет только на относительный приоритет “потока”, реализующего виртуальный прибор. Можно попробовать изменить до максимального также базовый приоритет &quot;процесса&quot; LABVIEW.EXE, как показано на рис. 11. </P>
</I></FONT><P><CENTER><IMG SRC="Image60.gif"></CENTER></P>
<FONT FACE="Arial" SIZE=1><P><CENTER>Рис. 11. Изменение базового приоритета</CENTER></P>
<I><P>Эксперименты показывают, что совместное увеличение базового приоритета &quot;процесса&quot; и относительного приоритета &quot;потока&quot; позволяет виртуальному прибору полностью захватывать процессор, но по завершении работы виртуального прибора возможна неустойчивая работа Windows. Еще один интересный эффект увеличения приоритета заключается в том, что регулярные временные задержки от аппаратных прерываний (случайная составляющая &quot;<FONT FACE="Symbol" SIZE=1>b</FONT>&quot;) исчезают из области &lt;1 мс и собираются вместе в области &quot;<FONT FACE="Symbol" SIZE=1>g</FONT>&quot;, заметно сдвигая ее в сторону увеличения длительности задержек. На трассе временных интервалов это выглядит так: в течение многих сотен тысяч и миллионов циклов задержки стабильно малы, а потом следует одиночный, но очень большой (десятые доли секунды!) выброс. Вероятно, оба эффекта (неустойчивость работы и изменение качественной картины распределения задержек) связаны с двухступенчатым алгоритмом обслуживания аппартных прерываний в Windows: при приходе сигнала прерывания операционная система на короткий срок получает управление и добавляет запрос на обработку в очередь необработанных прерываний. Собственно обработка выполняется позднее, при просмотре очереди &quot;рабочим&quot; потоком. Если &quot;заморозить&quot; этот поток своим экстремально-приоритетным потоком, то: 1) операционная система периодически пытается &quot;разгрести&quot; накопившиеся прерывания, не взирая на наличие высокоприоритетных потоков; 2) после освобождения процессора высокоприоритетными потоками операционная система занимается некоторое время исключительно обработкой прерываний, хотя, возможно, устройства требовали быстрой реакции на свои запросы, а запоздалая попытка обработать их приводит только к дезорганизации системы. Короче говоря, приоритет time critical для Windows чужероден и должен применяться осторожно, на коротких временных отрезках. </P>
<P>Примечание 6. Еще одним решением проблемы могло бы служить использование операционных систем с кооперативной многозадачностью (кстати, может быть, это и не требуется, т.к. Windows 95/98/ME для поддержки 16-разрядных приложений, например - LabView 3.X или LabVIEW 4.X for Windows 3.X, автоматически переключается в &quot;кооперативный&quot; режим). Эксперименты, проведенные на конфигурации, включающей P-IV 2000 МГц, Windows 3.11 for Workgroups и LabVIEW v3.1, продемонстрировали возможность выполнения циклов с отклонениями от номинальной продолжительности не более, чем на 1 мс.</P>
</I><B><P>Резюме. Итак, на современных программно-аппаратных конфигурациях неизбежно возникновение нерегулярных временных задержек длительностью до нескольких десятков миллисекунд. В общем случае средствами LabVIEW возможно удовлетворительное решение задач (жесткого) реального времени лишь при реализации циклов сбора данных и управления с частотами следования итераций не выше 10-20 Гц.</P></B>
<I><P>Примечание последнее. Конечно, столь пессимистичный вывод - следствие того, что в этой статье мы сами загнали себя в угол, попытавшись решить нерешаемую задачу: заставить многозадачную систему Windows работать в режиме однозадачности. Если же слегка снизить требования к реактивности поллинга, например до 1 мс, то задача вполне решаема. Надо просто не тратить полностью свой квант и давать &quot;дышать&quot; другим потокам, активно используя API32-функцию Sleep</I>()<I> (т.е. узлы &quot;Метроном&quot; или &quot;Часики&quot;). Если им передать в качестве параметра 1, то и получим жесткую привязку к миллисекундному циклу; если 0, то виртуальный прибор просто передаст управление другим потокам, т.е. реактивность, вероятно, будет выше, чем 1 мс, но какая точно - неизвестно, возможно даже, что в каждом цикле разная. Вот и все, а вы боялись. </I> <font face="wingdings">J</font></P></FONT>

<hr>
<P>
Что еще почитать:
<UL>
<LI> <a href="http://www.overclockers.ru/lab/15487.shtml" target="_none">А. Леменков. nForce2 -  А пляшут ли частоты?</a> и <a href="http://www.overclockers.ru/lab/15495.shtml" target="_none">А. Леменков. nForce2 - Решение проблемы пляски частот.</a> - системный таймер с тактовой частоой 1.19 МГц стабилен, а высокочастотный APIC-таймер, используемый по умолчанию в Windows XP, имеет погрешность до 15%;</LI>
<LI> <a href="http://old.osp.ru/pcworld/1999/06/056_print.htm" target="_none">Э. Немцов. Многозадачность без шапки-невидимки.</a> - Windows 95/98/ME при запуске 16-разрядных Windows-приложений переключается в режим кооперативной многозадачности;</LI>
<LI> <a href="qnxclub.net/files/articles/invers/invers.html" target="_none">О. Цилюрик. Инверсия приоритетов и реальное время.</a> - различные версии Windows демонстрируют  эффекты, напоминающие "наследование приоритетов" в RTOS-ах.</LI>
</UL>
</P>

<hr>
<center>
(с) Constantin E. Climentieff aka DrMad,
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> * <a href="http://drmad.chat.ru/">http://drmad.chat.ru</a>
</center>

    </td>
    </tr>
    </table>

    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0">
    </td>

</tr>
</table>

</body>
</html>

