<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<tile="LEX - генератор лексических анализаторов">
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>	
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
	
    <table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
    <tr>
    <td>
	
    <!---> 	

<hr>
<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%">
<TR>
<TH>
 <FONT SIZE=+3 COLOR="White">  
               LEX-генератор лексических анализаторов<br>
</FONT>
 <FONT COLOR="White">  
                М.Е.Леск и Е.Шмидт. Bell Laboratories,  Murray Hill, New Jersey 07974
</FONT>
</TH>
</TR>
</TABLE>                    

<br><a href="index.html"><img src="back.gif"></a><br>

<center>
 <h2> АННОТАЦИЯ  -  LEX</h2>
</center>

<p>
     Lex помогает писать программы, которые реализуют поток управления
для  обработки  входной  последовательности,   содержащей   регулярные
выражения.    Он    очень    подходит    для    преобразований    типа
редактирование-описание и к разделению ввода при  подготовке  процедур
разбора.
</p>

<p>
     Исходный текст  Lex'a  -  это  таблицы  регулярных  выражений   и
соответствующих   программных   фрагментов.  Таблица  транслируется  в
программу, которая читает входной поток, копирует его в выходной поток
и  разделяет ввод на строки,  которые соответствуют данным выражениям.
Как   только   каждая   такая   строка    распознается,    исполняется
соответствующий    фрагмент    программы.    Распознавание   выражений
выполняется  по   принципу   детерминированных   конечных   автоматов,
генерируемых   системой   Lex.   Программные   фрагменты,   написанные
пользователем,  исполняются  в  порядке,  в  котором   соответствующие
регулярные выражения появляются во входном потоке.
</p>

<p>
     Программы лексического  анализа,  написанные   с   помощью   Lex,
принимают  двусмысленные спецификации и выбирают наиболее подходящие к
ним элементы ввода.  Если необходимо,  входной  поток  просматривается
вперед,  но  входной  поток  всегда будет возвращен в текущую позицию,
чтобы пользователь имел максимальную свободу манипулирования  им.  Lex
способен  генерировать  анализаторы  для  Си  или Ратфора,  или языка,
который м.б.  транслирован  автоматически  в  компактный  Фортран.  Он
доступен  для работы в системах UNIX PDP-11,  Honeywell GCOS и ОС IBM.
Это руководство будет в основном обсуждать генерирование  анализаторов
для   Си  в  системе  UNIX,  которое  поддерживается  версией  7.  Lex
разработан для простого интерфейса с Yacc,  для  обоюдного  доступа  к
этой системе "компилятор компиляторов". <br>
21 июля 1975 г.
</p>

<h2>
СОДЕРЖАНИЕ
</h2>

<p>
<ol>
     <li> <A HREF="#m1">Введение</A>     
     <li> <A HREF="#m2">Исходный текст на языке Lex</A>     
     <li> <A HREF="#m3">Регулярные выражения системы Lex<A>
     <li> <A HREF="#m4">Действия в системе Lex</A>
     <li> <A HREF="#m5">Двусмысленные правила в исходном тексте</A>
     <li> <A HREF="#m6">Описание в исходном тексте системы Lex</A>
     <li> <A HREF="#m7">Использование</A>
     <li> <A HREF="#m8">Lex и Yacc</A>
     <li> <A HREF="#m9">Примеры</A>
     <li> <A HREF="#m10">Чувствительность к левому контексту</A>
     <li> <A HREF="#m11">Множество символов</A>
     <li> <A HREF="#m12">Сводка правил по исходному формату</A>
     <li> <A HREF="#m13">Каверны и жучки</A>
     <li> <A HREF="#m14">Благодарности</A>
     <li> <A HREF="#m15">Литература</A>
</ol>
</p>

<h2>
     <a name="m1">1. Введение</a>
</h2>

<p>
     Lex - это программный генератор,  разработанный  для  лексической
обработки символьных входных потоков.  Он воспринимает высокоуровневые
проблемно-ориентированные  спецификации   для   символьных   строк   и
продуцирует  программу  на  языке  программирования  высокого  уровня,
которая распознает  регулярные  выражения.  Эти  регулярные  выражения
специфицируются  пользователем в исходном тексте на языке системы Lex.
Программный  код,  сгенерированный  системой   Lex,   распознает   эти
выражения   во   входном   потоке   и   разделяет   входной  поток  на
соответствующие  им  элементы.  На  границе  двух  строк   выполняется
программный код,  предусмотренный пользователем.  В исходном тексте на
языке  системы  Lex   указываются   соответствия   между   регулярными
выражениями   и   программными   фрагментами.  Как  только  появляется
распознанное Lex-ом выражение, выполняется соответствующий программный
фрагмент.
</p>
<p>
     Система поддерживает не только  код  пользователя  на  к-л  языке
программирования, но и код, сгенерированный другими генераторами. Но в
целом программа,  распознающая регулярные выражения,  пишется на языке
высокого    уровня.    С    другой   стороны,   высокоуровневый   язык
программирования,  который  содержал  бы  средства  поддержки  разбора
регулярных  выражений,  снижал  бы  степень свободы пользователя.  Это
должно также  заставить  задуматься  пользователя,  который  хотел  бы
использовать  язык  манипулирования  строками  и  входного анализа для
написания обрабатывающих программ.  Lex  -  это  не  завершенный  язык
программирования,   а   скорее  генератор  дополнительных  программных
средств, которые можно подключать к различным языкам программирования,
называемым   "головными  языками".  Подобно  как  универсальные  языки
программирования способны генерировать код для  выполнения  на  разном
компьютерном  оборудовании,  так  и Lex способен продуцировать код для
работы под разными "головными языками".  Эти языки здесь  используются
для вывода кода, сгенерированного системой Lex и так же для выполнения
программных  компонентов,  предусмотренных  пользователем.  Вместе   с
системой   Lex   поставляются   библиотеки   совместимости  с  разными
"головными языками". Это делает Lex совместимым с различными средами и
удобным  для разных пользователей.  Каждое конкретное применение может
быть скорректировано в сторону желаемого  программного  и  аппаратного
пользовательского   окружения  и  желаемой  задачи.  В  данном  случае
единственный  поддерживаемый  язык  -  Си,   хотя   отчести   возможна
совместимость в Фортраном (в форме языка Ратфор 2).  Lex функционирует
в средах UNIX, GCOS и OS/370; но в принципе код, генерируемый системой
Lex, может быть применен и в других средах при наличии соответствующих
компиляторов.
</p>
<p>
     Lex транслирует выражения и действия пользователя (содержащиеся в
исходном тексте) на высокоуровневый  головной  язык  программирования;
сгенерированная  программа  специфицирована  именем  yyLex.  Программа
yyLex будет распознавать  выражения  во  входном  потоке  и  выполнять
специфицированные действия для каждого распознанного выражения:
</p>
<pre>

                Исх.текст ===> Lex  ===> yylex  


                Вход ===> yyLex ===> выход

</pre>


<p>
     В качестве тривиального примера рассмотрим программу удаления  из
входного потока всех пробелов и знаков табуляции в конце строк.
</p>

<pre>
     %%
     [ \t] + $;
</pre>

<p>
     Это все,  что требуется.  Программа содержит разделитель  %%  для
отметки  начала  правила  и  само  правило.  Это  правило  состоит  из
регулярного выражения,  которое соответствует любым случаям  появления
пробелов  и табуляций (назначенных в соответствии с правилами языка Си
комбинацией \t) до конца строки.  Квадратные скобки  индицируют  класс
символов,  состоящий из пробелов и табуляций;  плюс "+" означает "один
или более";  знак " $" означает "конец строки". Никакие действия здесь
не специфицированы,  так что программа,  сгенерированная системой Lex,
будет  просто  пропускать  указанные  символы.  Все  остальное   будет
копироваться один к одному. Дабы видоизменить программу так, чтобы она
заменяла пробелы и табуляции на один пробел, нужно следующее правило:
</p>

<pre>
     %%
     [ \t]+ $;
     [ \t]+ printf (" ");
</pre>

<p>
     Алгоритм, обрабатываемый  сгенерированным   конечным   автоматом,
будет удалять из строки все пробелы и табуляции и печатать на их месте
единственный пробел,  пока не встретится конец строки.  Первое правило
соответствует  случаю,  когда  пробелы и табуляции разрешаются в конце
строки, второе - всем остальным случаям.
</p>

<p>
     Система Lex может быть использована для простых трансформаций или
для анализа и статистических обобщений на уровне лексики.  Так же  Lex
можно использовать для работы с генератором разборщиков для выполнения
фазы лексического анализа,  особенно легко совместима  система  Lex  с
системой  Yacc3.  Программы  системы  Lex распознают только регулярные
выражения;  Yacc генерирует разборщики,  которые воспринимают  большие
классы  контекстно-свободных  грамматик,  но  еще и требуют анализатор
более низкого уровня для распознания входных токенов.  Так  комбинация
Lex'a  и  yacc'a  весьма  плодотворна.  Если  Lex  работает в качестве
препроцессора для генератора  разборщиков,  то  он  разбивает  входной
поток  на элементы,  а генератор назначает этим элементам определенную
структуру. Потоки управления в этом случае представляются в виде:
</p>

<pre>

      лексические правила      грамматические правила
                 |                               |                 
              Lex                             Yacc                   
                 |                               |
    Вход ==> yyLex               yyparse ==> Выход

</pre>

<p>
     Дополнительные программы,  выполненные  другим  генератором   или
вручную, легко взаимодействуют с системой Lex.
</p>

<p>
     Интерфейсом между  системами  Lex  и  yacc  служит  идентификатор
yylex,  который  зарезервирован  в  системе  yacc под имя лексического
анализатора.
</p>

<p>
     Lex генерирует  детерминированные  конечные атоматы,  разбирающие
регулярные  выражения.  Таким  образом   Lex   -   не   генератор,   а
интерпретатор.   В   результате   получается   скоростной  анализатор.
Конкретно,  время   распознавания   и   разбивания   входного   потока
пропорционально его длине.  Количество правил и их сложность не влияют
на скорость, если конечно, в системе правил нет таких, которые требуют
возврата к уже обработанной части входных данных. Единственное, на что
влияет количество  и  сложность  правил  -  это  на  размер  конечного
автомата, и, соответственно, на размер генерируемой программы.
</p>

<p>
     В программе,  сгенерированной  системой   Lex,   пользовательские
фрагменты   (реализующие   действия,   выполняемые   после  нахождения
регулярной  структуры)  рассматриваются   как   варианты   управляющей
структуры  типа switch языка Си.  Интерпретатор автоматов осуществляет
поток управления.  Пользователь может легко вставлять  любые  описания
или  дополнительные  операторы в процедуры,  выполняющие эти действия,
или добавлять внешние процедуры.  Lex не ограничивает размеры входного
потока.  Например, если существуют два правила: одно ожидающее "ab", а
другое - abcdefg ,  а входная строка - abcdefh, то Lex распознает ab и
остановит   входной  указатель  перед  ad.  Это  более  наглядно,  чем
обработка простейших языков.
</p>

<h2>
    <a name="m2"> 2. Исходный текст на языке Lex</a>
</h2>

<p>
     В общем формат исходного текста таков:

</p>
<pre>
     { описания }
     %%
     { правила }
     %%
     { процедуры пользователя }
</pre>
<p>
     где разделы описания и процедур  пользователя  часто  опускаются.
Второе сочетание %% не обязательно, а первое служит для пометки начала
правил. Абсолютно минимальная программа на языке Lex выглядит просто:
</p>

<pre>
     %%
</pre>

<p>
     (нет описаний,  нет  правил),  которая  транслируется  в   другую
программу, копирующую вход на выход без изменений.
</p>

<p>
     В абрисе  программы  Lex'a,   приведенном   выше,   эти   правила
представляют  определенную  пользователем  структуру:  они  сведены  в
таблицу,  в которой левая колонка содержит регулярные  выражения  (см.
главу 3),  а правая - действия, т.е. программные фрагменты, подлежащие
выполнению,  если выражение распознается.  Так отдельное правило может
иметь вид:
</p>

<pre>
     integer printf("found keyword INT");
</pre>

<p>
     Для того,  чтобы  напечатать  сообщение "обнаружен код INT",  как
только будет прочитано сочетание "integer" во входном потоке.  В  этом
примере  для  языка  Си  (в  роли головного) "printf" - функция печати
строки.  Конец выражения идентифицируется первым пробелом или символом
табуляции. Если действие - просто единичное выражение языка Си, то оно
должно быть просто  помещено  в  правую  часть  строки;  если  же  оно
достаточно  сложно  или  содержит  несколько  строк,  то  должно  быть
заключено  в  фигурные  скобки.  Как  немного  более  типичный  пример
рассмотрим  перевод  нескольких  слов  с  "британского" английского на
"американский". Правила системы Lex будут выглядеть так:
</p>

<pre>
     colour printf("color");
     mechanise printf("mechanize");
     petrol printf("gas");
</pre>

<p>
     Эта система правил,  конечно,  не обладает полнотой,  поскольку у
слова "petroleum" может получиться "gaseum";  как избежать этого - см.
далее.
</p>

<h2>
     <a name="m3">3. Регулярные выражения системы Lex</a>
</h2>

<p>
     Описания регулярных  выражений  весьма  напоминают  те,   которые
приведены в [5].
</p>

<p>
     Распознавание регулярных   выражений   выполняется    посредством
сопоставления  текстовой  строки  (содержащей  буквы и цифры) и строки
операторных символов (специфицирующих выбор,  повторение и пр.). Буквы
и цифры - это всегда текстовые символы;  поэтому регулярному выражению
57d соответствует строка 57d.
</p>

<p>
     Операторы. Операторные символы следующие:
</p>
<pre>
     " \ [] ^ - ? . * + | () $ / { } % <>

</pre>
<p>
     И если они используются в качестве символов текста,  должет  быть
использован   символ  \.  Оператор,  заключенный  в  двойные  кавычки,
означает, что то, что между ними находится - это текст. Так
</p>
<pre>
     xyz "++"
</pre>
<p>
     соответствует встретившейся строке xyz++. Отметим, что может быть
отмечена только часть строки.  Безвредно, но необязательно заключать в
кавычки единичные текстовые символы; выражение
</p>
<pre>
     "xyz++"
</pre>
<p>
     аналогично предыдущему.  Так,  заключая   в   кавычки   текстовые
символы,  пользователь  может  не  запоминать  список приведенных выше
операторных символов  и,  в  принципе,  этот  список  теперь  возможно
расширять.
</p>
<p>
     Операторный символ может так же  быть  преобразован  в  текстовый
использованием обратного слэша "\" как в выражении
</p>
<pre>
     xyz \+\+ ,

</pre>
<p>
     что является  другим,  менее читабельным эквивалентом предыдущего
выражения.  Еще  механизм  закавычевания  используется  для  помещения
пробела внутрь выражения;  как указывалось ранее, пробеелы и табуляции
заканчивают правило.  Любой пробел,  не заключенный  в  []  (см.ниже),
должен  быть  помещен  в  кавычки.  Некоторые стандартные для языка Си
комбинации с обратным слэшем \ так  же  распознаются:  \n  -  означает
новую  строку;  \t  -  табуляцию,  а \b - символ BS.  Для того,  чтобы
определить сам  символ  \,  используется  \\.  Там  где  новая  строка
недопустима в выражении,  должна использоваться комбинация \n;  но это
необязательно  для  табуляции  и  BS.  Любые  символы  кроме  пробела,
табуляции,  символа  перехода  на  новую строку и приведенных в списке
операторных, считаются текстовыми.
</p>
<p>
     Классы символов.  Классы  символов  могут  быть специфицированы с
использованием операторных скобок [].  Конструкция [abc] соответствует
единственному   символу,  который  может  быть  a,  b  или  с.  Внутри
квадратных  скобок  большинство  операторных  значений   игнорируется.
Только  три  символа  имеют  особый  смысл:  это суть \,  - и ^.  Тире
идентифицирует диапазоны.
</p>
<p>
     Например
</p>
<pre>
     [a-z0-9<>_]

</pre>
<p>
     - означает  символ,  который  может  быть одной из строчных букв,
одной из цифр, угловой скобкой или подчеркиванием. Диапазон может быть
задан в любом порядке. Если же между скобками находится пара символов,
которые одновременно не являются строчными, прописными или цифрами, то
реакция  зависит  от  реализации,  и  ей соответствует предупреждающее
сообщение (т.к.  в границах [0-2] в системе ASCII больше символов, чем
в  тех  же  границах  для  кода EBCDIC).  Если желательно включить сам
символ "тире" в класс символов,  то его можно поместить в  начало  или
конец; так сочетание
</p>
<pre>
     [-+0-9]
</pre>
<p>
     соответствует множеству цифр и двух арифметических знаков.
</p>
<p>
     В классах символов оператор ^ должен появляться как первый символ
после левой квадратной скобки;  он означает, что результирующая строка
не должна содержать указанное множество символов. Так

</p>
<pre>
     [^abc]

</pre>
<p>
     соответствует всем  символам,  кроме  a,  b  и  с,  включая   все
управляющие и специальные символы;а сочетание

</p>
<pre>
     [^a-zA-Z]

</pre>
<p>
     специфицирует любой   символ   -  не  букву.  Символ  \  означает
стандартную заменяющую комбинацию внутри квадратных скобок.
</p>
<p>
     Произвольный символ.  Оперативный  символ  "точка"  соответствует
любому   символу,   за   исключением    символа    перевода    строки.
Соответствующее   описание   с  использованием  слэша  выглядит  менее
компактным:

</p>
<pre>
     [\40-\176]

</pre>
<p>
     и означает  множество  всех  отображаемых  символов  кода  ASCII,
начиная от пробела и кончая тильдой ~.
<p>
    Ключевые выражения.  Оператор ?  идентифицирует ключевой элемент
выражения. Так
<p>
<pre>
    ab?c
</pre>
означает любое сочетание "ac" или "abc".

    Выражения-повторители. Повторения  классов идентифицируется опе-
раторами * и +.

</p>
<pre>
     а*

</pre>
<p>
     означает множество символов а,  которое может быть и пустым; в то
же время

</p>
<pre>
     а+

</pre>
<p>
     соответствует непустой последовательности. Например,
</p>
<pre>
                            [a-z]+

</pre>
<p>
     означает множество любых символьных строк,  состоящих из строчных
букв. А сочетание

</p>
<pre>
     [A-Za-z][A-Za-z0-9]*

</pre>
<p>
     обозначает все алфавитноцифровые  строки,  где  первый  символ  -
буква.  Это  типично  для  определения  идентификаторов в компьютерных
системах.
    Альтернативы и группировки. Оператор | означает альтернативу:

</p>
<pre>
     (ab|cd)

</pre>
<p>
     Это соответствует либо сочетанию ab, либо cd. Отметим, что скобки
использованы для группировки;  они могут отсутствовать для невложенных
выражений, так что допустимо сочетание вида

</p>
<pre>
     ab|cd

</pre>
<p>
     Скобки используются в достаточно сложныхх выражениях:

</p>
<pre>
     (ab|cd+)?(ef)*

</pre>
<p>
     Этому правилу соответствуют строки abefef, efefef, ccddef, cddd и
не соответствуют abc, abcd и abcdef.
</p>
<p>
     Чувствительность к  контексту.  Lex может распознавать лишь малую
часть окружающего контекста.  Два простых оператора для этого - ^ и $.
Если  первый символ правила есть ^,  то это означает,  что описываемое
выражение может располагаться только  в  начале  строки  (сразу  после
символа "конец строки" или в начале входного потока).  Символ ^ в этом
применении  не  конфликтует  с  другим  случаем  его  использованиядля
описания  классов символов,  т.к.  здесь он встречается вне квадратных
скобок. Если последний символ правила есть $, то описываемое выражение
может  располагаться  только  в  конце  строки  ( перед символом конца
строки). Последний оператор - особый случай оператора /. Выражение

</p>
<pre>
     ab/cd

</pre>
<p>
     соответствует сочетанию ab, следующему только за cd.
</p>
<p>
     Так

</p>
<pre>
     ab $

</pre>
<p>
     тоже самое, что и

</p>
<pre>
     ab / \ n

</pre>
<p>
     Левый контекст  обрабатывается  в системе Lex,  как будет описано
далее в главе 10.  Если правило обрабатывается  в  тот  момент,  когда
интерпретатор  конечного автомата находится в состоянии Х,  то правило
должно быть снабжено префиксом вида

</p>
<pre>
     < X > ,

</pre>
<p>
     т.е. с использованием угловых  скобок.  Если  мы  в  определенный
момент  рассматриваем  конец  входной  строки,  который  соответствует
стартовому состоянию ONE, то оператор ^ эквивалентен записи

</p>
<pre>
     <ONE>.

</pre>
<p>
     Стартовые состояния обсуждаются ниже.
</p>
<p>
     Повторения и  описания.  Фигурные   скобки,   заключающие   число
означают  повторение;  если  они заключают имя - то это уже расширение
описания. Например, сочетание

</p>
<pre>
     { цифра }

</pre>
<p>
     ищет предварительно  описанную  строку  под  названием  "цифра" и
вставляет ее в текущую точку в текущем выражении.  Сами  эти  описания
приведены в первой части входного потока системы Lex, перед правилами.
В противоположность этому

</p>
<pre>
     a{1,5}

</pre>
<p>
     ищет случаи a от 1 до 5.
</p>
<p>
     Наконец, помещенный в начале знак процента % означает разделитель
для сегментов во входном языке системы Lex.

</p>
<h2>
     <a name="m4">4. Действия в системе Lex</m4>
</h2>
<p>
     Если обнаружено соответствие выражения правилу,  то Lex выполняет
определенное действие.  В этой главе описываются средства, позволяющие
определять эти действия.  Отметим, что существует одно определенное по
умолчанию действие,  которое заключается в копировании входа на выход.
Оно выполняется  для  всех  выражений,  не  обязательно  распознанных.
Поэтому  пользователь  системы  Lex,  который  не  хочет продуцировать
какой-либо вывод,  не должен  задавать  никаких  правил  соответствия.
Когда  Lex  работает  совместно  с  системой  Yacc  -  это  нормальная
ситуация.
</p>
<p>
     Можно сказать,  что  это  сделано  заранее,  чтобы не писать свою
программу копирования;  в  целом  правило,  описывающее  тождественное
копирование,   может   быть  просто  пропущено.  Комбинация  символов,
описание которой пропущено, печатается на выходе без изменения, и этим
обращается внимание пользователя на пропуск в описаниях правил.
</p>
<p>
     Одним из простейших приемов является принудительное  инорирование
входа. Этого можно достичь, применяя пустой оператор языка Си:

</p>
<pre>
     ;

</pre>
<p>
     Часто встречается правило

</p>
<pre>
     [ \t\n] ;

</pre>
<p>
     оно означает,  что три непечатаемых символа (пробел,  табуляция и
символ новой строки) будут игнорироваться.
</p>
<p>
     Другой несложный   способ  избежать  распечатки  действий  -  это
применение символа |,  который означает,  что действие, поставленное в
соответствие   конкретному   правилу,  выполняется  и  для  следующего
правила. Предыдущий пример может быть переписан как

</p>
<pre>
     " "
     "\t"
     "\n"
</pre>
<p>
     Результат будет тот же,  только здесь используется другой  способ
записи. Кавычки вокруг \n и \t не обязательны.
</p>
<p>
     Пользователь часто желает,  чтобы при выполнении  многих  сложных
действий ему был известен текст,  соответствующий выражению типа [a-z]
+.  Система Lex содержит этот текст во внешнем символьном массиве  под
названием yytext.  Так, для печати обнаруженного имени можно применить
правило вида

</p>
<pre>
     [a-z]+ printf("%s", yytext);

</pre>
<p>
     Функция языка Си printf принимает формат и данные; в нашем случае
формат  "напечатай  строку" состоит из символов %  и S,  а данные - из
переменной yytext. Так что эта функция помещает соответствующую строку
в  выходной  поток.  Это действие имеет настолько общий характер,  что
получило символическое обозначение ECHO:

</p>
<pre>
     [a-z]+ ECHO;

</pre>
<p>
     Поскольку это стандартное действие просто  печатает  обнаруженные
символы,  может  возникнуть  вопрос  -  для  чего  заводить  отдельное
правило, которое выполняет действие по умолчанию.
</p>
<p>
     Такие правила  часто необходимы для избежания соответствия другим
правилам - которые не требуются в данном случае. Раз'яснения см. ниже.
</p>
<p>
     Иногда бывает  более  удобным  знать момент окончания разбора;  в
счетчике yyleng система Lex накапливает количество  символов,  которым
найдено соответствие.  Чтобы подсчитать одновременно количество слов и
количество символов во входном потоке, пользователь может написать

</p>
<pre>
     [a-zA-Z]+ {words++; chars += yyleng;}

</pre>
<p>
     Это выражение будет аккумулировать в переменной chars  количество
символов  в распознанных словах.  Последний символ в строке может быть
получен так: yytext[yyleng-1].
</p>
<p>
     Иногда действие  системы Lex может решить,  что правило не сумело
распознать  какую-либо  последовательность  символов.  В  этом  случае
удобно  использовать  две  процедуры.  Первая,  yymore(),  может  быть
вызвана  с  целью   определить   существующее   следующее   подлежащее
распознаванию  входное  выражение.  Нормально следующая входная строка
должна заместить текущую в переменной yytext. Вторая, yyless(n), может
быть  вызвана  для определения количества символов текущего выражения,
оставшихся неразобранными. Аргумент n индицирует количество символов в
yytext, которые подлежать сохранению. Последующие символы возвращаются
во входной поток. Это средство аналогично одной из форм оператора /.
</p>
<p>
     Пример: рассмотрим  язык,  который описывает строку как множество
символов между двойными кавычками (") и включает саму кавычку в текст,
если   ей   предшествует   обратный   слэш  \.  Регулярное  выражение,
соответствующее этому, достаточно сложно, так что предпочтительно было
бы написать

</p>
<pre>
     \"[^"]* {
     if (yytext[yyleng-1] == '\\') yymore();
     else ... normal user processing
     }
</pre>
<p>
     Когда система Lex  при  обработке  этого  правила  столкнется  со
строкой вида "abc|"def", то первая часть правила будет соответствовать
пяти символам "abc\;  тогда произойдет вызов функции yymore(), который
приведет  к  тому,  что  оставшаяся  часть  строки будет прикреплена к
концу.  Отметим,  что последняя  кавычка,  завершающая  строку,  будет
обработана кодом, помеченным как "нормальная обработка".
</p>
<p>
     Функция yyless()  может  быть  использована  для   преобразования
текста в разных обстоятельствах. Рассмотрим проблему компилятора Си по
различению двусмысленного выражения "=-а". Предположим, что необходимо
обратиться  к  нему как к "=-а" и напечатать сообщение.  Правило может
выглядеть так:

</p>
<pre>
     =-[a-zA-Z] {
     printf("Operator (=-) ambiguous\n");
     yyless(yyleng-1);
     ... action for =- ...
     }
</pre>
<p>
     Оно печатает сообщение,  возвращает  литеру  после  оператора  во
входной поток и обращается к оператору как к "=-".  Чтобы сделать это,
возвратим знак минуса в качестве обычной литеры во входной поток:

</p>
<pre>
     =-[a-zA-Z] {
     printf("Operator (=-) ambiguous\n");
     yyless(yyleng-2);
     ... action for = ...
     }
</pre>
<p>
     Это правило  выполнит  уже  другую  интерпретацию.  Заметим,  что
выражение для обоих этих случаев может быть легко записано как

</p>
<pre>
     =-/[A-Za-z]
</pre>
<p>
     и впервом случае, и как

</p>
<pre>
     =/-[A-Za-z]
</pre>
<p>
     во втором;   никаких   изменений   в  действиях,  поставленных  в
соответствие данному правилу, не требуется. Не обязательно, чтобы весь
распознаваемый  идентификатор  обладал свойством двусмысленности.  Для
возможного варианта "=-3" правило

</p>
<pre>
     =-/[^ \t\n]

</pre>
<p>
     является наилучшим.
</p>
<p>
     Кроме этих  процедур  возможен  доступ  к используемым процедурам
ввода/вывода системы Lex:
</p>
<p>
<ol>
     <li> input() - которая возвращает следующий входной символ;
     <li> output() - которая печатает символ С на выходе;
     <li> unput()  -  которая после чтения процедурой input() возвращает
символ во входной поток.
</ol>
</p>
<p>
     По умолчанию  эти процедуры доступны в качестве макроопределений,
но пользователь может заменить их собственными версиями. Эти процедуры
описаны  в  точке  между  внешними файлами и внутренними переменными и
могут   быть   модифицированы   последовательно.   Они   могут    быть
переопределены так, что ввод или вывод может происходить нестандартно,
например,  через другие программы или с использованием внешней памяти,
но множество используемых символов должно быть одинаково определено во
всех  процедурах;  нуль  на  вводе  должен   означать   конец   файла;
соответствие между процедурами input и unput должно сохраняться, иначе
Lex не сможет заглянуть вперед.  В обычном состоянии  система  Lex  не
заглядывает  вперед,  но  правила,  завершающиеся символами + * ?  или
содержащие / подразумевают эту  операцию.  Так  же  это  необходимо  в
случае,  когда  какое-либо  выражение является префиксом другого.  См.
ниже  обсуждение  множества  символов,  используемых  в  системе  Lex.
Стандартная  библиотека  системы  Lex допускает использование не более
100 символов.
</p>
<p>
     Еще одна библиотечная процедура системы Lex, которую пользователь
может переопределить и использовать в любой момент - это yywrap(); она
вызывается всякий раз, когда достигается конец файла. Если эта функция
возвращает 1, то система Lex будет отрабатывать циклический переход по
концу  ввода.  Но иногда удобней переключить систему на другой входной
поток.  В этом случае пользователь  должен  иметь  процедуру,  которая
делает это и возвращает 0.  Это заставит Lex продолжать обработку.  Но
по умолчанию yywrap всегда возвращает 1.
</p>
<p>
     Эта процедура  также  удобная точка в потоке обработки для печати
таблиц,  выводов и т.д.  в конце программы.  Заметим,  что  невозможно
написать   правило,   которое  распознавало  бы  символ  конца  файла;
единственный доступ  к  этому  состоянию  -  через  процедуру  yywrap.
Фактически,   если  не  используется  нестандартная  версия  процедуры
input(),  то файл,  содержащий машинные  нули  просто  не  может  быть
обработан, т.к. 0 соответствует концу файла.

</p>
<h2>
    <a name="m5"> 5. Двусмысленные правила в исходном тексте</a>

</h2>
<p>
     Lex способен   обрабатывать   двусмысленные   спецификации.  Если
текущему  вводу  соответствуют  более,  чем  одно  выражение,  система
поступает следующим образом:
</p>
<pre>
     1) Предпочтение отдается более длинному соответствию;
     2) Предпочтение отдается более раннему правилу.
</pre>
<p>
     Рассмотрим правила
</p>
<pre>
     integer keyword action ...;
     [a-z]+ identifier action ...;
</pre>
<p>
     Если на входе integers ,  то выбирается  идентификатор,  так  как
выражение  [a-z]+  соответствует 8 символам,  в то время как сочетание
"integer" содержит только 7.  Если же на входе  строка  "integer",  то
выбирается правило для ключевого слова,  т.к. оно описано ранее. Более
короткое  сочетание  (например,  "int")  не  соответствует   выражению
integer, так что рассматривается как идентификатор.
</p>
<p>
     Описанные принципы  предпочтения  более   длинного   соответствия
делают   применение  правил,  содержащих  выражения  типа  .*,  весьма
опасным.  Например,  выражение ".*" может показаться очень удобным для
распознавания  строки  в  кавычках.  Но  оно побудит систему "залезть"
далеко вперед, в поисках отдаленной кавычки. Так, если на входе

</p>
<p>
     "first" закавыченная строка здесь, "second" здесь,

</p>
<p>
     то это соответствует выражению

</p>
<p>
     "first" закавыченная строка здесь, "second",

</p>
<p>
     что, вероятно,  нежелательно. Более применимо правило '[^'\n]*' ,
которое  вызовет  прекращение  поиска  после  "first".  Надо,  однако,
призначть, что оператор "точка" (.) не соответствует переходу на новую
строку. Это выражение вызовет останов на текущей строке. И не пробуйте
победить эту проблему, используя правило вроде [.\n]+, сгенерированное
системой  Lex.Программа  попытается  прочесть  весь входной файл,  что
приведет к переполнению внутреннего буфера.
</p>
<p>
     Отметим, что в нормальном состоянии система Lex разбивает входной
поток на части и  не  ищет  все  возможные  соответствия  для  каждого
выражения.  Это  означает,  что  каждый символ обрабатывается не более
одного раза.  Например,  предположим,  что необходимо  подсчитать  все
вхождения местоимений she (она) и he (он) в текст.  Правила могут быть
такими:

</p>
<pre>
     she s++;
     he h++;
     \n |
     . ;
</pre>
<p>
     Здесь последние  два правила заставляют систему игнорировать все,
кроме искомых местоимений.  Вспомним, что точка "." не включает символ
перехода  на новую строку.  Поскольку сочетание she содержит сочетание
he, то Lex будет нормально не распознавать отдельно эти вхождения.
</p>
<p>
     Иногда пользователь  может захотеть изменить это положение вещей.
Директива  REJECT  означает  "двигаться  к  следующей   альтернативе".
Применение  ее  приведет к тому,  что каким бы не было второе правило,
выполниться то, которое находится вслед за текущим. Положение входного
указателя изменится соответственно.  Допустим,  что пользователь хочет
считать и сочетания he, входящие в состав she:


</p>
<pre>
     she {s++; REJECT;}
     he {h++; REJECT;}
     \n |
     . ;
</pre>
<p>
     Эти правила - один из способов изменить  предыдущий  пример  так,
чтобы  он выполнял новое желание пользователя.  Каждое выражение после
подсчета режектируется (отвергается); каким бы оно не было подходящим,
теперь  будет  подсчитываться  уже другое выражение.  В нашем примере,
разумеется,  пользователь может отметить, что выражение "she" включает
"he", а не наоборот и, поэтому, действие REJECT для he можно опустить,
но в других случаях  иногда  бывает  сложно  априорно  сказать,  какие
классы пересекаются и как.
</p>
<p>
     Рассмотрим два правила:

</p>
<pre>
     a[bc]+ { ... ; REJECT;}
     a[cd]+ { ... ; REJECT;}
</pre>
<p>
     Вход ab соответствует первому правилу, вход cd - второму. Входная
строка accb соответствует первому правилу  -  как  четыре  символа,  и
второму  - как три.  В противоположность этому - вход accd согласуется
со вторым правилом в качестве четырехсимвольного сочетания, и с первым
- в качестве трехсимвольного.
</p>
<p>
     В целом применение REJECT удобно всякий раз,  когда цель  системы
Lex  -  не  разделение входной строки на части,  а детектирование всех
возможных элементов входного потока,  причем  эти  эксперименты  могут
перекрываться  и  содержать  друг друга.  Предположим,  что необходима
гистограмма  входного  потока;   обычно   гистограмма   не   запрещает
перекрытий,  так  что  из  слова  the  она  рассмотрит и th и he.  Для
заполнения двуразмерной матрицы digram применимо правило

</p>
<pre>
     %%
     [a-z][a-z] {digram[yytext[0]][yytext[1]]++; REJECT;}
     \n ;
</pre>
<p>
     где REJECT необходим для выбора символьных  пар,  начинающихся  с
каждой буквы, но не с других символов.

</p>
<h2>
    <a name="m6"> 6.Описания в исходном тексте системы Lex</a>
</h2>
<p>
     Вспомним формат исходного текста на языке системы Lex:

</p>
<pre>
     {definitions}
     %%
     {rules}
     %%
     {user routines}
</pre>
<p>
     Ранее был описан только раздел правил. Но пользователю необходимы
дополнительные средства, которые позволяли бы ему описывать переменные
для использования в программах и в системе Lex.  Они могут содержаться
и в секции описаний и в секции правил.
</p>
<p>
     Вспомним, что Lex превращает правила в программу.  Любой фрагмент
исходного текста,  не  обрабатываемый  системой  Lex,  копируется  без
изменения  в  генерируемую  программу.  Этот  процесс  происходит  под
управлением трех правил:
</p>
<p>
     1) Любая  строка,  не  являющаяся  частью  правила  или действия,
которая начинается с пробела или табуляции,  копируется в генерируемую
программу без изменения.  Та из них, которая предваряется разделителем
%%,  будет внешней по отношению ко всем  функциям  кода,  если  строка
появляется  непосредственно  после первого такого разделителя,  то она
помещается на место для описаний внутри сгенерированной  системой  Lex
функции,  содержащей  действия.  Этот  материал  должен  выглядеть как
фрагмент программы и располагаться перед первым  правилом  в  исходном
тексте.  Побочным  эффектом  этого  является  тот  факт,  что  строки,
начинающиеся с пробела или табуляции и содержащие комментарий,  просто
пропускаются в генерируемую программу. Это может быть использовано для
того,  чтобы  включить   комментарии   либо   в   исходный,   либо   в
сгенерированный текст.  Формат комментария должен следовать принятым в
языке соглашениям.
</p>
<p>
     2) Любой   текст,   заключенный  между  %{  и  %},  копируется  в
результирующую программу как и в предыдущем случае.  Сами  разделители
удаляются.   Этот  формат  позволяет  вводить  текст  типа  операторов
прдпроцессора,  которые должны начинаться с первой колонки  и  которые
отличны по внешнему виду от операторов программы.
</p>
<p>
     3) Любой текст после третьего ограничителя  %,  типа  форматов  и
пр., помещается в конце выходного потока системы Lex.
</p>
<p>
     Описания, предназначенные  для  системы  Lex,  вставляются  перед
первым разделителем %%.  Любая строка из этой секции,  не содержащаяся
между %{ и %}  и  начинающаяся  с  первой  колонки,  используется  для
описания макроподстановок. Формат этих строк следующий:

</p>
<pre>
     имя значение
</pre>
<p>
     И это   означает,   что   данное   значение   теперь  ставится  в
соответствие данному имени.  Имя  и  перевод  должны  разделяться  как
минимум одним пробелом,  имя должно начинаться с буквы.  Перевод может
быть затем "вызван" в тексте правила конструкцией {имя}. Используя {D}
для  цифр  и  {E} для десятичных разрядов ,  можно получить компактную
форму для системы правил распознавания чисел:

</p>
<pre>
     D [0-9]
     E [DEde][-+]?{D}+
     %%
     {D}+ printf("integer");
     {D}+"."{D}*({E})? |
     {D}*"."{D}+({E})? |
     {D}+{E} printf("real");
</pre>
<p>
     Заметим, что  первые  два  правила   соответствуют   вещественным
числам;  оба  требуют  наличия  десятичной  точки  и содержат описание
десятичных разрядов,  но первое требует  хотя  бы  одной  цифры  перед
десятичной  точкой,  а  второе  - после нее.  Для корректной обработки
необычных ситуаций типа фортрановского выражения 35.EQ.I,  которое  не
содержит  вещественного числа,  необходимо включение правила обработки
контекста:

</p>
<pre>
     [0-9]+/"."EQ printf("integer");

</pre>
<p>
     Раздел описаний может содержать также следующие команды,  включая
выбор головного языка,  таблицу символов,  список стартовых состояний,
управление размерами массивов, принятыми по умолчанию, необходимые для
функционирования  сложных  программ.  Эти средства описываются в главе
"сводка правил по исходному формату".

</p>
<h2>
     <a name="m7">7. Использование</a>

</h2>
<p>
     Процесс компиляции программ на языке Lex состоит из двух  циклов.
Первый шаг состоит в том,  что исходный текст компилируется в текст на
одном из высокоуровневых  языков.  Затем  эта  программа  должна  быть
откомпилирована    с    использованием    библиотек    системы    Lex.
Сгенерированная программа помещается в файл  с  именем  Lex.yy.c.  Эта
библиотека  построена по стандартным правилам системы программирования
Си и называется library6.
</p>
<p>
     Сгенерированная программа на языке Си имеет некоторые особенности
в системе OS/370,  т.к.  компилятор этой системы менее мощный,  чем  в
системах UNIX или GCOS.  Программы же,  сгенерированные в GCOS и UNIX,
идентичны.
</p>
<p>
     UNIX. Доступ  к  библиотеке  достигается  с  использованием флага
загрузчика - ll. Соответсвующий набор команд:

</p>
<pre>
     Lex source
     cc Lex.yy.c -ll
</pre>
<p>
     Результирующая программа помещается по умолчанию в файл a.out для
последующего выполнения. Как компоновать Lex с системой Yacc см. ниже.
Большинство  процедур  ввода/вывода системы Lex используют стендартную
библиотеку языка Си,  а автоматные процедуры в этом не нуждаются; если
применяются  нестандартные  версии  процедур ввода/вывода,  библиотека
может не использоваться.

</p>
<h2>
  <a name="m8">8. Lex и Yacc</a>
</h2>
<p>
     Если вы  хотите  использовать  системы  Lex  и  Yacc   совместно,
отметьте,  что Lex генерирует выходную функцию под именем yyLex(), что
соответствует стандартному имени для лексического анализатора  системы
Yacc. По умолчанию главная программа вызывает эту процедуру, но если в
память загружена система yacc и используется ее главная программа,  то
вызывается  yylex().  В  этом случае каждое правило системы Lex должно
завершаться командой

</p>
<pre>
     return(token);

</pre>
<p>
     в которой  возвращалось  бы  соответствующее   токену   значение.
Простейшим  способом установления соответствия между именами токенов и
программой на языке Lex является компиляция выходного файла Lex'a  как
части входного файла Yacc'a, включающего строку

</p>
<pre>
     #include "Lex.yy.c"

</pre>
<p>
     Грамматика "good"  и  лексическое правило "better" в системе UNIX
сопрягаются командами

</p>
<pre>
     yacc good
     Lex better
     cc y.tab.c -ly -ll
</pre>
<p>
     Библиотека системы  Yacc  (-ly)  должна  быть   загружена   перед
библиотекой  системы  Lex для принятия ведущей роли разборщику Yacc'a.
Все поколения программ на языках Lex и  Yacc  сопрягаются  в  этом  же
порядке.

</p>
<h2>
     <a name="m9">9. Примеры</a>
</h2>
<p>
     В качестве  простой задачи рассмотрим копирование входного файла,
причем к каждому положительному числу, делящемуся на 7, добавляется 3.
Перед вами соответствующая программа на языке системы Lex:

</p>
<pre>
     %%
     int k;
     [0-9]+ {
     k = atoi(yytext);
     if (k%7 == 0) printf("%d", k+3);
     else printf("%d",k);
     }
</pre>
<p>
     Правило [0-9]+  распознает строки цифр.  Функция atoi преобразует
символы в число и запоминает результат  в  переменной  k.  Оператор  %
используется для определения делимости k на 7; если число делится на 7
без остатка,  оно увеличивается на 3.  Понятно,  что результаты  будут
неверными,  если во входной строке содержатся элементы вроде 49.63 или
Х7.  Более того,  эта программа  будет  обрабатывать  и  отрицательные
числа,  что  противоречит  условию.  Для  устранения  этого недостатка
добавим несколько правил:

</p>
<pre>
     %%
     int k;
     -?[0-9]+ {
     k = atoi(yytext);
     printf("%d", k%7 == 0 ? k+3 : k);
     }
     -?[0-9.]+ ECHO;
     [A-Za-z][A-Za-z0-9]+ ECHO;
</pre>
<p>
     Числовые строки,  содержащие точку или букву, будут отсеяны одним
из последних правил.  Структура "если - то"  представлена  операторами
языка Си; выражение "а?b:c" означает "если а то б, иначе с".
</p>
<p>
     Рассмотрим пример   накопления   статистической   информации    -
программу построения гистограммы длин слов, где слово представляется в
виде строки символов.

</p>
<pre>
     int lengs[100];
     %%
     [a-z]+ lengs[yyleng]++;
     . |
     \n ;
     %%
     yywrap()
     {
     int i;
     printf("Length No. words\n");
     for(i=0; i<100; i++)
     if (lengs[i] > 0)
     printf("%5d%10d\n",i,lengs[i]);
     return(1);
     }
</pre>
<p>
     Эта программа строит гистограмму,  но не  производит  какого-либо
вывода.  По  окончании  ввода  программа  печатает таблицу.  Последний
оператор  -  return(1);  он  означает,  что  система   Lex   выполняет
циклический  переход.  Если функция yywrap возвращает нуль (ложь),  то
это означает,  что на входе еще есть информация и программа продолжает
чтение и обработку. Если использовать вариант этой функции, который не
возвращает значение "истина",  то результатом будет  бесконечный  цикл
обработки.
</p>
<p>
     Более сложный пример - куски программы,  написанной  Н.Л.Шлайером
(Scheyer)  для  преобразования  фортрановских чисел двойной точности в
числа одинарной точности.  Поскольку Фортран не разделяет прописных  и
строчных  букв,  эта  процедура  начинается  с  определения  множества
классов, включающих оба варианта использования букв:

</p>
<pre>
     a [aA]
     b [bB]
     c [cC]
     ...
     z [zZ]
</pre>
<p>
     Еще один класс распознает пробелы:

</p>
<pre>
     W [ \t]*
</pre>
<p>
     Следующее правило превращает словосочетание "double precision"  в
"real", или "DOUBLE PRECISION" в "REAL".

</p>
<pre>
     {d}{o}{u}{b}{l}{e}{W}{p}{r}{e}{c}{i}{s}{i}{o}{n} {
     printf(yytext[0]=='d'? "real" : "REAL");
     }
</pre>
<p>
     К этому  приему  пришлось  прибегнуть,  чтобы  предотвратить сбой
программы,  если вдруг в  исходном  тексте  содержатся  и  строчные  и
прописные  буквы.  Для  выделения  правильной  формы  ключевого  слова
используется условный оператор. Следующее правило позволяет пропустить
строки, не содержащие константы:

</p>
<pre>
     ^" "[^ 0] ECHO;
</pre>
<p>
     В регулярном    выражении    кавычки    окружают   пробелы.   Это
интерпретируется  как  "начало  строки,  затем   5   пробелов,   затем
что-нибудь   не  равное  нулю  или  пробелу".  Отметим  два  различных
использования  символа  ^.  Дальнейшая  часть  программы  служит   для
превращения констант двойной точности в одинарную.

</p>
<pre>
     [0-9]+{W}{d}{W}[+-]?{W}[0-9]+ |
     [0-9]+{W}"."{W}{d}{W}[+-]?{W}[0-9]+ |
     "."{W}[0-9]+{W}{d}{W}[+-]?{W}[0-9]+ {
     /* convert constants */
     for(p=yytext; *p != 0; p++) {
     if (*p == 'd' || *p == 'D') *p += 'e'- 'd';
     ECHO;
     }
</pre>
<p>
     После того, как распознается плавающая константа, она сканируется
в  цикле  for  для  поиска  в  ее составе литеры "D".  Затем программа
заменяет все "D" на "Е",  кстати, Е - следующая за "D" буква алфавита.
И  модифицированная  константа  печатается  на  выходе.  Далее следуют
правила  для  описания  серии  идентификаторов  процедур   и   функций
нормальной точности,  которые должны быть снабжены префиксом "D".  При
помощи массива yytext это действие выполняется для всех указанных имен
(здесь приведен сокращенный их список).

</p>
<pre>
     {d}{s}{i}{n} |
     {d}{c}{o}{s} |
     {d}{s}{q}{r}{t} |
     {d}{a}{t}{a}{n} |
     ...
     {d}{f}{l}{o}{a}{t} printf("%s",yytext+1);
</pre>
<p>
     В именах из следующего списка D заменяется на А:

</p>
<pre>
     {d}{l}{o}{g} |
     {d}{l}{o}{g}10 |
     {d}{m}{i}{n}1 |
     {d}{m}{a}{x}1 {
     yytext[0] =+ 'a' - 'd'; ECHO;
     }
</pre>
<p>
     И одна процедура должна сменить букву "D" на "R":

</p>
<pre>
     {d}1{m}{a}{c}{h} yytext[0] += 'r' - 'd';
</pre>
<p>
     Для того,   чтобы   избежать  случая,  когда  имена  вроде  dsinx
рассматриваются  вместо  dsin,  следующие  правила  выбирают   слишком
длинные  слова и идентификаторы и просто копируют символы;  входящие в
них:

</p>
<pre>
     [A-Za-z][A-Za-z0-9]* |
     [0-9]+ |
     \n |
     . ECHO;
</pre>
<p>
     Остается добавить,  что  эта  программа  приведена  не полностью;
опущены вопросы о количестве пробелов  между  единицами  компиляции  в
Фортране   и   о   возможном   использовании   ключевых   слов  вместо
идентификаторов и др.

</p>
<h2>
     <a name="m10">10. Чувствительность к левому контексту</a>
</h2>
<p>
     Иногда бывает  желательно  иметь  несколько  наборов  лексических
правил, применяемых в разные моменты времени к одному и тому же вводу.
Например,  препроцессор,  входящий в состав компилятора,  должен уметь
различать  директивы  препроцессора  от обычных операторов языка.  Это
требует  чувствительности  к  предварительному   контексту,   и   есть
несколько способов решения этой проблемы.  Например,  оператор ^ - это
оператор    предварительного     контекста,     который     распознает
непосредственно предшествующий левый контекст, тогда как $ - оператор,
распознающий правый контекст.  Примыкающий левый контекст  может  быть
расширен настолько, что естественным образом будет смыкаться с правым,
но,  вероятно,  это будет не слишком удобно, т.к. нередко актуальный в
данный   момент   левый   контекст   появляется  гораздо  раньше,  чем
потреебуется, например - в начале строки.
</p>
<p>
     В этой  главе  содержится  описание трех средств,  обеспечивающих
контекстную   чувствительность:   простейшее   использование   флагов,
позволяющее  изменять  действие  нескольких  правил  в  зависимости от
ситуации;  использование стартовых условий для  правил;  использование
нескольких работающих одновременно лексических анализаторов.  В каждом
случае существуют правила,  которые распознают возникновение  ситуации
смены  условий  обработки  входного  потока  и инициируют переключение
неких параметров,  определяющих состояние  процесса.  Это  может  быть
флаг,  тестируемый исключительно пользовательским кодом;  такой флаг -
простейшее средство разрешения проблемы. Может быть более удобным было
бы  использование этих флагов в качестве начальных условий для правил.
Каждому правилу может быть поставлено в соотвествие начальное условие.
Они  тестируются  только  один  раз,  когда  система  Lex  находится в
стартовой кондиции.  В этот  момент  и  может  быть  изменено  текущее
начальное  условие  функционирования  анализатора.  И,  наконец,  если
наборы правил для разных ситуаций  очень  различны,  то  можно  просто
написать  несколько отдельных лексических анализаторов и переключаться
между ними, когда требуется.
</p>
<p>
     Рассмотрим следующую  задачу:  копировать вход на выход,  изменяя
слово "magic" на слово "first" в каждой строке,  которая начинается  с
символа  "а",  на  слово "second",  если строка начинается с "в" ,и на
"third" - если  с  "с".  Все  остальные  слова  в  других  строках  не
изменяются.
</p>
<p>
     Правила достаточно просты,  и целесообразнее  всего  использовать
флаги:

</p>
<pre>
     int flag;
     %%
     ^a {flag = 'a'; ECHO;}
     ^b {flag = 'b'; ECHO;}
     ^c {flag = 'c'; ECHO;}
     \n {flag = 0 ; ECHO;}
     magic { switch (flag) {
     case 'a':
     printf("first"); break;
     case 'b':
     printf("second"); break;
     case 'c':
     printf("third"); break;
     default: ECHO; break;
     }
     }
</pre>
<p>
     Для решения той же  задачи  с  использованием  стартовых  условий
необходимо ввести каждое такое условие в секцию описаний в виде

</p>
<pre>
     %start name1 name2 ...

</pre>
<p>
     где условия могут располагаться в любой последовательности.
</p>
<p>
     Слово start  может  быть  сокращено  до  s.  Условия  могут  быть
специфицированы  в  заготовке  как  правила  в  ограничениях <и>:<имя>
выражение - это правило,  которое разпознается,  если Lex находится  в
стартовой  кондиции  name1.  Для ввода стартовой кондиции используется
оператор

</p>
<pre>
     BEGIN name1;
</pre>
<p>
     который переключает стартовую кондицию  в  положение  name1.  Для
возвражения в нормальное состояние достаточно написать

</p>
<pre>
     BEGIN 0;
</pre>
<p>
     Эта команда   сбрасывает   интерпретатор   конечных  автоматов  в
исходное состояние. Правило может быть активным в нескольких стартовых
кондициях:

</p>
<pre>
     <name1,name2,name3>
</pre>
<p>
     Любое правило, не начинающееся с префикса <>, считается активным.
</p>
<p>
     В свете изложенного решение предыдущей задачи можно представить в
виде

</p>
<pre>
     %START AA BB CC
     %%
     ^a {ECHO; BEGIN AA;}
     ^b {ECHO; BEGIN BB;}
     ^c {ECHO; BEGIN CC;}
     \n {ECHO; BEGIN 0;}
     &lt;AA&gt;magic printf("first");
     &lt;BB&gt;magic printf("second");
     &lt;CC&gt;magic printf("third");
</pre>
<p>
     где логика  аналогична применяемой в предыдущем варианте решения,
но здесь Lex не работает раньше пользовательского кода.

</p>
<h2>
     <a name="m11">11. Множество символов</a>
</h2>
<p>
     Программы, сгенерированные  системой  Lex,  выполняют  ввод/вывод
только   через   процедуры  input,  output  и  unput.  Таким  образом.
последовательность   символов,   проходящих   через   эти   процедуры,
воспринимается  системой  Lex  и  передается в переменной yytext.  Для
внутреннего применения символ представляется как целое число, которое,
если  используется  стандартная  библиотека,  имеет  значение,  равное
битовому  представлению  этого  числа  в  конкретной  ЭВМ.  Литера   а
представляется  в той же форме,  что и символьная константа "а".  Если
представление изменяется посредством изменения процедур  ввода/вывода,
которые  транслируют  символы,  то необходимо об этом сообщить системе
Lex,  поместив информацию в таблицу  трансляции.  Эта  таблица  должна
располагаться  в  секции  описаний  и  быть  ограничена строками "%T".
Таблица должна содержать строки вида

</p>
<pre>
     {целое} {строка символов}
</pre>
<p>
     которые устанавливают соответствие между символом  и  его  кодом.
Следующий пример

</p>
<pre>
     %T
     1 Aa
     2 Bb
     ...
     26 Zz
     27 \n
     28 +
     29 -
     30 0
     31 1
     ...
     39 9
     %T
</pre>
<p>
     отображает строчные  и  прописные символы в целые числа - от 1 до
26,  символ перевода строки - в число 27,  + и - соответственно в 28 и
29, а цифры - в числа с 30 до 39. Т.е. код перевода строки совпадает с
ESC.
</p>
<p>
     Если используется  эта  или подобная ей таблица,  то в нее должен
быть включен каждый символ,  который только может появиться на входе и
который  признается допустимым.  Никакой символ не может быть назначен
числу 0 или числу, превосходящему размер множества символов для данной
ЭВМ.

</p>
<h2>
     <a name="m12">12. Сводка правил по исходному формату</a>
</h2>
<p>
     Общий формат текста на языке Lex имееет вид:

</p>
<pre>
     {definitions}
     %%
     {rules}
     %%
     {user subroutines}
</pre>
<p>
     Секция определений   и   описаний   -  это  комбинация  следующих
составных частей:
</p>
<ol>
     <li> Описание в форме "имя пробел перевод";
     <li> Включаемый код в форме "пробел код";
     <li> Включаемый код в форме % { код %};
     <li> Стартовые кондиции в форме
<pre>
     %S имя 1 имя 2 ...;
     <li> Таблица символов в форме
     %T число пробел строка
     ...
     %T
</pre>
     <li> Описание  размеров  массивов  в  форме  %x  nnn,  где  nnn   -
десятичное  число,  представляющее собой размер массива,  а x означает
имя массива параметров из перечня:
</ol>

<CENTER>
<TABLE BORDER=1>
<TR>
	<TD> Символ</TD>
	<TD> Параметр</TD>
</TR>
<TR>
	<TD>p </TD>
	<TD>позиции</TD>
</TR>
<TR>
	<TD>n</TD>
	<TD>состояния</TD>
</TR>
<TR>
	<TD>e</TD>
	<TD>узлы дерева</TD>
</TR>
<TR>
	<TD>a</TD>
	<TD>переходы</TD>
</TR>
<TR>
	<TD>k</TD>
	<TD>упакованные классы символов</TD>
</TR>
<TR>
	<TD>o</TD>
	<TD>размер выходного массива</TD>
</TR>
</TABLE>
</CENTER>

<p>
     Строки в  секции  правил  имеют  флому "выражение действие",  где
действия могут быть продолжены на следующую строку,  если заключены  в
фигурные скобки.
</p>
<p>
     Регулярные выражения в  системе  Lex  используют  следующие  виды
операторов:

</p>
<pre>
     x символ "Х"
     "x" "Х", даже если Х - оператор;
     W "Х", даже если Х - оператор;
     [xy] символ Х или Y;
     [x-z] символы Х, Y или Z;
     [^x] любой символ, кроме Х;
     . любой символ, кроме перевода строки;
     ^x Х в начале строки;
     <y>x Х, если Lex в состоянии Y;
     x$ Х в конце строки;
     x? возможный (optional) X;
     x* 0, 1, 2, ... случай Х;
     x+ 1, 2, 3 ... случай Х;
     x|y Х или Y;
     (x) X;
     x/y X, если он следует за Y;
     {xx} трансляция ХХ из секции описаний;
     x{m,n} возможные значения x от m до n.
</pre>
<h2>
     <a name="m13">13. Каверны и жучки</a>

</h2>
<p>
     Существуют патологические   выражения,   которые    приводят    к
экспоненциальному росту размеров таблиц для детерминированных конечных
автоматов; к счастью, это случается редко.
</p>
<p>
     Директива REJECT не позволяет повторно читать ввод;  вместо этого
она запоминает результат предыдущего сканирования.  Это означает,  что
если   обнаружено   правило   с  прикрепленным  к  нему  контекстом  и
выполняется REJECT,  то пользователь не должен использовать  процедуру
unput   во   избежание   изменения   символов,  ожидающих  ввода.  Это
единственное    ограничение    на    возможности    пользователя    по
манипулированию еще не обработанным входом.

</p>
<h2>
     <a name="m14">14. Благодарности</a>

</h2>
<p>
     Как становится   очевидным   из   вышесказанного,  внешне  Lex  -
продолжение системы Yacc,  а внутри - машина Ахо  (Aho).  Не  случайно
S.C.Джонсон (Johnson) и А.В.Ахо - настоящие авторы системы Lex, так же
как и отладчики ее. Множество благодарностей им обоим за все.
</p>
<p>
     Код описываемой  версии  системы  Lex  был  разработан  и отлажен
Эриком Шмидтом (Schmidt).

</p>
<h2>
     <a name="m15">15. Литература</a>
</h2>
<p>
<ol>
     <li> B. W. Kernighan and D. M. Ritchie, The C Programming Language,
Prentice-Hall, N. J. (1978).

     <li> B.  W.  Kernighan,  Ratfor:  A  Preprocessor  for  a  Rational
Fortran, Software - Practice and Experience, 5, pp. 395-496 (1975).

     <li> S.  C. Johnson, Yacc: Yet Another Compiler Compiler, Computing
Science Technical Report No. 32, 1975, Bell Laboratories, Murray Hill,
NJ 07974.

     <li> A.  V.  Aho and M.  J. Corasick, Efficient String Matching: An
Aid to Bibliographic Search, Comm. ACM _18, 333-340 (1975).

     <li> B.  W.  Kernighan,  D. M. Ritchie and K. L. Thompson, QED Text
Editor,  Computing  Science  Technical  Report  No.  5,   1972,   Bell
Laboratories, Murray Hill, NJ 07974.

     <li> D. M. Ritchie, private communication. See also M. E. Lesk, The
Portable C Library,  Computing Science Technical Report No.  31,  Bell
Laboratories, Murray Hill, NJ 07974.
</ol>

<hr>
<p>
Перевод: (с) Constantin E. Climentieff aka DrMad,<br>
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> * 
<a href="http://www.chat.ru/~drmad">http://www.chat.ru/~drmad</a>
</p>
<body>
</html>

    </td>
    </tr>
    </table>
    </td>

    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>

</body>
</html>

