<html>
<body>

<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>Взаимодействие LabView с программными моделями объектов внешнего мира</TITLE>
<style type="text/css">
   BODY {font-family:Arial; font-size:10pt; margin-left:10;margin-right:10} 
   TD {font-family:Arial; font-size:10pt}
   P {font-family:Arial; font-size:10pt; text-align:justify}
   LI {font-family:Arial; font-size:10pt}
   UL {font-family:Arial; font-size:10pt}   
   PRE {font-family:Tahoma; font-size:10pt}
   STRONG  {font-family:Arial; font-size:10pt}
   CENTER {font-family:Arial; font-size:10pt}
</style>	
</head>

<body>
<table align="center" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="50"></td>
    <td width="70%" height="50" align="center"><b><font face="arial black" size="+4" color="Teal">DRMADСКОЕ БАРАХЛО</font></b></td>
    <td width="15%" height="50"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="teal"></td>
    <td width="70%" height="25" bgcolor="teal"></td>
    <td width="15%" height="25" bgcolor="teal"></td>
</tr>
<tr>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
    <td width="70%" height="25" bgcolor="#60C0C0"></td>
    <td width="15%" height="25" bgcolor="#60C0C0"></td>
</tr>
<tr>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
    <td width="70%" height="100%">
	
	<table border="0" bordercolor="teal" width="100%" height="100%" cellpadding="10">
	<tr>
	<td>
	
<TABLE ALIGN=CENTER CELLPADDING=0 BGCOLOR="Teal" WIDTH="100%" HEIGHT="60" border="0">
<TR>
<TD ALIGN="CENTER">
<B>
<FONT FACE="Arial" color="white" SIZE="4">
Взаимодействие LabView с программными моделями объектов внешнего мира<BR>
</B>
</FONT>
</TD>
</TR>
</TABLE>

<font face="Arial" size="-1">
       
<p align="justify"><h2>Введение</h2>
       
<p align="justify">В этой статье мне хотелось бы напомнить об одном очень простом, но эффективном 
трюке, который позволяет отлаживать LabView-программы, взаимодействующие в реальном 
времени со внешними объектами. Если самого объекта нет (например, предполагается 
"домашняя" отладка), то его роль вполне может сыграть автономная программа, написанная на 
любом языке программирования. (Примечание. Если вам кажется, что проще всего модель 
сделать тоже на LabView и оформить как часть отлаживаемой программы, то вы ошибаетесь. 
Сложная модель и громоздкая система связей могут похоронить под собой отлаживаемую 
программу).
<p align="justify">Сам я пользуюсь этим трюком давным-давно, но не встречал, чтобы он упоминался кем-
нибудь в Интернете. Вероятно, "непрограммисты" не подозревают о существовании подобного 
трюка, а "труЪ кодерам" сочинять программы на LabView западло. :) Как бы то ни было, речь 
пойдет вот о чем (см. рис. 1).
<center><img src="lm001.gif"></center>
       
<h2>1. Постановка задачи</h2>
       
<p align="justify">Написание программной модели внешнего объекта проиллюстрируем на примере 
емкости, заполняемой и опустошаемой через трубы (см. рис. 2). Пропускная способность 
выходной трубы - константа W куб/c, на трубе стоит регулируемая задвижка. Удельная скорость 
подачи жидкости через первую трубу - случайная величина, распределенная равномерно на 
интервале  0..W куб/c. Емкость цилиндрическая диаметром R см и высотой H см.
<center><img src="lm002.gif"></center>        
<p align="justify">К емкости прикреплен поплавковый датчик уровня, выход которого преобразуется 8-
битовым АЦП. Необходимо при помощи LabView-программы следить за объемом жидкости и 
поддерживать его в интервале от Vmin до Vmax куб.
       
<h2>2. Физическая модель</h2>
       
<p align="justify">Сначала составим физическую модель происходящего в баке:
<ul> 
<li>W1:=Random[0..W] - сколько жидкости втекает;
<li>Если задвижка открыта, то W2:=W, иначе W2:=0 - сколько жидкости вытекает; 
<li><font face="Symbol">D</font>V := W1-W2 - изменение объема жидкости в баке за единицу времени;
<li>V := V + <font face="Symbol">D</font>V - новое значение объема;
<li>L := V/ пR<sup>2</sup> - новое значение уровня жидкости;
<li>X := (L/H)*255 - код на выходе АЦП;
<li>T := T + <font face="Symbol">D</font>T  - приращение времени.
</ul>
<p align="justify">Теперь нужно, чтобы:
<ul>
<li>LabView-программа могла получать изменяющиеся значения переменной X;
<li>Программа-модель могла получать от LabView-программы признак состояния 
задвижки - открыта она или закрыта.
</ul> 
       
<h2>3.Организация разделяемой памяти</h2>
       
<p align="justify">Для обмена данными между моделирующей и управляющей программами удобней 
всего использовать "разделяемую" (т.е. общую) память. В Windows она организовывается при 
помощи специальным образом скомпилированной и скомпонованной DLL, которая загружается 
в разные адресные пространства (в нашем случае это LabView и программная модель объекта), 
и ее переменные равно доступны для всех процессов этих адресных пространств. Рассмотрим, 
как изготовить такую DLL. (Подробней про изготовление "обычных" DLL и про подключение их к 
LabView модно прочитать <a href="lvdll.html">здесь</a>).
       
<h3>3.1. Компиляторы Borland C/C++ и  Borland C/C++ Builder</h3>
       
<p align="justify">Исходный текст для библиотеки будет выглядеть следующим образом. Обратите 
внимание на два важных обстоятельства: 1) прагмы описания сегмента должны появиться в 
тексте до включения файла windows.h; 2)  разделяемые переменные обязательно должны быть 
проинициализированы какими-нибудь значениями. Итак, файл sharedll.cpp:
<code><pre>       
#pragma option -zRSHARESEG   // Имя сегмента
#pragma option -zTSHARECLS   // Класс сегмента
__int8  Valve = 1; // Задвижка
__int16 ADC   = 0; // Код АЦП

#include &lt;windows.h&gt;
#pragma argsused

// Функции для доступа к переменным извне
void _export _stdcall SetADC(WORD x) { // Изменить код на АЦП
 ADC = x;
}
void _export __stdcall GetADC(WORD *x) { // Прочитать код с АЦП
 *x = ADC;
}
void _export __stdcall ValvOn() { // Открыть задвижку
 Valve = 1;
}
void _export __stdcall ValvOff() { // Закрыть задвижку
 Valve = 0;
}
BYTE _export __stdcall GetValv() { // Узнать состояние задвижки
 return Valve;
} 
</pre></code>
<p align="justify">Не забудем включить в проект файл sharedll.def, в котором описываются правила замены 
сгенерированных компилятором странных имена типа "@SetADC$qqsus" на "нормальные" 
имена типа "SetADC". (Подробней про "манглинг" имен см. <a href="lvdll.html">здесь</a>).

<code><pre>SEGMENTS 
SHARESEG CLASS "SHARECLS" SHARED 
EXPORTS
SetADC=@SetADC$qqsus
GetADC=@GetADC$qqspus
ValvOn=@ValvOn$qqsv
ValvOff=@ValvOff$qqsv
GetValv=@GetValv$qqsv
</pre></code>       
<p align="justify">После построения проекта получается файл sharedll.dll, содержащий две "общие" переменные 
ADC и Valve и экспортирующий набор функций для доступа к ним извне. 
       
<h3>3.2.  Компиляторы MS Visual C/C++ и Visual Studio C/C++</h3>

<p align="justify">Исходный текст для библиотеки будет выглядеть следующим образом. Обратите 
внимание на два важных обстоятельства: 1) прагмы описания сегмента должны появиться в 
тексте до включения файла windows.h; 2)  разделяемые переменные обязательно должны быть 
проинициализированы какими-нибудь значениями. Итак, файл sharedll.cpp:
       
<code><pre>       
#include &lt;windows.h&gt;
#include "stdafx.h"

#define EXPORT extern "C" __declspec (dllexport)

#pragma data_seg("SHARESEG")
extern BYTE Valve=1; // Задвижка
extern WORD ADC=0;   // Код АЦП
#pragma data_seg()

EXPORT void CALLBACK _stdcall SetADC(WORD x) { // Изменить код на АЦП
 ADC = x;
}
EXPORT void CALLBACK __stdcall GetADC(WORD *x) { // Прочитать код с АЦП 
*x = ADC;
}
EXPORT void CALLBACK __stdcall ValvOn() { // Открыть задвижку
 Valve = 1;
}
EXPORT void CALLBACK __stdcall ValvOff() { // Закрыть задвижку
 Valve = 0;
}
EXPORT BYTE CALLBACK __stdcall GetValv() { // Узнать состояние задвижки
 return Valve;
}
</pre></code>       
<p align="justify">Не забудем включить в проект файл sharedll.def, в котором описываются правила замены 
сгенерированных компилятором странных имена типа "GetADC@4" на "нормальные" имена 
типа "GetADC". (Подробней про "манглинг" имен см. <a href="lvdll.html">здесь</a>).
<code><pre>
EXPORTS
 SetADC @1
 GetADC @2
 ValvOn  @3
 ValvOff @4
 GetValv @5
</pre></code>
<p align="justify">После построения проекта получается файл sharedll.dll, содержащий две "общие переменные" 
ADC и Valve и экспортирующий набор функций для доступа к ним извне. 
 
<h3>3.3. Иные способы создания разделяемой памяти</h3>  

<p align="justify">К сожалению, описанный выше метод разделения памяти, использующий специально 
оформленные DLL, возможен только для некоторых компиляторов/компоновщиков с языков 
С/C++. При помощи Borland Delphi или MS Visual Basic тоже можно изготавливать DLL (см. <a href="lvdll.html">здесь</a>), 
но они не будут содержать "разделяемых" переменных.

<p align="justify">В качестве альтернативы можно использовать универсальный способ, пригодный для любых 
языков программирования (за исключением, естественно, ориентированных на виртуальные 
машины, например, Java) . Он основан на отображении файлов на память при помощи API-
функции CreateFileMapping(), которой в качестве первого аргумента передается не хэндл какого-
нибудь реально существующего файла, а 0xFFFFFFFF. В этом случае файл все равно будет создан, 
но не на диске, а в памяти. Если два приложения откроют файл с одним и тем же именем, они 
смогут обмениваться данным через него. Но такой подход кажется неудобным в нашем случае, 
так как одно из наших приложений - программа на LabView.   (Я пробовал, все работает, но 
действительно не очень удобно ).

<p align="justify">Так же стоит упомянуть "хакерский" метод. При помощи программы HIEW можно попробовать 
изменить флаги свойств секции данных для DLL, не имевшей разделяемой памяти, с 0хС0000040 
на 0xD0000040.  На свой страх и риск.

<center><img src="lm003.gif"></center>

<h2>4.  Программная модель объекта</h2>

<p align="justify">В п. 2 была описана физическая модель работы емкости. Она может быть оформлена на любом 
языке программирования примерно вот таким образом. (Примечание. Константы - 
геометрические параметры бака, пропускные способности труб и т.п. подобраны из 
соображений более или менее "красивой картинки" ).

<p align="justify">Вот вариант на Си (компилятор Borland C/C++ 5.5):
<code><pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
typedef void (WINAPI* SETADC_TYPE)(WORD);
typedef void (WINAPI* GETADC_TYPE)(WORD *);
typedef void (WINAPI* VALVON_TYPE)();
typedef void (WINAPI* VALVOFF_TYPE)();
typedef BYTE (WINAPI* GETVALV_TYPE)();
main() {
 // Блокирование запуска 2-ой копии программы
 HANDLE m = CreateMutex( NULL, TRUE, "SHAREDLL_MUTEX" );
 if (GetLastError()==ERROR_ALREADY_EXISTS) exit(0);
 // Загрузка DLL и получение адресов функций
 HANDLE h = LoadLibrary("sharedll.dll"); if (!h) exit(0);
 SETADC_TYPE  SetADC  = (SETADC_TYPE)  GetProcAddress ( h, "SetADC"  );
 GETADC_TYPE  GetADC  = (GETADC_TYPE)  GetProcAddress ( h, "GetADC"  );
 VALVON_TYPE  ValvOn  = (VALVON_TYPE)  GetProcAddress ( h, "ValvOn"  );
 VALVOFF_TYPE ValvOff = (VALVOFF_TYPE) GetProcAddress ( h, "ValvOff" );
 GETVALV_TYPE GetValv = (GETVALV_TYPE) GetProcAddress ( h, "GetValv" );
 // Константы моделирования
 int V=0;     // Текущий объем жидкости в баке
 int T=0;     // Текущее время
 int R=30;    // Радиус бака
 int H=110;   // Высота бака
 int Vmax = (int)( (double)(R*R) * 3.1415926 )*H; // Объем бака
 int W=5000; // Пропускная способность труб
 int W1, W2;  // Объемы впуска и слива в ед. времени
 int L=0;     // Текущий уровень жидкости в баке
 WORD X, Y;   // Код АЦП
 int DV;      // Изменение объема
 ValvOff();   // Первоначально слив закрыт
 // Бесконечный цикл моделирования работы емкости
 while (1) {
  W1 = random(W);                                   // Сколько втекает
  if (GetValv()) W2=W; else W2=0;                   // Сколько вытекает
  DV = W1-W2;                                       // Изменение объема
  V = V + DV;                                       // Новый объем
  if (V&gt;Vmax) V=Vmax; if (V&lt;0) V=0;                 // Коррекция объема
  L = (int)((double)V/((double)(R*R)*3.1415926));   // Новый уровень
  X = (WORD)(((double)L/(double)H)*256.0);          // Код АЦП
  SetADC(X);
  T = T+1;
  Sleep(500);
#define DBG
#ifdef DBG
  GetADC(&Y);
  printf("\nW1=%6d W2=%6d DV=%6d V=%6d L=%3d X=%3d Valv=%1d Y=%3d", 
         W1, W2, DV, V, L, X, GetValv(), Y);
#endif
 }
}
</pre></code>
<p align="justify">Программа оформлена в виде простого консольного приложения. Она загружает DLL 
динамически, ищет в ней нужные функции, определяет их адреса и в дальнейшем обращается к 
ним. С другой стороны, к этим же функциям этой же DLL будет обращаться LabView-программа.  
В качестве минимального сервиса в программе предусмотрена блокировка повторного запуска.

<p align="justify">У программы довольно много направлений совершенствования. Например, я предпочитаю 
делать такие программы в виде оконного приложения (т.е. с точкой входа WinMain(), а не main() 
), но окно не открывать, а сразу сворачивать его в трей (туда, где живут "часики"). Так же, для моделирования
"быстрых" объектов может потребоваться пересчитывать время не 2 раза в секунду, а, например, 100 раз, указав
Sleep(10). (Примечание. Для "быстрых" объектов придется пожертвовать выводом на экран, т.к. printf() просто
не сможет так быстро рисовать буковки и циферки).

<h2>5.  Управляющая программа</h2>

<p align="justify">Итак, модель емкости разработана и запущена - она незаметно висит в памяти и в режиме 
реального времени видоизменяет параметры процесса втекания и вытекания жидкости. Теперь 
разработаем LabView-приложение, которое будет мониторить этот процесс, управлять им и т.п. 
Собственно говоря, ради этого приложения вся каша и заваривалась.  Ведь можно обойтись без 
демонтажа реального бака, стоящего на производстве или в лаборатории, без перевозки его 
домой и без установки на кухне или в ванной - его роль будет исполнять написанная нами ранее 
моделирующая программка. А LabView-программу можно сочинять, отлаживать и вылизывать 
автономно.  

<p align="justify">Вот пример простейшего приложения, отображающего уровни жидкости и управляющего 
задвижкой "вручную". Техника подключения к DLL описана здесь.

<p align="justify">Это чтение 8-битового кода с АЦП.
<center><img src="lm005.gif"></center>

<p align="justify">Это управление задвижкой.
<center><img src="lm006.gif"></center> 

<p align="justify">Это блок-схема управления системой.
<center><img src="lm007.gif"></center>

<p align="justify">Ну а это передняя панель.
<center><img src="lm008.gif"></center>
<p align="justify">Можете теперь дома усовершенствовать это приложение - например, добавить автоматическое открытие-закрытие 
задвижки, включить в обратную связь ПИД-регулятор и т.п. А потом принести готовый результат на работу.

<p align="justify"> Общее примечание. Порой, это трюк годится не только для простеньких студенческих лабораторок, но
и при отладке довольно сложных систем. Сигналы, идущие с датчиков, при этом не моделируются, а сначала
записываются на реальном объекте, а в процессе моделирования считываются из файла.

</font>


<hr>
<center>
(с) Constantin E. Climentieff aka DrMad,
<a href="mailto:drmad@dr.com"> mailto: drmad@dr.com</a> * <a href="http://drmad.chat.ru/">http://drmad.chat.ru</a>
</center>
	
	
	</td>
	</tr>
	</table>
	</td>
    <td width="15%" height="100%" bgcolor="#60C0C0"></td>
</tr>
</table>
 
</body>
</html>